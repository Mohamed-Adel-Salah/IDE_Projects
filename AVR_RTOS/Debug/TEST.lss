
TEST.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .text         00004cc0  00000000  00000000  00000094  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .data         000000b4  00800060  00004cc0  00004d54  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  2 .bss          00000663  00800114  00800114  00004e08  2**0
                  ALLOC
  3 .stab         0000a908  00000000  00000000  00004e08  2**2
                  CONTENTS, READONLY, DEBUGGING
  4 .stabstr      000064a1  00000000  00000000  0000f710  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
       0:	0c 94 2a 00 	jmp	0x54	; 0x54 <__ctors_end>
       4:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
       8:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
       c:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      10:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      14:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      18:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      1c:	0c 94 61 09 	jmp	0x12c2	; 0x12c2 <__vector_7>
      20:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      24:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      28:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      2c:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      30:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      34:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      38:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      3c:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      40:	0c 94 8c 02 	jmp	0x518	; 0x518 <__vector_16>
      44:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      48:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      4c:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      50:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>

00000054 <__ctors_end>:
      54:	11 24       	eor	r1, r1
      56:	1f be       	out	0x3f, r1	; 63
      58:	cf e5       	ldi	r28, 0x5F	; 95
      5a:	d8 e0       	ldi	r29, 0x08	; 8
      5c:	de bf       	out	0x3e, r29	; 62
      5e:	cd bf       	out	0x3d, r28	; 61

00000060 <__do_copy_data>:
      60:	11 e0       	ldi	r17, 0x01	; 1
      62:	a0 e6       	ldi	r26, 0x60	; 96
      64:	b0 e0       	ldi	r27, 0x00	; 0
      66:	e0 ec       	ldi	r30, 0xC0	; 192
      68:	fc e4       	ldi	r31, 0x4C	; 76
      6a:	02 c0       	rjmp	.+4      	; 0x70 <.do_copy_data_start>

0000006c <.do_copy_data_loop>:
      6c:	05 90       	lpm	r0, Z+
      6e:	0d 92       	st	X+, r0

00000070 <.do_copy_data_start>:
      70:	a4 31       	cpi	r26, 0x14	; 20
      72:	b1 07       	cpc	r27, r17
      74:	d9 f7       	brne	.-10     	; 0x6c <.do_copy_data_loop>

00000076 <__do_clear_bss>:
      76:	17 e0       	ldi	r17, 0x07	; 7
      78:	a4 e1       	ldi	r26, 0x14	; 20
      7a:	b1 e0       	ldi	r27, 0x01	; 1
      7c:	01 c0       	rjmp	.+2      	; 0x80 <.do_clear_bss_start>

0000007e <.do_clear_bss_loop>:
      7e:	1d 92       	st	X+, r1

00000080 <.do_clear_bss_start>:
      80:	a7 37       	cpi	r26, 0x77	; 119
      82:	b1 07       	cpc	r27, r17
      84:	e1 f7       	brne	.-8      	; 0x7e <.do_clear_bss_loop>
      86:	0e 94 14 23 	call	0x4628	; 0x4628 <main>
      8a:	0c 94 5e 26 	jmp	0x4cbc	; 0x4cbc <_exit>

0000008e <__bad_interrupt>:
      8e:	0c 94 00 00 	jmp	0	; 0x0 <__vectors>

00000092 <GIE_Enable>:
      92:	8f b7       	in	r24, 0x3f	; 63
      94:	80 68       	ori	r24, 0x80	; 128
      96:	8f bf       	out	0x3f, r24	; 63
      98:	08 95       	ret

0000009a <GIE_Disable>:
	SET_BIT(SREG,GIE);
}

void GIE_Disable(void)
{
	CLR_BIT(SREG,GIE);
      9a:	8f b7       	in	r24, 0x3f	; 63
      9c:	8f 77       	andi	r24, 0x7F	; 127
      9e:	8f bf       	out	0x3f, r24	; 63
}
      a0:	08 95       	ret

000000a2 <DIO_voidSetPinDirection>:
	DIO_voidSetPinValue(PortA,Pin1,High);
}

void 	DIO_voidSetPinDirection (u8 PortId,u8 PinId,u8 Direction)
{
	if(Direction==Output)
      a2:	41 30       	cpi	r20, 0x01	; 1
      a4:	b1 f5       	brne	.+108    	; 0x112 <DIO_voidSetPinDirection+0x70>
	{
		switch(PortId)
      a6:	81 30       	cpi	r24, 0x01	; 1
      a8:	99 f0       	breq	.+38     	; 0xd0 <DIO_voidSetPinDirection+0x2e>
      aa:	81 30       	cpi	r24, 0x01	; 1
      ac:	30 f0       	brcs	.+12     	; 0xba <DIO_voidSetPinDirection+0x18>
      ae:	82 30       	cpi	r24, 0x02	; 2
      b0:	d1 f0       	breq	.+52     	; 0xe6 <DIO_voidSetPinDirection+0x44>
      b2:	83 30       	cpi	r24, 0x03	; 3
      b4:	09 f0       	breq	.+2      	; 0xb8 <DIO_voidSetPinDirection+0x16>
      b6:	65 c0       	rjmp	.+202    	; 0x182 <DIO_voidSetPinDirection+0xe0>
      b8:	21 c0       	rjmp	.+66     	; 0xfc <DIO_voidSetPinDirection+0x5a>
		{
			case 0: SET_BIT(DDRA,PinId); break;
      ba:	2a b3       	in	r18, 0x1a	; 26
      bc:	81 e0       	ldi	r24, 0x01	; 1
      be:	90 e0       	ldi	r25, 0x00	; 0
      c0:	02 c0       	rjmp	.+4      	; 0xc6 <DIO_voidSetPinDirection+0x24>
      c2:	88 0f       	add	r24, r24
      c4:	99 1f       	adc	r25, r25
      c6:	6a 95       	dec	r22
      c8:	e2 f7       	brpl	.-8      	; 0xc2 <DIO_voidSetPinDirection+0x20>
      ca:	28 2b       	or	r18, r24
      cc:	2a bb       	out	0x1a, r18	; 26
      ce:	08 95       	ret
			case 1: SET_BIT(DDRB,PinId); break;
      d0:	27 b3       	in	r18, 0x17	; 23
      d2:	81 e0       	ldi	r24, 0x01	; 1
      d4:	90 e0       	ldi	r25, 0x00	; 0
      d6:	02 c0       	rjmp	.+4      	; 0xdc <DIO_voidSetPinDirection+0x3a>
      d8:	88 0f       	add	r24, r24
      da:	99 1f       	adc	r25, r25
      dc:	6a 95       	dec	r22
      de:	e2 f7       	brpl	.-8      	; 0xd8 <DIO_voidSetPinDirection+0x36>
      e0:	28 2b       	or	r18, r24
      e2:	27 bb       	out	0x17, r18	; 23
      e4:	08 95       	ret
			case 2: SET_BIT(DDRC,PinId); break;
      e6:	24 b3       	in	r18, 0x14	; 20
      e8:	81 e0       	ldi	r24, 0x01	; 1
      ea:	90 e0       	ldi	r25, 0x00	; 0
      ec:	02 c0       	rjmp	.+4      	; 0xf2 <DIO_voidSetPinDirection+0x50>
      ee:	88 0f       	add	r24, r24
      f0:	99 1f       	adc	r25, r25
      f2:	6a 95       	dec	r22
      f4:	e2 f7       	brpl	.-8      	; 0xee <DIO_voidSetPinDirection+0x4c>
      f6:	28 2b       	or	r18, r24
      f8:	24 bb       	out	0x14, r18	; 20
      fa:	08 95       	ret
			case 3: SET_BIT(DDRD,PinId); break;
      fc:	21 b3       	in	r18, 0x11	; 17
      fe:	81 e0       	ldi	r24, 0x01	; 1
     100:	90 e0       	ldi	r25, 0x00	; 0
     102:	02 c0       	rjmp	.+4      	; 0x108 <DIO_voidSetPinDirection+0x66>
     104:	88 0f       	add	r24, r24
     106:	99 1f       	adc	r25, r25
     108:	6a 95       	dec	r22
     10a:	e2 f7       	brpl	.-8      	; 0x104 <DIO_voidSetPinDirection+0x62>
     10c:	28 2b       	or	r18, r24
     10e:	21 bb       	out	0x11, r18	; 17
     110:	08 95       	ret
		}
	}
	else
	{
		switch(PortId)
     112:	81 30       	cpi	r24, 0x01	; 1
     114:	99 f0       	breq	.+38     	; 0x13c <DIO_voidSetPinDirection+0x9a>
     116:	81 30       	cpi	r24, 0x01	; 1
     118:	28 f0       	brcs	.+10     	; 0x124 <DIO_voidSetPinDirection+0x82>
     11a:	82 30       	cpi	r24, 0x02	; 2
     11c:	d9 f0       	breq	.+54     	; 0x154 <DIO_voidSetPinDirection+0xb2>
     11e:	83 30       	cpi	r24, 0x03	; 3
     120:	81 f5       	brne	.+96     	; 0x182 <DIO_voidSetPinDirection+0xe0>
     122:	24 c0       	rjmp	.+72     	; 0x16c <DIO_voidSetPinDirection+0xca>
		{
			case 0: CLR_BIT(DDRA,PinId); break;
     124:	2a b3       	in	r18, 0x1a	; 26
     126:	81 e0       	ldi	r24, 0x01	; 1
     128:	90 e0       	ldi	r25, 0x00	; 0
     12a:	02 c0       	rjmp	.+4      	; 0x130 <DIO_voidSetPinDirection+0x8e>
     12c:	88 0f       	add	r24, r24
     12e:	99 1f       	adc	r25, r25
     130:	6a 95       	dec	r22
     132:	e2 f7       	brpl	.-8      	; 0x12c <DIO_voidSetPinDirection+0x8a>
     134:	80 95       	com	r24
     136:	82 23       	and	r24, r18
     138:	8a bb       	out	0x1a, r24	; 26
     13a:	08 95       	ret
			case 1: CLR_BIT(DDRB,PinId); break;
     13c:	27 b3       	in	r18, 0x17	; 23
     13e:	81 e0       	ldi	r24, 0x01	; 1
     140:	90 e0       	ldi	r25, 0x00	; 0
     142:	02 c0       	rjmp	.+4      	; 0x148 <DIO_voidSetPinDirection+0xa6>
     144:	88 0f       	add	r24, r24
     146:	99 1f       	adc	r25, r25
     148:	6a 95       	dec	r22
     14a:	e2 f7       	brpl	.-8      	; 0x144 <DIO_voidSetPinDirection+0xa2>
     14c:	80 95       	com	r24
     14e:	82 23       	and	r24, r18
     150:	87 bb       	out	0x17, r24	; 23
     152:	08 95       	ret
			case 2: CLR_BIT(DDRC,PinId); break;
     154:	24 b3       	in	r18, 0x14	; 20
     156:	81 e0       	ldi	r24, 0x01	; 1
     158:	90 e0       	ldi	r25, 0x00	; 0
     15a:	02 c0       	rjmp	.+4      	; 0x160 <DIO_voidSetPinDirection+0xbe>
     15c:	88 0f       	add	r24, r24
     15e:	99 1f       	adc	r25, r25
     160:	6a 95       	dec	r22
     162:	e2 f7       	brpl	.-8      	; 0x15c <DIO_voidSetPinDirection+0xba>
     164:	80 95       	com	r24
     166:	82 23       	and	r24, r18
     168:	84 bb       	out	0x14, r24	; 20
     16a:	08 95       	ret
			case 3: CLR_BIT(DDRD,PinId); break;
     16c:	21 b3       	in	r18, 0x11	; 17
     16e:	81 e0       	ldi	r24, 0x01	; 1
     170:	90 e0       	ldi	r25, 0x00	; 0
     172:	02 c0       	rjmp	.+4      	; 0x178 <DIO_voidSetPinDirection+0xd6>
     174:	88 0f       	add	r24, r24
     176:	99 1f       	adc	r25, r25
     178:	6a 95       	dec	r22
     17a:	e2 f7       	brpl	.-8      	; 0x174 <DIO_voidSetPinDirection+0xd2>
     17c:	80 95       	com	r24
     17e:	82 23       	and	r24, r18
     180:	81 bb       	out	0x11, r24	; 17
     182:	08 95       	ret

00000184 <DIO_voidSetPinValue>:
	}
}

void DIO_voidSetPinValue(u8 PortId,u8 PinId,u8 Value)
{
	if(Value==High)
     184:	41 30       	cpi	r20, 0x01	; 1
     186:	b1 f5       	brne	.+108    	; 0x1f4 <DIO_voidSetPinValue+0x70>
	{
		switch(PortId)
     188:	81 30       	cpi	r24, 0x01	; 1
     18a:	99 f0       	breq	.+38     	; 0x1b2 <DIO_voidSetPinValue+0x2e>
     18c:	81 30       	cpi	r24, 0x01	; 1
     18e:	30 f0       	brcs	.+12     	; 0x19c <DIO_voidSetPinValue+0x18>
     190:	82 30       	cpi	r24, 0x02	; 2
     192:	d1 f0       	breq	.+52     	; 0x1c8 <DIO_voidSetPinValue+0x44>
     194:	83 30       	cpi	r24, 0x03	; 3
     196:	09 f0       	breq	.+2      	; 0x19a <DIO_voidSetPinValue+0x16>
     198:	65 c0       	rjmp	.+202    	; 0x264 <DIO_voidSetPinValue+0xe0>
     19a:	21 c0       	rjmp	.+66     	; 0x1de <DIO_voidSetPinValue+0x5a>
		{
			case 0: SET_BIT(PORTA,PinId); break;
     19c:	2b b3       	in	r18, 0x1b	; 27
     19e:	81 e0       	ldi	r24, 0x01	; 1
     1a0:	90 e0       	ldi	r25, 0x00	; 0
     1a2:	02 c0       	rjmp	.+4      	; 0x1a8 <DIO_voidSetPinValue+0x24>
     1a4:	88 0f       	add	r24, r24
     1a6:	99 1f       	adc	r25, r25
     1a8:	6a 95       	dec	r22
     1aa:	e2 f7       	brpl	.-8      	; 0x1a4 <DIO_voidSetPinValue+0x20>
     1ac:	28 2b       	or	r18, r24
     1ae:	2b bb       	out	0x1b, r18	; 27
     1b0:	08 95       	ret
			case 1: SET_BIT(PORTB,PinId); break;
     1b2:	28 b3       	in	r18, 0x18	; 24
     1b4:	81 e0       	ldi	r24, 0x01	; 1
     1b6:	90 e0       	ldi	r25, 0x00	; 0
     1b8:	02 c0       	rjmp	.+4      	; 0x1be <DIO_voidSetPinValue+0x3a>
     1ba:	88 0f       	add	r24, r24
     1bc:	99 1f       	adc	r25, r25
     1be:	6a 95       	dec	r22
     1c0:	e2 f7       	brpl	.-8      	; 0x1ba <DIO_voidSetPinValue+0x36>
     1c2:	28 2b       	or	r18, r24
     1c4:	28 bb       	out	0x18, r18	; 24
     1c6:	08 95       	ret
			case 2: SET_BIT(PORTC,PinId); break;
     1c8:	25 b3       	in	r18, 0x15	; 21
     1ca:	81 e0       	ldi	r24, 0x01	; 1
     1cc:	90 e0       	ldi	r25, 0x00	; 0
     1ce:	02 c0       	rjmp	.+4      	; 0x1d4 <DIO_voidSetPinValue+0x50>
     1d0:	88 0f       	add	r24, r24
     1d2:	99 1f       	adc	r25, r25
     1d4:	6a 95       	dec	r22
     1d6:	e2 f7       	brpl	.-8      	; 0x1d0 <DIO_voidSetPinValue+0x4c>
     1d8:	28 2b       	or	r18, r24
     1da:	25 bb       	out	0x15, r18	; 21
     1dc:	08 95       	ret
			case 3: SET_BIT(PORTD,PinId); break;
     1de:	22 b3       	in	r18, 0x12	; 18
     1e0:	81 e0       	ldi	r24, 0x01	; 1
     1e2:	90 e0       	ldi	r25, 0x00	; 0
     1e4:	02 c0       	rjmp	.+4      	; 0x1ea <DIO_voidSetPinValue+0x66>
     1e6:	88 0f       	add	r24, r24
     1e8:	99 1f       	adc	r25, r25
     1ea:	6a 95       	dec	r22
     1ec:	e2 f7       	brpl	.-8      	; 0x1e6 <DIO_voidSetPinValue+0x62>
     1ee:	28 2b       	or	r18, r24
     1f0:	22 bb       	out	0x12, r18	; 18
     1f2:	08 95       	ret
		}
	}
	else
	{
		switch(PortId)
     1f4:	81 30       	cpi	r24, 0x01	; 1
     1f6:	99 f0       	breq	.+38     	; 0x21e <DIO_voidSetPinValue+0x9a>
     1f8:	81 30       	cpi	r24, 0x01	; 1
     1fa:	28 f0       	brcs	.+10     	; 0x206 <DIO_voidSetPinValue+0x82>
     1fc:	82 30       	cpi	r24, 0x02	; 2
     1fe:	d9 f0       	breq	.+54     	; 0x236 <DIO_voidSetPinValue+0xb2>
     200:	83 30       	cpi	r24, 0x03	; 3
     202:	81 f5       	brne	.+96     	; 0x264 <DIO_voidSetPinValue+0xe0>
     204:	24 c0       	rjmp	.+72     	; 0x24e <DIO_voidSetPinValue+0xca>
		{
			case 0: CLR_BIT(PORTA,PinId); break;
     206:	2b b3       	in	r18, 0x1b	; 27
     208:	81 e0       	ldi	r24, 0x01	; 1
     20a:	90 e0       	ldi	r25, 0x00	; 0
     20c:	02 c0       	rjmp	.+4      	; 0x212 <DIO_voidSetPinValue+0x8e>
     20e:	88 0f       	add	r24, r24
     210:	99 1f       	adc	r25, r25
     212:	6a 95       	dec	r22
     214:	e2 f7       	brpl	.-8      	; 0x20e <DIO_voidSetPinValue+0x8a>
     216:	80 95       	com	r24
     218:	82 23       	and	r24, r18
     21a:	8b bb       	out	0x1b, r24	; 27
     21c:	08 95       	ret
			case 1: CLR_BIT(PORTB,PinId); break;
     21e:	28 b3       	in	r18, 0x18	; 24
     220:	81 e0       	ldi	r24, 0x01	; 1
     222:	90 e0       	ldi	r25, 0x00	; 0
     224:	02 c0       	rjmp	.+4      	; 0x22a <DIO_voidSetPinValue+0xa6>
     226:	88 0f       	add	r24, r24
     228:	99 1f       	adc	r25, r25
     22a:	6a 95       	dec	r22
     22c:	e2 f7       	brpl	.-8      	; 0x226 <DIO_voidSetPinValue+0xa2>
     22e:	80 95       	com	r24
     230:	82 23       	and	r24, r18
     232:	88 bb       	out	0x18, r24	; 24
     234:	08 95       	ret
			case 2: CLR_BIT(PORTC,PinId); break;
     236:	25 b3       	in	r18, 0x15	; 21
     238:	81 e0       	ldi	r24, 0x01	; 1
     23a:	90 e0       	ldi	r25, 0x00	; 0
     23c:	02 c0       	rjmp	.+4      	; 0x242 <DIO_voidSetPinValue+0xbe>
     23e:	88 0f       	add	r24, r24
     240:	99 1f       	adc	r25, r25
     242:	6a 95       	dec	r22
     244:	e2 f7       	brpl	.-8      	; 0x23e <DIO_voidSetPinValue+0xba>
     246:	80 95       	com	r24
     248:	82 23       	and	r24, r18
     24a:	85 bb       	out	0x15, r24	; 21
     24c:	08 95       	ret
			case 3: CLR_BIT(PORTD,PinId); break;
     24e:	22 b3       	in	r18, 0x12	; 18
     250:	81 e0       	ldi	r24, 0x01	; 1
     252:	90 e0       	ldi	r25, 0x00	; 0
     254:	02 c0       	rjmp	.+4      	; 0x25a <DIO_voidSetPinValue+0xd6>
     256:	88 0f       	add	r24, r24
     258:	99 1f       	adc	r25, r25
     25a:	6a 95       	dec	r22
     25c:	e2 f7       	brpl	.-8      	; 0x256 <DIO_voidSetPinValue+0xd2>
     25e:	80 95       	com	r24
     260:	82 23       	and	r24, r18
     262:	82 bb       	out	0x12, r24	; 18
     264:	08 95       	ret

00000266 <DIO_voidInitialization>:
//	DIO_voidSetPinDirection(PortD,Pin5,Output);
//
//	DIO_voidSetPinDirection(PortB,Pin3,Output);
//	DIO_voidSetPinDirection(PortD,Pin6,Input);

	DIO_voidSetPinDirection(PortA,Pin0,Input);
     266:	80 e0       	ldi	r24, 0x00	; 0
     268:	60 e0       	ldi	r22, 0x00	; 0
     26a:	40 e0       	ldi	r20, 0x00	; 0
     26c:	0e 94 51 00 	call	0xa2	; 0xa2 <DIO_voidSetPinDirection>
	DIO_voidSetPinDirection(PortA,Pin1,Input);
     270:	80 e0       	ldi	r24, 0x00	; 0
     272:	61 e0       	ldi	r22, 0x01	; 1
     274:	40 e0       	ldi	r20, 0x00	; 0
     276:	0e 94 51 00 	call	0xa2	; 0xa2 <DIO_voidSetPinDirection>

	DIO_voidSetPinValue(PortA,Pin0,High);
     27a:	80 e0       	ldi	r24, 0x00	; 0
     27c:	60 e0       	ldi	r22, 0x00	; 0
     27e:	41 e0       	ldi	r20, 0x01	; 1
     280:	0e 94 c2 00 	call	0x184	; 0x184 <DIO_voidSetPinValue>
	DIO_voidSetPinValue(PortA,Pin1,High);
     284:	80 e0       	ldi	r24, 0x00	; 0
     286:	61 e0       	ldi	r22, 0x01	; 1
     288:	41 e0       	ldi	r20, 0x01	; 1
     28a:	0e 94 c2 00 	call	0x184	; 0x184 <DIO_voidSetPinValue>
}
     28e:	08 95       	ret

00000290 <DIO_voidTogglePin>:
	}
}

void DIO_voidTogglePin (u8 PortId,u8 PinId)
{
	switch(PortId)
     290:	81 30       	cpi	r24, 0x01	; 1
     292:	91 f0       	breq	.+36     	; 0x2b8 <DIO_voidTogglePin+0x28>
     294:	81 30       	cpi	r24, 0x01	; 1
     296:	28 f0       	brcs	.+10     	; 0x2a2 <DIO_voidTogglePin+0x12>
     298:	82 30       	cpi	r24, 0x02	; 2
     29a:	c9 f0       	breq	.+50     	; 0x2ce <DIO_voidTogglePin+0x3e>
     29c:	83 30       	cpi	r24, 0x03	; 3
     29e:	61 f5       	brne	.+88     	; 0x2f8 <DIO_voidTogglePin+0x68>
     2a0:	21 c0       	rjmp	.+66     	; 0x2e4 <DIO_voidTogglePin+0x54>
	{
		case 0: TOG_BIT(PORTA,PinId); break;
     2a2:	2b b3       	in	r18, 0x1b	; 27
     2a4:	81 e0       	ldi	r24, 0x01	; 1
     2a6:	90 e0       	ldi	r25, 0x00	; 0
     2a8:	02 c0       	rjmp	.+4      	; 0x2ae <DIO_voidTogglePin+0x1e>
     2aa:	88 0f       	add	r24, r24
     2ac:	99 1f       	adc	r25, r25
     2ae:	6a 95       	dec	r22
     2b0:	e2 f7       	brpl	.-8      	; 0x2aa <DIO_voidTogglePin+0x1a>
     2b2:	28 27       	eor	r18, r24
     2b4:	2b bb       	out	0x1b, r18	; 27
     2b6:	08 95       	ret
		case 1: TOG_BIT(PORTB,PinId); break;
     2b8:	28 b3       	in	r18, 0x18	; 24
     2ba:	81 e0       	ldi	r24, 0x01	; 1
     2bc:	90 e0       	ldi	r25, 0x00	; 0
     2be:	02 c0       	rjmp	.+4      	; 0x2c4 <DIO_voidTogglePin+0x34>
     2c0:	88 0f       	add	r24, r24
     2c2:	99 1f       	adc	r25, r25
     2c4:	6a 95       	dec	r22
     2c6:	e2 f7       	brpl	.-8      	; 0x2c0 <DIO_voidTogglePin+0x30>
     2c8:	28 27       	eor	r18, r24
     2ca:	28 bb       	out	0x18, r18	; 24
     2cc:	08 95       	ret
		case 2: TOG_BIT(PORTC,PinId); break;
     2ce:	25 b3       	in	r18, 0x15	; 21
     2d0:	81 e0       	ldi	r24, 0x01	; 1
     2d2:	90 e0       	ldi	r25, 0x00	; 0
     2d4:	02 c0       	rjmp	.+4      	; 0x2da <DIO_voidTogglePin+0x4a>
     2d6:	88 0f       	add	r24, r24
     2d8:	99 1f       	adc	r25, r25
     2da:	6a 95       	dec	r22
     2dc:	e2 f7       	brpl	.-8      	; 0x2d6 <DIO_voidTogglePin+0x46>
     2de:	28 27       	eor	r18, r24
     2e0:	25 bb       	out	0x15, r18	; 21
     2e2:	08 95       	ret
		case 3: TOG_BIT(PORTD,PinId); break;
     2e4:	22 b3       	in	r18, 0x12	; 18
     2e6:	81 e0       	ldi	r24, 0x01	; 1
     2e8:	90 e0       	ldi	r25, 0x00	; 0
     2ea:	02 c0       	rjmp	.+4      	; 0x2f0 <DIO_voidTogglePin+0x60>
     2ec:	88 0f       	add	r24, r24
     2ee:	99 1f       	adc	r25, r25
     2f0:	6a 95       	dec	r22
     2f2:	e2 f7       	brpl	.-8      	; 0x2ec <DIO_voidTogglePin+0x5c>
     2f4:	28 27       	eor	r18, r24
     2f6:	22 bb       	out	0x12, r18	; 18
     2f8:	08 95       	ret

000002fa <DIO_voidSetPortDirection>:
	}
}

void DIO_voidSetPortDirection (u8 PortId,u8 Direction)
{
	if(Direction==Output)
     2fa:	61 30       	cpi	r22, 0x01	; 1
     2fc:	a9 f4       	brne	.+42     	; 0x328 <DIO_voidSetPortDirection+0x2e>
	{
		switch(PortId)
     2fe:	81 30       	cpi	r24, 0x01	; 1
     300:	51 f0       	breq	.+20     	; 0x316 <DIO_voidSetPortDirection+0x1c>
     302:	81 30       	cpi	r24, 0x01	; 1
     304:	28 f0       	brcs	.+10     	; 0x310 <DIO_voidSetPortDirection+0x16>
     306:	82 30       	cpi	r24, 0x02	; 2
     308:	49 f0       	breq	.+18     	; 0x31c <DIO_voidSetPortDirection+0x22>
     30a:	83 30       	cpi	r24, 0x03	; 3
     30c:	e9 f4       	brne	.+58     	; 0x348 <DIO_voidSetPortDirection+0x4e>
     30e:	09 c0       	rjmp	.+18     	; 0x322 <DIO_voidSetPortDirection+0x28>
		{
			case 0: SET_BYTE(DDRA,0xFF); break;
     310:	8f ef       	ldi	r24, 0xFF	; 255
     312:	8a bb       	out	0x1a, r24	; 26
     314:	08 95       	ret
			case 1: SET_BYTE(DDRB,0xFF); break;
     316:	8f ef       	ldi	r24, 0xFF	; 255
     318:	87 bb       	out	0x17, r24	; 23
     31a:	08 95       	ret
			case 2: SET_BYTE(DDRC,0xFF); break;
     31c:	8f ef       	ldi	r24, 0xFF	; 255
     31e:	84 bb       	out	0x14, r24	; 20
     320:	08 95       	ret
			case 3: SET_BYTE(DDRD,0xFF); break;
     322:	8f ef       	ldi	r24, 0xFF	; 255
     324:	81 bb       	out	0x11, r24	; 17
     326:	08 95       	ret
		}
	}
	else
	{
		switch(PortId)
     328:	81 30       	cpi	r24, 0x01	; 1
     32a:	49 f0       	breq	.+18     	; 0x33e <DIO_voidSetPortDirection+0x44>
     32c:	81 30       	cpi	r24, 0x01	; 1
     32e:	28 f0       	brcs	.+10     	; 0x33a <DIO_voidSetPortDirection+0x40>
     330:	82 30       	cpi	r24, 0x02	; 2
     332:	39 f0       	breq	.+14     	; 0x342 <DIO_voidSetPortDirection+0x48>
     334:	83 30       	cpi	r24, 0x03	; 3
     336:	41 f4       	brne	.+16     	; 0x348 <DIO_voidSetPortDirection+0x4e>
     338:	06 c0       	rjmp	.+12     	; 0x346 <DIO_voidSetPortDirection+0x4c>
		{
			case 0: SET_BYTE(DDRA,0x00); break;
     33a:	1a ba       	out	0x1a, r1	; 26
     33c:	08 95       	ret
			case 1: SET_BYTE(DDRB,0x00); break;
     33e:	17 ba       	out	0x17, r1	; 23
     340:	08 95       	ret
			case 2: SET_BYTE(DDRC,0x00); break;
     342:	14 ba       	out	0x14, r1	; 20
     344:	08 95       	ret
			case 3: SET_BYTE(DDRD,0x00); break;
     346:	11 ba       	out	0x11, r1	; 17
     348:	08 95       	ret

0000034a <DIO_voidSetPortValue>:
	}
}

void DIO_voidSetPortValue (u8 PortId,u8 Value)
{
	switch(PortId)
     34a:	81 30       	cpi	r24, 0x01	; 1
     34c:	49 f0       	breq	.+18     	; 0x360 <DIO_voidSetPortValue+0x16>
     34e:	81 30       	cpi	r24, 0x01	; 1
     350:	28 f0       	brcs	.+10     	; 0x35c <DIO_voidSetPortValue+0x12>
     352:	82 30       	cpi	r24, 0x02	; 2
     354:	39 f0       	breq	.+14     	; 0x364 <DIO_voidSetPortValue+0x1a>
     356:	83 30       	cpi	r24, 0x03	; 3
     358:	41 f4       	brne	.+16     	; 0x36a <DIO_voidSetPortValue+0x20>
     35a:	06 c0       	rjmp	.+12     	; 0x368 <DIO_voidSetPortValue+0x1e>
	{
		case 0: SET_BYTE(PORTA,Value); break;
     35c:	6b bb       	out	0x1b, r22	; 27
     35e:	08 95       	ret
		case 1: SET_BYTE(PORTB,Value); break;
     360:	68 bb       	out	0x18, r22	; 24
     362:	08 95       	ret
		case 2: SET_BYTE(PORTC,Value); break;
     364:	65 bb       	out	0x15, r22	; 21
     366:	08 95       	ret
		case 3: SET_BYTE(PORTD,Value); break;
     368:	62 bb       	out	0x12, r22	; 18
     36a:	08 95       	ret

0000036c <DIO_voidSetPortValueMask>:
	}
}

void	DIO_voidSetPortValueMask		(u8 PortId,u8 Value,u8 Mask)
{
	switch(PortId)
     36c:	81 30       	cpi	r24, 0x01	; 1
     36e:	61 f0       	breq	.+24     	; 0x388 <DIO_voidSetPortValueMask+0x1c>
     370:	81 30       	cpi	r24, 0x01	; 1
     372:	28 f0       	brcs	.+10     	; 0x37e <DIO_voidSetPortValueMask+0x12>
     374:	82 30       	cpi	r24, 0x02	; 2
     376:	69 f0       	breq	.+26     	; 0x392 <DIO_voidSetPortValueMask+0x26>
     378:	83 30       	cpi	r24, 0x03	; 3
     37a:	a1 f4       	brne	.+40     	; 0x3a4 <DIO_voidSetPortValueMask+0x38>
     37c:	0f c0       	rjmp	.+30     	; 0x39c <DIO_voidSetPortValueMask+0x30>
	{
		case 0: PORTA=((Value)|(PORTA & Mask)); break;
     37e:	8b b3       	in	r24, 0x1b	; 27
     380:	48 23       	and	r20, r24
     382:	46 2b       	or	r20, r22
     384:	4b bb       	out	0x1b, r20	; 27
     386:	08 95       	ret
		case 1: PORTB=((Value)|(PORTB & Mask)); break;
     388:	88 b3       	in	r24, 0x18	; 24
     38a:	48 23       	and	r20, r24
     38c:	46 2b       	or	r20, r22
     38e:	48 bb       	out	0x18, r20	; 24
     390:	08 95       	ret
		case 2: PORTC=((Value)|(PORTC & Mask)); break;
     392:	85 b3       	in	r24, 0x15	; 21
     394:	48 23       	and	r20, r24
     396:	46 2b       	or	r20, r22
     398:	45 bb       	out	0x15, r20	; 21
     39a:	08 95       	ret
		case 3: PORTD=((Value)|(PORTD & Mask)); break;
     39c:	82 b3       	in	r24, 0x12	; 18
     39e:	48 23       	and	r20, r24
     3a0:	46 2b       	or	r20, r22
     3a2:	42 bb       	out	0x12, r20	; 18
     3a4:	08 95       	ret

000003a6 <DIO_voidSetPortDirectionMask>:
	}
}

void	DIO_voidSetPortDirectionMask	(u8 PortId,u8 Direction,u8 Mask)
{
	switch(PortId)
     3a6:	81 30       	cpi	r24, 0x01	; 1
     3a8:	61 f0       	breq	.+24     	; 0x3c2 <DIO_voidSetPortDirectionMask+0x1c>
     3aa:	81 30       	cpi	r24, 0x01	; 1
     3ac:	28 f0       	brcs	.+10     	; 0x3b8 <DIO_voidSetPortDirectionMask+0x12>
     3ae:	82 30       	cpi	r24, 0x02	; 2
     3b0:	69 f0       	breq	.+26     	; 0x3cc <DIO_voidSetPortDirectionMask+0x26>
     3b2:	83 30       	cpi	r24, 0x03	; 3
     3b4:	a1 f4       	brne	.+40     	; 0x3de <DIO_voidSetPortDirectionMask+0x38>
     3b6:	0f c0       	rjmp	.+30     	; 0x3d6 <DIO_voidSetPortDirectionMask+0x30>
	{
		case 0: PORTA=((Direction)|(DDRA & Mask)); break;
     3b8:	8a b3       	in	r24, 0x1a	; 26
     3ba:	48 23       	and	r20, r24
     3bc:	46 2b       	or	r20, r22
     3be:	4b bb       	out	0x1b, r20	; 27
     3c0:	08 95       	ret
		case 1: PORTB=((Direction)|(DDRB & Mask)); break;
     3c2:	87 b3       	in	r24, 0x17	; 23
     3c4:	48 23       	and	r20, r24
     3c6:	46 2b       	or	r20, r22
     3c8:	48 bb       	out	0x18, r20	; 24
     3ca:	08 95       	ret
		case 2: PORTC=((Direction)|(DDRC & Mask)); break;
     3cc:	84 b3       	in	r24, 0x14	; 20
     3ce:	48 23       	and	r20, r24
     3d0:	46 2b       	or	r20, r22
     3d2:	45 bb       	out	0x15, r20	; 21
     3d4:	08 95       	ret
		case 3: PORTD=((Direction)|(DDRD & Mask)); break;
     3d6:	81 b3       	in	r24, 0x11	; 17
     3d8:	48 23       	and	r20, r24
     3da:	46 2b       	or	r20, r22
     3dc:	42 bb       	out	0x12, r20	; 18
     3de:	08 95       	ret

000003e0 <DIO_u8GetPinValue>:
	}
}

u8 DIO_u8GetPinValue (u8 PortId,u8 PinId)
{
     3e0:	28 2f       	mov	r18, r24
	u8 DIO_u8ReturnPinValue;
	switch(PortId)
     3e2:	81 30       	cpi	r24, 0x01	; 1
     3e4:	49 f0       	breq	.+18     	; 0x3f8 <DIO_u8GetPinValue+0x18>
     3e6:	81 30       	cpi	r24, 0x01	; 1
     3e8:	28 f0       	brcs	.+10     	; 0x3f4 <DIO_u8GetPinValue+0x14>
     3ea:	82 30       	cpi	r24, 0x02	; 2
     3ec:	39 f0       	breq	.+14     	; 0x3fc <DIO_u8GetPinValue+0x1c>
     3ee:	83 30       	cpi	r24, 0x03	; 3
     3f0:	c9 f4       	brne	.+50     	; 0x424 <DIO_u8GetPinValue+0x44>
     3f2:	06 c0       	rjmp	.+12     	; 0x400 <DIO_u8GetPinValue+0x20>
	{
	case 0: DIO_u8ReturnPinValue = GET_BIT(PINA,PinId); break;
     3f4:	29 b3       	in	r18, 0x19	; 25
     3f6:	05 c0       	rjmp	.+10     	; 0x402 <DIO_u8GetPinValue+0x22>
	case 1: DIO_u8ReturnPinValue = GET_BIT(PINB,PinId); break;
     3f8:	26 b3       	in	r18, 0x16	; 22
     3fa:	03 c0       	rjmp	.+6      	; 0x402 <DIO_u8GetPinValue+0x22>
	case 2: DIO_u8ReturnPinValue = GET_BIT(PINC,PinId); break;
     3fc:	23 b3       	in	r18, 0x13	; 19
     3fe:	01 c0       	rjmp	.+2      	; 0x402 <DIO_u8GetPinValue+0x22>
	case 3: DIO_u8ReturnPinValue = GET_BIT(PIND,PinId); break;
     400:	20 b3       	in	r18, 0x10	; 16
     402:	81 e0       	ldi	r24, 0x01	; 1
     404:	90 e0       	ldi	r25, 0x00	; 0
     406:	06 2e       	mov	r0, r22
     408:	02 c0       	rjmp	.+4      	; 0x40e <DIO_u8GetPinValue+0x2e>
     40a:	88 0f       	add	r24, r24
     40c:	99 1f       	adc	r25, r25
     40e:	0a 94       	dec	r0
     410:	e2 f7       	brpl	.-8      	; 0x40a <DIO_u8GetPinValue+0x2a>
     412:	30 e0       	ldi	r19, 0x00	; 0
     414:	82 23       	and	r24, r18
     416:	93 23       	and	r25, r19
     418:	02 c0       	rjmp	.+4      	; 0x41e <DIO_u8GetPinValue+0x3e>
     41a:	95 95       	asr	r25
     41c:	87 95       	ror	r24
     41e:	6a 95       	dec	r22
     420:	e2 f7       	brpl	.-8      	; 0x41a <DIO_u8GetPinValue+0x3a>
     422:	08 95       	ret
	default : DIO_u8ReturnPinValue = GET_BIT(PortId,PinId); break;
     424:	81 e0       	ldi	r24, 0x01	; 1
     426:	90 e0       	ldi	r25, 0x00	; 0
     428:	06 2e       	mov	r0, r22
     42a:	02 c0       	rjmp	.+4      	; 0x430 <DIO_u8GetPinValue+0x50>
     42c:	88 0f       	add	r24, r24
     42e:	99 1f       	adc	r25, r25
     430:	0a 94       	dec	r0
     432:	e2 f7       	brpl	.-8      	; 0x42c <DIO_u8GetPinValue+0x4c>
     434:	30 e0       	ldi	r19, 0x00	; 0
     436:	82 23       	and	r24, r18
     438:	93 23       	and	r25, r19
     43a:	02 c0       	rjmp	.+4      	; 0x440 <DIO_u8GetPinValue+0x60>
     43c:	95 95       	asr	r25
     43e:	87 95       	ror	r24
     440:	6a 95       	dec	r22
     442:	e2 f7       	brpl	.-8      	; 0x43c <DIO_u8GetPinValue+0x5c>
	}
	return DIO_u8ReturnPinValue;
}
     444:	08 95       	ret

00000446 <DIO_voidGetPinValue>:

void DIO_voidGetPinValue (u8 PortId,u8 PinId, u8 * ptr)
{
     446:	fa 01       	movw	r30, r20
	switch(PortId)
     448:	81 30       	cpi	r24, 0x01	; 1
     44a:	49 f0       	breq	.+18     	; 0x45e <DIO_voidGetPinValue+0x18>
     44c:	81 30       	cpi	r24, 0x01	; 1
     44e:	28 f0       	brcs	.+10     	; 0x45a <DIO_voidGetPinValue+0x14>
     450:	82 30       	cpi	r24, 0x02	; 2
     452:	39 f0       	breq	.+14     	; 0x462 <DIO_voidGetPinValue+0x1c>
     454:	83 30       	cpi	r24, 0x03	; 3
     456:	51 f5       	brne	.+84     	; 0x4ac <DIO_voidGetPinValue+0x66>
     458:	17 c0       	rjmp	.+46     	; 0x488 <DIO_voidGetPinValue+0x42>
	{
	case 0: *ptr = GET_BIT(DDRA,PinId); break;
     45a:	2a b3       	in	r18, 0x1a	; 26
     45c:	03 c0       	rjmp	.+6      	; 0x464 <DIO_voidGetPinValue+0x1e>
	case 1: *ptr = GET_BIT(DDRB,PinId); break;
     45e:	27 b3       	in	r18, 0x17	; 23
     460:	01 c0       	rjmp	.+2      	; 0x464 <DIO_voidGetPinValue+0x1e>
	case 2: *ptr = GET_BIT(DDRC,PinId); break;
     462:	24 b3       	in	r18, 0x14	; 20
     464:	81 e0       	ldi	r24, 0x01	; 1
     466:	90 e0       	ldi	r25, 0x00	; 0
     468:	06 2e       	mov	r0, r22
     46a:	02 c0       	rjmp	.+4      	; 0x470 <DIO_voidGetPinValue+0x2a>
     46c:	88 0f       	add	r24, r24
     46e:	99 1f       	adc	r25, r25
     470:	0a 94       	dec	r0
     472:	e2 f7       	brpl	.-8      	; 0x46c <DIO_voidGetPinValue+0x26>
     474:	30 e0       	ldi	r19, 0x00	; 0
     476:	82 23       	and	r24, r18
     478:	93 23       	and	r25, r19
     47a:	02 c0       	rjmp	.+4      	; 0x480 <DIO_voidGetPinValue+0x3a>
     47c:	95 95       	asr	r25
     47e:	87 95       	ror	r24
     480:	6a 95       	dec	r22
     482:	e2 f7       	brpl	.-8      	; 0x47c <DIO_voidGetPinValue+0x36>
     484:	80 83       	st	Z, r24
     486:	08 95       	ret
	case 3: *ptr = GET_BIT(DDRD,PinId); break;
     488:	21 b3       	in	r18, 0x11	; 17
     48a:	81 e0       	ldi	r24, 0x01	; 1
     48c:	90 e0       	ldi	r25, 0x00	; 0
     48e:	06 2e       	mov	r0, r22
     490:	02 c0       	rjmp	.+4      	; 0x496 <DIO_voidGetPinValue+0x50>
     492:	88 0f       	add	r24, r24
     494:	99 1f       	adc	r25, r25
     496:	0a 94       	dec	r0
     498:	e2 f7       	brpl	.-8      	; 0x492 <DIO_voidGetPinValue+0x4c>
     49a:	30 e0       	ldi	r19, 0x00	; 0
     49c:	82 23       	and	r24, r18
     49e:	93 23       	and	r25, r19
     4a0:	02 c0       	rjmp	.+4      	; 0x4a6 <DIO_voidGetPinValue+0x60>
     4a2:	95 95       	asr	r25
     4a4:	87 95       	ror	r24
     4a6:	6a 95       	dec	r22
     4a8:	e2 f7       	brpl	.-8      	; 0x4a2 <DIO_voidGetPinValue+0x5c>
     4aa:	80 83       	st	Z, r24
     4ac:	08 95       	ret

000004ae <ADC_voidInterruptEnable>:
	SET_BIT(ADCSRA,ADIF);
}

void ADC_voidInterruptEnable(void)
{
	SET_BIT(ADCSRA,ADIE);
     4ae:	33 9a       	sbi	0x06, 3	; 6
}
     4b0:	08 95       	ret

000004b2 <ADC_voidInterruptDisable>:

void ADC_voidInterruptDisable(void)
{
	CLR_BIT(ADCSRA,ADIE);
     4b2:	33 98       	cbi	0x06, 3	; 6
}
     4b4:	08 95       	ret

000004b6 <ADC_voidStartConversion>:

void ADC_voidStartConversion(u8 Channel)
{
	CLR_BIT(ADMUX,MUX4);
     4b6:	3c 98       	cbi	0x07, 4	; 7
	CLR_BIT(ADMUX,MUX3);
     4b8:	3b 98       	cbi	0x07, 3	; 7

	switch(Channel)
     4ba:	83 30       	cpi	r24, 0x03	; 3
     4bc:	c1 f0       	breq	.+48     	; 0x4ee <ADC_voidStartConversion+0x38>
     4be:	84 30       	cpi	r24, 0x04	; 4
     4c0:	28 f4       	brcc	.+10     	; 0x4cc <ADC_voidStartConversion+0x16>
     4c2:	81 30       	cpi	r24, 0x01	; 1
     4c4:	71 f0       	breq	.+28     	; 0x4e2 <ADC_voidStartConversion+0x2c>
     4c6:	82 30       	cpi	r24, 0x02	; 2
     4c8:	70 f4       	brcc	.+28     	; 0x4e6 <ADC_voidStartConversion+0x30>
     4ca:	09 c0       	rjmp	.+18     	; 0x4de <ADC_voidStartConversion+0x28>
     4cc:	85 30       	cpi	r24, 0x05	; 5
     4ce:	a1 f0       	breq	.+40     	; 0x4f8 <ADC_voidStartConversion+0x42>
     4d0:	85 30       	cpi	r24, 0x05	; 5
     4d2:	78 f0       	brcs	.+30     	; 0x4f2 <ADC_voidStartConversion+0x3c>
     4d4:	86 30       	cpi	r24, 0x06	; 6
     4d6:	99 f0       	breq	.+38     	; 0x4fe <ADC_voidStartConversion+0x48>
     4d8:	87 30       	cpi	r24, 0x07	; 7
     4da:	b1 f4       	brne	.+44     	; 0x508 <ADC_voidStartConversion+0x52>
     4dc:	12 c0       	rjmp	.+36     	; 0x502 <ADC_voidStartConversion+0x4c>
	{
		case 0 : CLR_BIT(ADMUX,MUX2);CLR_BIT(ADMUX,MUX1);CLR_BIT(ADMUX,MUX0);break;
     4de:	3a 98       	cbi	0x07, 2	; 7
     4e0:	09 c0       	rjmp	.+18     	; 0x4f4 <ADC_voidStartConversion+0x3e>
		case 1 : CLR_BIT(ADMUX,MUX2);CLR_BIT(ADMUX,MUX1);SET_BIT(ADMUX,MUX0);break;
     4e2:	3a 98       	cbi	0x07, 2	; 7
     4e4:	0a c0       	rjmp	.+20     	; 0x4fa <ADC_voidStartConversion+0x44>
		case 2 : CLR_BIT(ADMUX,MUX2);SET_BIT(ADMUX,MUX1);CLR_BIT(ADMUX,MUX0);break;
     4e6:	3a 98       	cbi	0x07, 2	; 7
     4e8:	39 9a       	sbi	0x07, 1	; 7
     4ea:	38 98       	cbi	0x07, 0	; 7
     4ec:	0d c0       	rjmp	.+26     	; 0x508 <ADC_voidStartConversion+0x52>
		case 3 : CLR_BIT(ADMUX,MUX2);SET_BIT(ADMUX,MUX1);SET_BIT(ADMUX,MUX0);break;
     4ee:	3a 98       	cbi	0x07, 2	; 7
     4f0:	09 c0       	rjmp	.+18     	; 0x504 <ADC_voidStartConversion+0x4e>
		case 4 : SET_BIT(ADMUX,MUX2);CLR_BIT(ADMUX,MUX1);CLR_BIT(ADMUX,MUX0);break;
     4f2:	3a 9a       	sbi	0x07, 2	; 7
     4f4:	39 98       	cbi	0x07, 1	; 7
     4f6:	f9 cf       	rjmp	.-14     	; 0x4ea <ADC_voidStartConversion+0x34>
		case 5 : SET_BIT(ADMUX,MUX2);CLR_BIT(ADMUX,MUX1);SET_BIT(ADMUX,MUX0);break;
     4f8:	3a 9a       	sbi	0x07, 2	; 7
     4fa:	39 98       	cbi	0x07, 1	; 7
     4fc:	04 c0       	rjmp	.+8      	; 0x506 <ADC_voidStartConversion+0x50>
		case 6 : SET_BIT(ADMUX,MUX2);SET_BIT(ADMUX,MUX1);CLR_BIT(ADMUX,MUX0);break;
     4fe:	3a 9a       	sbi	0x07, 2	; 7
     500:	f3 cf       	rjmp	.-26     	; 0x4e8 <ADC_voidStartConversion+0x32>
		case 7 : SET_BIT(ADMUX,MUX2);SET_BIT(ADMUX,MUX1);SET_BIT(ADMUX,MUX0);break;
     502:	3a 9a       	sbi	0x07, 2	; 7
     504:	39 9a       	sbi	0x07, 1	; 7
     506:	38 9a       	sbi	0x07, 0	; 7
	}

	SET_BIT(ADCSRA,ADSC);
     508:	36 9a       	sbi	0x06, 6	; 6
}
     50a:	08 95       	ret

0000050c <ADC_u16ReadConversionValue_Polling>:
	LCD_KIT_voidDisplayBigNumber((u16)(ADCL|(ADCH<<8)));
}

u16 ADC_u16ReadConversionValue_Polling(void)
{
	while(!GET_BIT(ADCSRA,ADIF));
     50c:	34 9b       	sbis	0x06, 4	; 6
     50e:	fe cf       	rjmp	.-4      	; 0x50c <ADC_u16ReadConversionValue_Polling>

	//LCD_KIT_voidDisplayCharacter('j');
	//LCD_KIT_voidDisplayBigNumber(8);

	return ADCDATA;
     510:	24 b1       	in	r18, 0x04	; 4
     512:	35 b1       	in	r19, 0x05	; 5
}
     514:	c9 01       	movw	r24, r18
     516:	08 95       	ret

00000518 <__vector_16>:

void (*ADC_ISR)(void)=NULL;
void __vector_16(void)
{
     518:	1f 92       	push	r1
     51a:	0f 92       	push	r0
     51c:	0f b6       	in	r0, 0x3f	; 63
     51e:	0f 92       	push	r0
     520:	11 24       	eor	r1, r1
     522:	2f 93       	push	r18
     524:	3f 93       	push	r19
     526:	4f 93       	push	r20
     528:	5f 93       	push	r21
     52a:	6f 93       	push	r22
     52c:	7f 93       	push	r23
     52e:	8f 93       	push	r24
     530:	9f 93       	push	r25
     532:	af 93       	push	r26
     534:	bf 93       	push	r27
     536:	ef 93       	push	r30
     538:	ff 93       	push	r31
	ADC_ISR();
     53a:	e0 91 14 01 	lds	r30, 0x0114
     53e:	f0 91 15 01 	lds	r31, 0x0115
     542:	09 95       	icall
}
     544:	ff 91       	pop	r31
     546:	ef 91       	pop	r30
     548:	bf 91       	pop	r27
     54a:	af 91       	pop	r26
     54c:	9f 91       	pop	r25
     54e:	8f 91       	pop	r24
     550:	7f 91       	pop	r23
     552:	6f 91       	pop	r22
     554:	5f 91       	pop	r21
     556:	4f 91       	pop	r20
     558:	3f 91       	pop	r19
     55a:	2f 91       	pop	r18
     55c:	0f 90       	pop	r0
     55e:	0f be       	out	0x3f, r0	; 63
     560:	0f 90       	pop	r0
     562:	1f 90       	pop	r1
     564:	18 95       	reti

00000566 <ADC_CallBack>:
void ADC_CallBack(void (*PF_ADC)(void))
{
	ADC_ISR=PF_ADC;
     566:	90 93 15 01 	sts	0x0115, r25
     56a:	80 93 14 01 	sts	0x0114, r24
}
     56e:	08 95       	ret

00000570 <ADC_voidReadConversionValue_Polling>:
	SET_BIT(ADCSRA,ADSC);
}

void ADC_voidReadConversionValue_Polling(void)
{
	while(!GET_BIT(ADCSRA,ADIF));
     570:	34 9b       	sbis	0x06, 4	; 6
     572:	fe cf       	rjmp	.-4      	; 0x570 <ADC_voidReadConversionValue_Polling>
	LCD_KIT_voidRunCommand(0x01);
     574:	81 e0       	ldi	r24, 0x01	; 1
     576:	90 e0       	ldi	r25, 0x00	; 0
     578:	0e 94 d7 02 	call	0x5ae	; 0x5ae <LCD_KIT_voidRunCommand>
	LCD_KIT_voidDisplayBigNumber((u16)(ADCL|(ADCH<<8)));
     57c:	24 b1       	in	r18, 0x04	; 4
     57e:	45 b1       	in	r20, 0x05	; 5
     580:	94 2f       	mov	r25, r20
     582:	80 e0       	ldi	r24, 0x00	; 0
     584:	30 e0       	ldi	r19, 0x00	; 0
     586:	82 2b       	or	r24, r18
     588:	93 2b       	or	r25, r19
     58a:	0e 94 06 04 	call	0x80c	; 0x80c <LCD_KIT_voidDisplayBigNumber>
}
     58e:	08 95       	ret

00000590 <ADC_voidInitialization>:
#include "ADC_priv.h"

void ADC_voidInitialization(void)
{
	// AVCC as a REF
	CLR_BIT(ADMUX,REFS1);
     590:	3f 98       	cbi	0x07, 7	; 7
	SET_BIT(ADMUX,REFS0);
     592:	3e 9a       	sbi	0x07, 6	; 7

	// Right Adjusting
	DIO_voidSetPinValue(ADMUX,ADLAR,Low);
     594:	87 b1       	in	r24, 0x07	; 7
     596:	65 e0       	ldi	r22, 0x05	; 5
     598:	40 e0       	ldi	r20, 0x00	; 0
     59a:	0e 94 c2 00 	call	0x184	; 0x184 <DIO_voidSetPinValue>
//	CLR_BIT(ADMUX,MUX2);
//	CLR_BIT(ADMUX,MUX1);
//	CLR_BIT(ADMUX,MUX0);

	// Enabling ADC
	SET_BIT(ADCSRA,ADEN);
     59e:	37 9a       	sbi	0x06, 7	; 6

	// Auto Trigger Disable
	SET_BIT(ADCSRA,ADATE);
     5a0:	35 9a       	sbi	0x06, 5	; 6

	// ADC Prescaler is 64
	SET_BIT(ADCSRA,ADPS2);
     5a2:	32 9a       	sbi	0x06, 2	; 6
	SET_BIT(ADCSRA,ADPS1);
     5a4:	31 9a       	sbi	0x06, 1	; 6
	CLR_BIT(ADCSRA,ADPS0);
     5a6:	30 98       	cbi	0x06, 0	; 6

	CLR_BIT(ADCSRA,ADIE);
     5a8:	33 98       	cbi	0x06, 3	; 6
	SET_BIT(ADCSRA,ADIF);
     5aa:	34 9a       	sbi	0x06, 4	; 6
}
     5ac:	08 95       	ret

000005ae <LCD_KIT_voidRunCommand>:

	return;
}

void LCD_KIT_voidRunCommand(u8 command)
{
     5ae:	df 92       	push	r13
     5b0:	ef 92       	push	r14
     5b2:	ff 92       	push	r15
     5b4:	0f 93       	push	r16
     5b6:	1f 93       	push	r17
     5b8:	d8 2e       	mov	r13, r24
	DIO_voidSetPinValue(LCD_ADDRESS_PORT,LCD_ADDRESS_RS,Low);
     5ba:	80 e0       	ldi	r24, 0x00	; 0
     5bc:	63 e0       	ldi	r22, 0x03	; 3
     5be:	40 e0       	ldi	r20, 0x00	; 0
     5c0:	0e 94 c2 00 	call	0x184	; 0x184 <DIO_voidSetPinValue>

	DIO_voidSetPinValue(LCD_DATA_PORT,LCD_DATA_PinD7,GET_BIT(command,Pin7));
     5c4:	4d 2d       	mov	r20, r13
     5c6:	44 1f       	adc	r20, r20
     5c8:	44 27       	eor	r20, r20
     5ca:	44 1f       	adc	r20, r20
     5cc:	81 e0       	ldi	r24, 0x01	; 1
     5ce:	64 e0       	ldi	r22, 0x04	; 4
     5d0:	0e 94 c2 00 	call	0x184	; 0x184 <DIO_voidSetPinValue>
	DIO_voidSetPinValue(LCD_DATA_PORT,LCD_DATA_PinD6,GET_BIT(command,Pin6));
     5d4:	0d 2d       	mov	r16, r13
     5d6:	10 e0       	ldi	r17, 0x00	; 0
     5d8:	a8 01       	movw	r20, r16
     5da:	40 74       	andi	r20, 0x40	; 64
     5dc:	50 70       	andi	r21, 0x00	; 0
     5de:	e6 e0       	ldi	r30, 0x06	; 6
     5e0:	55 95       	asr	r21
     5e2:	47 95       	ror	r20
     5e4:	ea 95       	dec	r30
     5e6:	e1 f7       	brne	.-8      	; 0x5e0 <LCD_KIT_voidRunCommand+0x32>
     5e8:	81 e0       	ldi	r24, 0x01	; 1
     5ea:	62 e0       	ldi	r22, 0x02	; 2
     5ec:	0e 94 c2 00 	call	0x184	; 0x184 <DIO_voidSetPinValue>
	DIO_voidSetPinValue(LCD_DATA_PORT,LCD_DATA_PinD5,GET_BIT(command,Pin5));
     5f0:	a8 01       	movw	r20, r16
     5f2:	40 72       	andi	r20, 0x20	; 32
     5f4:	50 70       	andi	r21, 0x00	; 0
     5f6:	75 e0       	ldi	r23, 0x05	; 5
     5f8:	55 95       	asr	r21
     5fa:	47 95       	ror	r20
     5fc:	7a 95       	dec	r23
     5fe:	e1 f7       	brne	.-8      	; 0x5f8 <LCD_KIT_voidRunCommand+0x4a>
     600:	81 e0       	ldi	r24, 0x01	; 1
     602:	61 e0       	ldi	r22, 0x01	; 1
     604:	0e 94 c2 00 	call	0x184	; 0x184 <DIO_voidSetPinValue>
	DIO_voidSetPinValue(LCD_DATA_PORT,LCD_DATA_PinD4,GET_BIT(command,Pin4));
     608:	a8 01       	movw	r20, r16
     60a:	40 71       	andi	r20, 0x10	; 16
     60c:	50 70       	andi	r21, 0x00	; 0
     60e:	64 e0       	ldi	r22, 0x04	; 4
     610:	55 95       	asr	r21
     612:	47 95       	ror	r20
     614:	6a 95       	dec	r22
     616:	e1 f7       	brne	.-8      	; 0x610 <LCD_KIT_voidRunCommand+0x62>
     618:	81 e0       	ldi	r24, 0x01	; 1
     61a:	60 e0       	ldi	r22, 0x00	; 0
     61c:	0e 94 c2 00 	call	0x184	; 0x184 <DIO_voidSetPinValue>

	DIO_voidSetPinValue(LCD_ADDRESS_PORT,LCD_ADDRESS_E,High);
     620:	80 e0       	ldi	r24, 0x00	; 0
     622:	62 e0       	ldi	r22, 0x02	; 2
     624:	41 e0       	ldi	r20, 0x01	; 1
     626:	0e 94 c2 00 	call	0x184	; 0x184 <DIO_voidSetPinValue>
    milliseconds can be achieved.
 */
void
_delay_loop_2(uint16_t __count)
{
	__asm__ volatile (
     62a:	30 e4       	ldi	r19, 0x40	; 64
     62c:	e3 2e       	mov	r14, r19
     62e:	3f e1       	ldi	r19, 0x1F	; 31
     630:	f3 2e       	mov	r15, r19
     632:	c7 01       	movw	r24, r14
     634:	01 97       	sbiw	r24, 0x01	; 1
     636:	f1 f7       	brne	.-4      	; 0x634 <LCD_KIT_voidRunCommand+0x86>
	_delay_ms(2);
	DIO_voidSetPinValue(LCD_ADDRESS_PORT,LCD_ADDRESS_E,Low);
     638:	80 e0       	ldi	r24, 0x00	; 0
     63a:	62 e0       	ldi	r22, 0x02	; 2
     63c:	40 e0       	ldi	r20, 0x00	; 0
     63e:	0e 94 c2 00 	call	0x184	; 0x184 <DIO_voidSetPinValue>
     642:	c7 01       	movw	r24, r14
     644:	01 97       	sbiw	r24, 0x01	; 1
     646:	f1 f7       	brne	.-4      	; 0x644 <LCD_KIT_voidRunCommand+0x96>
	_delay_ms(2);

	DIO_voidSetPinValue(LCD_DATA_PORT,LCD_DATA_PinD7,GET_BIT(command,Pin3));
     648:	a8 01       	movw	r20, r16
     64a:	48 70       	andi	r20, 0x08	; 8
     64c:	50 70       	andi	r21, 0x00	; 0
     64e:	23 e0       	ldi	r18, 0x03	; 3
     650:	55 95       	asr	r21
     652:	47 95       	ror	r20
     654:	2a 95       	dec	r18
     656:	e1 f7       	brne	.-8      	; 0x650 <LCD_KIT_voidRunCommand+0xa2>
     658:	81 e0       	ldi	r24, 0x01	; 1
     65a:	64 e0       	ldi	r22, 0x04	; 4
     65c:	0e 94 c2 00 	call	0x184	; 0x184 <DIO_voidSetPinValue>
	DIO_voidSetPinValue(LCD_DATA_PORT,LCD_DATA_PinD6,GET_BIT(command,Pin2));
     660:	a8 01       	movw	r20, r16
     662:	44 70       	andi	r20, 0x04	; 4
     664:	50 70       	andi	r21, 0x00	; 0
     666:	55 95       	asr	r21
     668:	47 95       	ror	r20
     66a:	55 95       	asr	r21
     66c:	47 95       	ror	r20
     66e:	81 e0       	ldi	r24, 0x01	; 1
     670:	62 e0       	ldi	r22, 0x02	; 2
     672:	0e 94 c2 00 	call	0x184	; 0x184 <DIO_voidSetPinValue>
	DIO_voidSetPinValue(LCD_DATA_PORT,LCD_DATA_PinD5,GET_BIT(command,Pin1));
     676:	02 70       	andi	r16, 0x02	; 2
     678:	10 70       	andi	r17, 0x00	; 0
     67a:	15 95       	asr	r17
     67c:	07 95       	ror	r16
     67e:	81 e0       	ldi	r24, 0x01	; 1
     680:	61 e0       	ldi	r22, 0x01	; 1
     682:	40 2f       	mov	r20, r16
     684:	0e 94 c2 00 	call	0x184	; 0x184 <DIO_voidSetPinValue>
	DIO_voidSetPinValue(LCD_DATA_PORT,LCD_DATA_PinD4,GET_BIT(command,Pin0));
     688:	81 e0       	ldi	r24, 0x01	; 1
     68a:	d8 22       	and	r13, r24
     68c:	60 e0       	ldi	r22, 0x00	; 0
     68e:	4d 2d       	mov	r20, r13
     690:	0e 94 c2 00 	call	0x184	; 0x184 <DIO_voidSetPinValue>
	//DIO_voidSetPinValue(PortB,Pin7,GET_BIT(command,Pin0));

	DIO_voidSetPinValue(LCD_ADDRESS_PORT,LCD_ADDRESS_E,High);
     694:	80 e0       	ldi	r24, 0x00	; 0
     696:	62 e0       	ldi	r22, 0x02	; 2
     698:	41 e0       	ldi	r20, 0x01	; 1
     69a:	0e 94 c2 00 	call	0x184	; 0x184 <DIO_voidSetPinValue>
     69e:	c7 01       	movw	r24, r14
     6a0:	01 97       	sbiw	r24, 0x01	; 1
     6a2:	f1 f7       	brne	.-4      	; 0x6a0 <LCD_KIT_voidRunCommand+0xf2>
	_delay_ms(2);
	DIO_voidSetPinValue(LCD_ADDRESS_PORT,LCD_ADDRESS_E,Low);
     6a4:	80 e0       	ldi	r24, 0x00	; 0
     6a6:	62 e0       	ldi	r22, 0x02	; 2
     6a8:	40 e0       	ldi	r20, 0x00	; 0
     6aa:	0e 94 c2 00 	call	0x184	; 0x184 <DIO_voidSetPinValue>
     6ae:	c7 01       	movw	r24, r14
     6b0:	01 97       	sbiw	r24, 0x01	; 1
     6b2:	f1 f7       	brne	.-4      	; 0x6b0 <LCD_KIT_voidRunCommand+0x102>
	_delay_ms(2);

	return;
}
     6b4:	1f 91       	pop	r17
     6b6:	0f 91       	pop	r16
     6b8:	ff 90       	pop	r15
     6ba:	ef 90       	pop	r14
     6bc:	df 90       	pop	r13
     6be:	08 95       	ret

000006c0 <LCD_KIT_voidSetCurser>:

void LCD_KIT_voidSetCurser(u8 Line , u8 Col)
{
	LCD_KIT_voidRunCommand(Line+Col);
     6c0:	86 0f       	add	r24, r22
     6c2:	0e 94 d7 02 	call	0x5ae	; 0x5ae <LCD_KIT_voidRunCommand>

	return;
}
     6c6:	08 95       	ret

000006c8 <LCD_KIT_voidDisplayCharacter>:

	return;
}

void LCD_KIT_voidDisplayCharacter(u8 character)
{
     6c8:	df 92       	push	r13
     6ca:	ef 92       	push	r14
     6cc:	ff 92       	push	r15
     6ce:	0f 93       	push	r16
     6d0:	1f 93       	push	r17
     6d2:	d8 2e       	mov	r13, r24
	DIO_voidSetPinValue(LCD_ADDRESS_PORT,LCD_ADDRESS_RS,High);
     6d4:	80 e0       	ldi	r24, 0x00	; 0
     6d6:	63 e0       	ldi	r22, 0x03	; 3
     6d8:	41 e0       	ldi	r20, 0x01	; 1
     6da:	0e 94 c2 00 	call	0x184	; 0x184 <DIO_voidSetPinValue>

	DIO_voidSetPinValue(LCD_DATA_PORT,LCD_DATA_PinD7,GET_BIT(character,Pin7));
     6de:	4d 2d       	mov	r20, r13
     6e0:	44 1f       	adc	r20, r20
     6e2:	44 27       	eor	r20, r20
     6e4:	44 1f       	adc	r20, r20
     6e6:	81 e0       	ldi	r24, 0x01	; 1
     6e8:	64 e0       	ldi	r22, 0x04	; 4
     6ea:	0e 94 c2 00 	call	0x184	; 0x184 <DIO_voidSetPinValue>
	DIO_voidSetPinValue(LCD_DATA_PORT,LCD_DATA_PinD6,GET_BIT(character,Pin6));
     6ee:	0d 2d       	mov	r16, r13
     6f0:	10 e0       	ldi	r17, 0x00	; 0
     6f2:	a8 01       	movw	r20, r16
     6f4:	40 74       	andi	r20, 0x40	; 64
     6f6:	50 70       	andi	r21, 0x00	; 0
     6f8:	36 e0       	ldi	r19, 0x06	; 6
     6fa:	55 95       	asr	r21
     6fc:	47 95       	ror	r20
     6fe:	3a 95       	dec	r19
     700:	e1 f7       	brne	.-8      	; 0x6fa <LCD_KIT_voidDisplayCharacter+0x32>
     702:	81 e0       	ldi	r24, 0x01	; 1
     704:	62 e0       	ldi	r22, 0x02	; 2
     706:	0e 94 c2 00 	call	0x184	; 0x184 <DIO_voidSetPinValue>
	DIO_voidSetPinValue(LCD_DATA_PORT,LCD_DATA_PinD5,GET_BIT(character,Pin5));
     70a:	a8 01       	movw	r20, r16
     70c:	40 72       	andi	r20, 0x20	; 32
     70e:	50 70       	andi	r21, 0x00	; 0
     710:	25 e0       	ldi	r18, 0x05	; 5
     712:	55 95       	asr	r21
     714:	47 95       	ror	r20
     716:	2a 95       	dec	r18
     718:	e1 f7       	brne	.-8      	; 0x712 <LCD_KIT_voidDisplayCharacter+0x4a>
     71a:	81 e0       	ldi	r24, 0x01	; 1
     71c:	61 e0       	ldi	r22, 0x01	; 1
     71e:	0e 94 c2 00 	call	0x184	; 0x184 <DIO_voidSetPinValue>
	DIO_voidSetPinValue(LCD_DATA_PORT,LCD_DATA_PinD4,GET_BIT(character,Pin4));
     722:	a8 01       	movw	r20, r16
     724:	40 71       	andi	r20, 0x10	; 16
     726:	50 70       	andi	r21, 0x00	; 0
     728:	94 e0       	ldi	r25, 0x04	; 4
     72a:	55 95       	asr	r21
     72c:	47 95       	ror	r20
     72e:	9a 95       	dec	r25
     730:	e1 f7       	brne	.-8      	; 0x72a <LCD_KIT_voidDisplayCharacter+0x62>
     732:	81 e0       	ldi	r24, 0x01	; 1
     734:	60 e0       	ldi	r22, 0x00	; 0
     736:	0e 94 c2 00 	call	0x184	; 0x184 <DIO_voidSetPinValue>

	DIO_voidSetPinValue(LCD_ADDRESS_PORT,LCD_ADDRESS_E,High);
     73a:	80 e0       	ldi	r24, 0x00	; 0
     73c:	62 e0       	ldi	r22, 0x02	; 2
     73e:	41 e0       	ldi	r20, 0x01	; 1
     740:	0e 94 c2 00 	call	0x184	; 0x184 <DIO_voidSetPinValue>
     744:	80 e4       	ldi	r24, 0x40	; 64
     746:	e8 2e       	mov	r14, r24
     748:	8f e1       	ldi	r24, 0x1F	; 31
     74a:	f8 2e       	mov	r15, r24
     74c:	c7 01       	movw	r24, r14
     74e:	01 97       	sbiw	r24, 0x01	; 1
     750:	f1 f7       	brne	.-4      	; 0x74e <LCD_KIT_voidDisplayCharacter+0x86>
	_delay_ms(2);
	DIO_voidSetPinValue(LCD_ADDRESS_PORT,LCD_ADDRESS_E,Low);
     752:	80 e0       	ldi	r24, 0x00	; 0
     754:	62 e0       	ldi	r22, 0x02	; 2
     756:	40 e0       	ldi	r20, 0x00	; 0
     758:	0e 94 c2 00 	call	0x184	; 0x184 <DIO_voidSetPinValue>
     75c:	c7 01       	movw	r24, r14
     75e:	01 97       	sbiw	r24, 0x01	; 1
     760:	f1 f7       	brne	.-4      	; 0x75e <LCD_KIT_voidDisplayCharacter+0x96>
	_delay_ms(2);

	DIO_voidSetPinValue(LCD_DATA_PORT,LCD_DATA_PinD7,GET_BIT(character,Pin3));
     762:	a8 01       	movw	r20, r16
     764:	48 70       	andi	r20, 0x08	; 8
     766:	50 70       	andi	r21, 0x00	; 0
     768:	b3 e0       	ldi	r27, 0x03	; 3
     76a:	55 95       	asr	r21
     76c:	47 95       	ror	r20
     76e:	ba 95       	dec	r27
     770:	e1 f7       	brne	.-8      	; 0x76a <LCD_KIT_voidDisplayCharacter+0xa2>
     772:	81 e0       	ldi	r24, 0x01	; 1
     774:	64 e0       	ldi	r22, 0x04	; 4
     776:	0e 94 c2 00 	call	0x184	; 0x184 <DIO_voidSetPinValue>
	DIO_voidSetPinValue(LCD_DATA_PORT,LCD_DATA_PinD6,GET_BIT(character,Pin2));
     77a:	a8 01       	movw	r20, r16
     77c:	44 70       	andi	r20, 0x04	; 4
     77e:	50 70       	andi	r21, 0x00	; 0
     780:	55 95       	asr	r21
     782:	47 95       	ror	r20
     784:	55 95       	asr	r21
     786:	47 95       	ror	r20
     788:	81 e0       	ldi	r24, 0x01	; 1
     78a:	62 e0       	ldi	r22, 0x02	; 2
     78c:	0e 94 c2 00 	call	0x184	; 0x184 <DIO_voidSetPinValue>
	DIO_voidSetPinValue(LCD_DATA_PORT,LCD_DATA_PinD5,GET_BIT(character,Pin1));
     790:	02 70       	andi	r16, 0x02	; 2
     792:	10 70       	andi	r17, 0x00	; 0
     794:	15 95       	asr	r17
     796:	07 95       	ror	r16
     798:	81 e0       	ldi	r24, 0x01	; 1
     79a:	61 e0       	ldi	r22, 0x01	; 1
     79c:	40 2f       	mov	r20, r16
     79e:	0e 94 c2 00 	call	0x184	; 0x184 <DIO_voidSetPinValue>
	DIO_voidSetPinValue(LCD_DATA_PORT,LCD_DATA_PinD4,GET_BIT(character,Pin0));
     7a2:	81 e0       	ldi	r24, 0x01	; 1
     7a4:	d8 22       	and	r13, r24
     7a6:	60 e0       	ldi	r22, 0x00	; 0
     7a8:	4d 2d       	mov	r20, r13
     7aa:	0e 94 c2 00 	call	0x184	; 0x184 <DIO_voidSetPinValue>

	DIO_voidSetPinValue(LCD_ADDRESS_PORT,LCD_ADDRESS_E,High);
     7ae:	80 e0       	ldi	r24, 0x00	; 0
     7b0:	62 e0       	ldi	r22, 0x02	; 2
     7b2:	41 e0       	ldi	r20, 0x01	; 1
     7b4:	0e 94 c2 00 	call	0x184	; 0x184 <DIO_voidSetPinValue>
     7b8:	c7 01       	movw	r24, r14
     7ba:	01 97       	sbiw	r24, 0x01	; 1
     7bc:	f1 f7       	brne	.-4      	; 0x7ba <LCD_KIT_voidDisplayCharacter+0xf2>
	_delay_ms(2);
	DIO_voidSetPinValue(LCD_ADDRESS_PORT,LCD_ADDRESS_E,Low);
     7be:	80 e0       	ldi	r24, 0x00	; 0
     7c0:	62 e0       	ldi	r22, 0x02	; 2
     7c2:	40 e0       	ldi	r20, 0x00	; 0
     7c4:	0e 94 c2 00 	call	0x184	; 0x184 <DIO_voidSetPinValue>
     7c8:	c7 01       	movw	r24, r14
     7ca:	01 97       	sbiw	r24, 0x01	; 1
     7cc:	f1 f7       	brne	.-4      	; 0x7ca <LCD_KIT_voidDisplayCharacter+0x102>
	_delay_ms(2);

	return;
}
     7ce:	1f 91       	pop	r17
     7d0:	0f 91       	pop	r16
     7d2:	ff 90       	pop	r15
     7d4:	ef 90       	pop	r14
     7d6:	df 90       	pop	r13
     7d8:	08 95       	ret

000007da <LCD_KIT_voidStoreCustomCharacter>:

	return;
}

void LCD_KIT_voidStoreCustomCharacter(u8 *Character, u8 Address)
{
     7da:	0f 93       	push	r16
     7dc:	1f 93       	push	r17
     7de:	cf 93       	push	r28
     7e0:	df 93       	push	r29
     7e2:	8c 01       	movw	r16, r24
     7e4:	86 2f       	mov	r24, r22
	LCD_KIT_voidRunCommand(Address);
     7e6:	0e 94 d7 02 	call	0x5ae	; 0x5ae <LCD_KIT_voidRunCommand>
     7ea:	c0 e0       	ldi	r28, 0x00	; 0
     7ec:	d0 e0       	ldi	r29, 0x00	; 0

	for(u8 j=0;j<8;j++)
	{
		LCD_KIT_voidDisplayCharacter(Character[j]);
     7ee:	f8 01       	movw	r30, r16
     7f0:	ec 0f       	add	r30, r28
     7f2:	fd 1f       	adc	r31, r29
     7f4:	80 81       	ld	r24, Z
     7f6:	0e 94 64 03 	call	0x6c8	; 0x6c8 <LCD_KIT_voidDisplayCharacter>
     7fa:	21 96       	adiw	r28, 0x01	; 1

void LCD_KIT_voidStoreCustomCharacter(u8 *Character, u8 Address)
{
	LCD_KIT_voidRunCommand(Address);

	for(u8 j=0;j<8;j++)
     7fc:	c8 30       	cpi	r28, 0x08	; 8
     7fe:	d1 05       	cpc	r29, r1
     800:	b1 f7       	brne	.-20     	; 0x7ee <LCD_KIT_voidStoreCustomCharacter+0x14>
	{
		LCD_KIT_voidDisplayCharacter(Character[j]);
	}

	return;
}
     802:	df 91       	pop	r29
     804:	cf 91       	pop	r28
     806:	1f 91       	pop	r17
     808:	0f 91       	pop	r16
     80a:	08 95       	ret

0000080c <LCD_KIT_voidDisplayBigNumber>:
	}
}
*/

void LCD_KIT_voidDisplayBigNumber(u32 Number)
{
     80c:	ef 92       	push	r14
     80e:	ff 92       	push	r15
     810:	0f 93       	push	r16
     812:	1f 93       	push	r17
     814:	7b 01       	movw	r14, r22
     816:	8c 01       	movw	r16, r24
	if(Number<=9)
     818:	8a e0       	ldi	r24, 0x0A	; 10
     81a:	e8 16       	cp	r14, r24
     81c:	f1 04       	cpc	r15, r1
     81e:	01 05       	cpc	r16, r1
     820:	11 05       	cpc	r17, r1
     822:	10 f4       	brcc	.+4      	; 0x828 <LCD_KIT_voidDisplayBigNumber+0x1c>
	{
		LCD_KIT_voidDisplayCharacter(Number+48);
     824:	8e 2d       	mov	r24, r14
     826:	df c0       	rjmp	.+446    	; 0x9e6 <__stack+0x187>
	}
	else if(Number<=99)
     828:	84 e6       	ldi	r24, 0x64	; 100
     82a:	e8 16       	cp	r14, r24
     82c:	f1 04       	cpc	r15, r1
     82e:	01 05       	cpc	r16, r1
     830:	11 05       	cpc	r17, r1
     832:	50 f4       	brcc	.+20     	; 0x848 <LCD_KIT_voidDisplayBigNumber+0x3c>
	{
		LCD_KIT_voidDisplayCharacter(Number/10+48);
     834:	c8 01       	movw	r24, r16
     836:	b7 01       	movw	r22, r14
     838:	2a e0       	ldi	r18, 0x0A	; 10
     83a:	30 e0       	ldi	r19, 0x00	; 0
     83c:	40 e0       	ldi	r20, 0x00	; 0
     83e:	50 e0       	ldi	r21, 0x00	; 0
     840:	0e 94 33 26 	call	0x4c66	; 0x4c66 <__udivmodsi4>
     844:	82 2f       	mov	r24, r18
     846:	c3 c0       	rjmp	.+390    	; 0x9ce <__stack+0x16f>
		LCD_KIT_voidDisplayCharacter(Number%10+48);
	}
	else if(Number<=999)
     848:	88 ee       	ldi	r24, 0xE8	; 232
     84a:	e8 16       	cp	r14, r24
     84c:	83 e0       	ldi	r24, 0x03	; 3
     84e:	f8 06       	cpc	r15, r24
     850:	80 e0       	ldi	r24, 0x00	; 0
     852:	08 07       	cpc	r16, r24
     854:	80 e0       	ldi	r24, 0x00	; 0
     856:	18 07       	cpc	r17, r24
     858:	50 f4       	brcc	.+20     	; 0x86e <__stack+0xf>
	{
		LCD_KIT_voidDisplayCharacter(Number/100+48);
     85a:	c8 01       	movw	r24, r16
     85c:	b7 01       	movw	r22, r14
     85e:	24 e6       	ldi	r18, 0x64	; 100
     860:	30 e0       	ldi	r19, 0x00	; 0
     862:	40 e0       	ldi	r20, 0x00	; 0
     864:	50 e0       	ldi	r21, 0x00	; 0
     866:	0e 94 33 26 	call	0x4c66	; 0x4c66 <__udivmodsi4>
     86a:	82 2f       	mov	r24, r18
     86c:	9c c0       	rjmp	.+312    	; 0x9a6 <__stack+0x147>
		LCD_KIT_voidDisplayCharacter((Number/10)%10+48);
		LCD_KIT_voidDisplayCharacter(Number%10+48);
	}
	else if(Number<=9999)
     86e:	80 e1       	ldi	r24, 0x10	; 16
     870:	e8 16       	cp	r14, r24
     872:	87 e2       	ldi	r24, 0x27	; 39
     874:	f8 06       	cpc	r15, r24
     876:	80 e0       	ldi	r24, 0x00	; 0
     878:	08 07       	cpc	r16, r24
     87a:	80 e0       	ldi	r24, 0x00	; 0
     87c:	18 07       	cpc	r17, r24
     87e:	50 f4       	brcc	.+20     	; 0x894 <__stack+0x35>
	{
		LCD_KIT_voidDisplayCharacter(Number/1000+48);
     880:	c8 01       	movw	r24, r16
     882:	b7 01       	movw	r22, r14
     884:	28 ee       	ldi	r18, 0xE8	; 232
     886:	33 e0       	ldi	r19, 0x03	; 3
     888:	40 e0       	ldi	r20, 0x00	; 0
     88a:	50 e0       	ldi	r21, 0x00	; 0
     88c:	0e 94 33 26 	call	0x4c66	; 0x4c66 <__udivmodsi4>
     890:	82 2f       	mov	r24, r18
     892:	75 c0       	rjmp	.+234    	; 0x97e <__stack+0x11f>
		LCD_KIT_voidDisplayCharacter((Number/100)%10+48);
		LCD_KIT_voidDisplayCharacter((Number/10)%10+48);
		LCD_KIT_voidDisplayCharacter(Number%10+48);
	}
	else if(Number<=99999)
     894:	80 ea       	ldi	r24, 0xA0	; 160
     896:	e8 16       	cp	r14, r24
     898:	86 e8       	ldi	r24, 0x86	; 134
     89a:	f8 06       	cpc	r15, r24
     89c:	81 e0       	ldi	r24, 0x01	; 1
     89e:	08 07       	cpc	r16, r24
     8a0:	80 e0       	ldi	r24, 0x00	; 0
     8a2:	18 07       	cpc	r17, r24
     8a4:	50 f4       	brcc	.+20     	; 0x8ba <__stack+0x5b>
	{
		LCD_KIT_voidDisplayCharacter(Number/10000+48);
     8a6:	c8 01       	movw	r24, r16
     8a8:	b7 01       	movw	r22, r14
     8aa:	20 e1       	ldi	r18, 0x10	; 16
     8ac:	37 e2       	ldi	r19, 0x27	; 39
     8ae:	40 e0       	ldi	r20, 0x00	; 0
     8b0:	50 e0       	ldi	r21, 0x00	; 0
     8b2:	0e 94 33 26 	call	0x4c66	; 0x4c66 <__udivmodsi4>
     8b6:	82 2f       	mov	r24, r18
     8b8:	4e c0       	rjmp	.+156    	; 0x956 <__stack+0xf7>
		LCD_KIT_voidDisplayCharacter((Number/1000)%10+48);
		LCD_KIT_voidDisplayCharacter((Number/100)%10+48);
		LCD_KIT_voidDisplayCharacter((Number/10)%10+48);
		LCD_KIT_voidDisplayCharacter(Number%10+48);
	}
	else if(Number<=999999)
     8ba:	80 e4       	ldi	r24, 0x40	; 64
     8bc:	e8 16       	cp	r14, r24
     8be:	82 e4       	ldi	r24, 0x42	; 66
     8c0:	f8 06       	cpc	r15, r24
     8c2:	8f e0       	ldi	r24, 0x0F	; 15
     8c4:	08 07       	cpc	r16, r24
     8c6:	80 e0       	ldi	r24, 0x00	; 0
     8c8:	18 07       	cpc	r17, r24
     8ca:	50 f4       	brcc	.+20     	; 0x8e0 <__stack+0x81>
		{
			LCD_KIT_voidDisplayCharacter(Number/100000+48);
     8cc:	c8 01       	movw	r24, r16
     8ce:	b7 01       	movw	r22, r14
     8d0:	20 ea       	ldi	r18, 0xA0	; 160
     8d2:	36 e8       	ldi	r19, 0x86	; 134
     8d4:	41 e0       	ldi	r20, 0x01	; 1
     8d6:	50 e0       	ldi	r21, 0x00	; 0
     8d8:	0e 94 33 26 	call	0x4c66	; 0x4c66 <__udivmodsi4>
     8dc:	82 2f       	mov	r24, r18
     8de:	27 c0       	rjmp	.+78     	; 0x92e <__stack+0xcf>
			LCD_KIT_voidDisplayCharacter((Number/1000)%10+48);
			LCD_KIT_voidDisplayCharacter((Number/100)%10+48);
			LCD_KIT_voidDisplayCharacter((Number/10)%10+48);
			LCD_KIT_voidDisplayCharacter(Number%10+48);
		}
	else if(Number<=9999999)
     8e0:	80 e8       	ldi	r24, 0x80	; 128
     8e2:	e8 16       	cp	r14, r24
     8e4:	86 e9       	ldi	r24, 0x96	; 150
     8e6:	f8 06       	cpc	r15, r24
     8e8:	88 e9       	ldi	r24, 0x98	; 152
     8ea:	08 07       	cpc	r16, r24
     8ec:	80 e0       	ldi	r24, 0x00	; 0
     8ee:	18 07       	cpc	r17, r24
     8f0:	08 f0       	brcs	.+2      	; 0x8f4 <__stack+0x95>
     8f2:	7c c0       	rjmp	.+248    	; 0x9ec <__stack+0x18d>
			{
				LCD_KIT_voidDisplayCharacter(Number/1000000+48);
     8f4:	c8 01       	movw	r24, r16
     8f6:	b7 01       	movw	r22, r14
     8f8:	20 e4       	ldi	r18, 0x40	; 64
     8fa:	32 e4       	ldi	r19, 0x42	; 66
     8fc:	4f e0       	ldi	r20, 0x0F	; 15
     8fe:	50 e0       	ldi	r21, 0x00	; 0
     900:	0e 94 33 26 	call	0x4c66	; 0x4c66 <__udivmodsi4>
     904:	82 2f       	mov	r24, r18
     906:	80 5d       	subi	r24, 0xD0	; 208
     908:	0e 94 64 03 	call	0x6c8	; 0x6c8 <LCD_KIT_voidDisplayCharacter>
				LCD_KIT_voidDisplayCharacter((Number/100000)%10+48);
     90c:	c8 01       	movw	r24, r16
     90e:	b7 01       	movw	r22, r14
     910:	20 ea       	ldi	r18, 0xA0	; 160
     912:	36 e8       	ldi	r19, 0x86	; 134
     914:	41 e0       	ldi	r20, 0x01	; 1
     916:	50 e0       	ldi	r21, 0x00	; 0
     918:	0e 94 33 26 	call	0x4c66	; 0x4c66 <__udivmodsi4>
     91c:	ca 01       	movw	r24, r20
     91e:	b9 01       	movw	r22, r18
     920:	2a e0       	ldi	r18, 0x0A	; 10
     922:	30 e0       	ldi	r19, 0x00	; 0
     924:	40 e0       	ldi	r20, 0x00	; 0
     926:	50 e0       	ldi	r21, 0x00	; 0
     928:	0e 94 33 26 	call	0x4c66	; 0x4c66 <__udivmodsi4>
     92c:	86 2f       	mov	r24, r22
     92e:	80 5d       	subi	r24, 0xD0	; 208
     930:	0e 94 64 03 	call	0x6c8	; 0x6c8 <LCD_KIT_voidDisplayCharacter>
				LCD_KIT_voidDisplayCharacter((Number/10000)%10+48);
     934:	c8 01       	movw	r24, r16
     936:	b7 01       	movw	r22, r14
     938:	20 e1       	ldi	r18, 0x10	; 16
     93a:	37 e2       	ldi	r19, 0x27	; 39
     93c:	40 e0       	ldi	r20, 0x00	; 0
     93e:	50 e0       	ldi	r21, 0x00	; 0
     940:	0e 94 33 26 	call	0x4c66	; 0x4c66 <__udivmodsi4>
     944:	ca 01       	movw	r24, r20
     946:	b9 01       	movw	r22, r18
     948:	2a e0       	ldi	r18, 0x0A	; 10
     94a:	30 e0       	ldi	r19, 0x00	; 0
     94c:	40 e0       	ldi	r20, 0x00	; 0
     94e:	50 e0       	ldi	r21, 0x00	; 0
     950:	0e 94 33 26 	call	0x4c66	; 0x4c66 <__udivmodsi4>
     954:	86 2f       	mov	r24, r22
     956:	80 5d       	subi	r24, 0xD0	; 208
     958:	0e 94 64 03 	call	0x6c8	; 0x6c8 <LCD_KIT_voidDisplayCharacter>
				LCD_KIT_voidDisplayCharacter((Number/1000)%10+48);
     95c:	c8 01       	movw	r24, r16
     95e:	b7 01       	movw	r22, r14
     960:	28 ee       	ldi	r18, 0xE8	; 232
     962:	33 e0       	ldi	r19, 0x03	; 3
     964:	40 e0       	ldi	r20, 0x00	; 0
     966:	50 e0       	ldi	r21, 0x00	; 0
     968:	0e 94 33 26 	call	0x4c66	; 0x4c66 <__udivmodsi4>
     96c:	ca 01       	movw	r24, r20
     96e:	b9 01       	movw	r22, r18
     970:	2a e0       	ldi	r18, 0x0A	; 10
     972:	30 e0       	ldi	r19, 0x00	; 0
     974:	40 e0       	ldi	r20, 0x00	; 0
     976:	50 e0       	ldi	r21, 0x00	; 0
     978:	0e 94 33 26 	call	0x4c66	; 0x4c66 <__udivmodsi4>
     97c:	86 2f       	mov	r24, r22
     97e:	80 5d       	subi	r24, 0xD0	; 208
     980:	0e 94 64 03 	call	0x6c8	; 0x6c8 <LCD_KIT_voidDisplayCharacter>
				LCD_KIT_voidDisplayCharacter((Number/100)%10+48);
     984:	c8 01       	movw	r24, r16
     986:	b7 01       	movw	r22, r14
     988:	24 e6       	ldi	r18, 0x64	; 100
     98a:	30 e0       	ldi	r19, 0x00	; 0
     98c:	40 e0       	ldi	r20, 0x00	; 0
     98e:	50 e0       	ldi	r21, 0x00	; 0
     990:	0e 94 33 26 	call	0x4c66	; 0x4c66 <__udivmodsi4>
     994:	ca 01       	movw	r24, r20
     996:	b9 01       	movw	r22, r18
     998:	2a e0       	ldi	r18, 0x0A	; 10
     99a:	30 e0       	ldi	r19, 0x00	; 0
     99c:	40 e0       	ldi	r20, 0x00	; 0
     99e:	50 e0       	ldi	r21, 0x00	; 0
     9a0:	0e 94 33 26 	call	0x4c66	; 0x4c66 <__udivmodsi4>
     9a4:	86 2f       	mov	r24, r22
     9a6:	80 5d       	subi	r24, 0xD0	; 208
     9a8:	0e 94 64 03 	call	0x6c8	; 0x6c8 <LCD_KIT_voidDisplayCharacter>
				LCD_KIT_voidDisplayCharacter((Number/10)%10+48);
     9ac:	c8 01       	movw	r24, r16
     9ae:	b7 01       	movw	r22, r14
     9b0:	2a e0       	ldi	r18, 0x0A	; 10
     9b2:	30 e0       	ldi	r19, 0x00	; 0
     9b4:	40 e0       	ldi	r20, 0x00	; 0
     9b6:	50 e0       	ldi	r21, 0x00	; 0
     9b8:	0e 94 33 26 	call	0x4c66	; 0x4c66 <__udivmodsi4>
     9bc:	ca 01       	movw	r24, r20
     9be:	b9 01       	movw	r22, r18
     9c0:	2a e0       	ldi	r18, 0x0A	; 10
     9c2:	30 e0       	ldi	r19, 0x00	; 0
     9c4:	40 e0       	ldi	r20, 0x00	; 0
     9c6:	50 e0       	ldi	r21, 0x00	; 0
     9c8:	0e 94 33 26 	call	0x4c66	; 0x4c66 <__udivmodsi4>
     9cc:	86 2f       	mov	r24, r22
     9ce:	80 5d       	subi	r24, 0xD0	; 208
     9d0:	0e 94 64 03 	call	0x6c8	; 0x6c8 <LCD_KIT_voidDisplayCharacter>
				LCD_KIT_voidDisplayCharacter(Number%10+48);
     9d4:	c8 01       	movw	r24, r16
     9d6:	b7 01       	movw	r22, r14
     9d8:	2a e0       	ldi	r18, 0x0A	; 10
     9da:	30 e0       	ldi	r19, 0x00	; 0
     9dc:	40 e0       	ldi	r20, 0x00	; 0
     9de:	50 e0       	ldi	r21, 0x00	; 0
     9e0:	0e 94 33 26 	call	0x4c66	; 0x4c66 <__udivmodsi4>
     9e4:	86 2f       	mov	r24, r22
     9e6:	80 5d       	subi	r24, 0xD0	; 208
     9e8:	0e 94 64 03 	call	0x6c8	; 0x6c8 <LCD_KIT_voidDisplayCharacter>
			}

	return;
}
     9ec:	1f 91       	pop	r17
     9ee:	0f 91       	pop	r16
     9f0:	ff 90       	pop	r15
     9f2:	ef 90       	pop	r14
     9f4:	08 95       	ret

000009f6 <LCD_KIT_voidDisplayString>:

	return;
}

void LCD_KIT_voidDisplayString(u8 *Str)
{
     9f6:	1f 93       	push	r17
     9f8:	cf 93       	push	r28
     9fa:	df 93       	push	r29
     9fc:	ec 01       	movw	r28, r24
     9fe:	10 e0       	ldi	r17, 0x00	; 0
     a00:	03 c0       	rjmp	.+6      	; 0xa08 <LCD_KIT_voidDisplayString+0x12>
	for(u8 j=0;Str[j]!='\0';j++)
	{
		LCD_KIT_voidDisplayCharacter(Str[j]);
     a02:	0e 94 64 03 	call	0x6c8	; 0x6c8 <LCD_KIT_voidDisplayCharacter>
	return;
}

void LCD_KIT_voidDisplayString(u8 *Str)
{
	for(u8 j=0;Str[j]!='\0';j++)
     a06:	1f 5f       	subi	r17, 0xFF	; 255
     a08:	fe 01       	movw	r30, r28
     a0a:	e1 0f       	add	r30, r17
     a0c:	f1 1d       	adc	r31, r1
     a0e:	80 81       	ld	r24, Z
     a10:	88 23       	and	r24, r24
     a12:	b9 f7       	brne	.-18     	; 0xa02 <LCD_KIT_voidDisplayString+0xc>
	{
		LCD_KIT_voidDisplayCharacter(Str[j]);
	}
}
     a14:	df 91       	pop	r29
     a16:	cf 91       	pop	r28
     a18:	1f 91       	pop	r17
     a1a:	08 95       	ret

00000a1c <LCD_KIT_voidInitialization>:

#include <util/delay.h>


void LCD_KIT_voidInitialization(void)
{
     a1c:	ef 92       	push	r14
     a1e:	ff 92       	push	r15
     a20:	0f 93       	push	r16
     a22:	1f 93       	push	r17
	DIO_voidSetPinDirection(LCD_ADDRESS_PORT,LCD_ADDRESS_E,Output);
     a24:	80 e0       	ldi	r24, 0x00	; 0
     a26:	62 e0       	ldi	r22, 0x02	; 2
     a28:	41 e0       	ldi	r20, 0x01	; 1
     a2a:	0e 94 51 00 	call	0xa2	; 0xa2 <DIO_voidSetPinDirection>
	DIO_voidSetPinDirection(LCD_ADDRESS_PORT,LCD_ADDRESS_RS,Output);
     a2e:	80 e0       	ldi	r24, 0x00	; 0
     a30:	63 e0       	ldi	r22, 0x03	; 3
     a32:	41 e0       	ldi	r20, 0x01	; 1
     a34:	0e 94 51 00 	call	0xa2	; 0xa2 <DIO_voidSetPinDirection>

	DIO_voidSetPinDirection(LCD_DATA_PORT,LCD_DATA_PinD4,Output);
     a38:	81 e0       	ldi	r24, 0x01	; 1
     a3a:	60 e0       	ldi	r22, 0x00	; 0
     a3c:	41 e0       	ldi	r20, 0x01	; 1
     a3e:	0e 94 51 00 	call	0xa2	; 0xa2 <DIO_voidSetPinDirection>
	DIO_voidSetPinDirection(LCD_DATA_PORT,LCD_DATA_PinD5,Output);
     a42:	81 e0       	ldi	r24, 0x01	; 1
     a44:	61 e0       	ldi	r22, 0x01	; 1
     a46:	41 e0       	ldi	r20, 0x01	; 1
     a48:	0e 94 51 00 	call	0xa2	; 0xa2 <DIO_voidSetPinDirection>
	DIO_voidSetPinDirection(LCD_DATA_PORT,LCD_DATA_PinD6,Output);
     a4c:	81 e0       	ldi	r24, 0x01	; 1
     a4e:	62 e0       	ldi	r22, 0x02	; 2
     a50:	41 e0       	ldi	r20, 0x01	; 1
     a52:	0e 94 51 00 	call	0xa2	; 0xa2 <DIO_voidSetPinDirection>
	DIO_voidSetPinDirection(LCD_DATA_PORT,LCD_DATA_PinD7,Output);
     a56:	81 e0       	ldi	r24, 0x01	; 1
     a58:	64 e0       	ldi	r22, 0x04	; 4
     a5a:	41 e0       	ldi	r20, 0x01	; 1
     a5c:	0e 94 51 00 	call	0xa2	; 0xa2 <DIO_voidSetPinDirection>
     a60:	80 e9       	ldi	r24, 0x90	; 144
     a62:	91 e0       	ldi	r25, 0x01	; 1
     a64:	20 e9       	ldi	r18, 0x90	; 144
     a66:	31 e0       	ldi	r19, 0x01	; 1
     a68:	f9 01       	movw	r30, r18
     a6a:	31 97       	sbiw	r30, 0x01	; 1
     a6c:	f1 f7       	brne	.-4      	; 0xa6a <LCD_KIT_voidInitialization+0x4e>
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
     a6e:	01 97       	sbiw	r24, 0x01	; 1
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
     a70:	d9 f7       	brne	.-10     	; 0xa68 <LCD_KIT_voidInitialization+0x4c>

	_delay_ms(40);
	DIO_voidSetPinValue(LCD_DATA_PORT,LCD_DATA_PinD4,Low);
     a72:	81 e0       	ldi	r24, 0x01	; 1
     a74:	60 e0       	ldi	r22, 0x00	; 0
     a76:	40 e0       	ldi	r20, 0x00	; 0
     a78:	0e 94 c2 00 	call	0x184	; 0x184 <DIO_voidSetPinValue>
	DIO_voidSetPinValue(LCD_DATA_PORT,LCD_DATA_PinD5,High);
     a7c:	81 e0       	ldi	r24, 0x01	; 1
     a7e:	61 e0       	ldi	r22, 0x01	; 1
     a80:	41 e0       	ldi	r20, 0x01	; 1
     a82:	0e 94 c2 00 	call	0x184	; 0x184 <DIO_voidSetPinValue>
	DIO_voidSetPinValue(LCD_DATA_PORT,LCD_DATA_PinD6,Low);
     a86:	81 e0       	ldi	r24, 0x01	; 1
     a88:	62 e0       	ldi	r22, 0x02	; 2
     a8a:	40 e0       	ldi	r20, 0x00	; 0
     a8c:	0e 94 c2 00 	call	0x184	; 0x184 <DIO_voidSetPinValue>
	DIO_voidSetPinValue(LCD_DATA_PORT,LCD_DATA_PinD7,Low);
     a90:	81 e0       	ldi	r24, 0x01	; 1
     a92:	64 e0       	ldi	r22, 0x04	; 4
     a94:	40 e0       	ldi	r20, 0x00	; 0
     a96:	0e 94 c2 00 	call	0x184	; 0x184 <DIO_voidSetPinValue>

	DIO_voidSetPinValue(LCD_ADDRESS_PORT,LCD_ADDRESS_E,High);
     a9a:	80 e0       	ldi	r24, 0x00	; 0
     a9c:	62 e0       	ldi	r22, 0x02	; 2
     a9e:	41 e0       	ldi	r20, 0x01	; 1
     aa0:	0e 94 c2 00 	call	0x184	; 0x184 <DIO_voidSetPinValue>
     aa4:	40 e4       	ldi	r20, 0x40	; 64
     aa6:	e4 2e       	mov	r14, r20
     aa8:	4f e1       	ldi	r20, 0x1F	; 31
     aaa:	f4 2e       	mov	r15, r20
     aac:	c7 01       	movw	r24, r14
     aae:	01 97       	sbiw	r24, 0x01	; 1
     ab0:	f1 f7       	brne	.-4      	; 0xaae <LCD_KIT_voidInitialization+0x92>
	_delay_ms(2);
	DIO_voidSetPinValue(LCD_ADDRESS_PORT,LCD_ADDRESS_E,Low);
     ab2:	80 e0       	ldi	r24, 0x00	; 0
     ab4:	62 e0       	ldi	r22, 0x02	; 2
     ab6:	40 e0       	ldi	r20, 0x00	; 0
     ab8:	0e 94 c2 00 	call	0x184	; 0x184 <DIO_voidSetPinValue>
     abc:	c7 01       	movw	r24, r14
     abe:	01 97       	sbiw	r24, 0x01	; 1
     ac0:	f1 f7       	brne	.-4      	; 0xabe <LCD_KIT_voidInitialization+0xa2>
	_delay_ms(2);

	LCD_KIT_voidRunCommand(0x28);
     ac2:	88 e2       	ldi	r24, 0x28	; 40
     ac4:	0e 94 d7 02 	call	0x5ae	; 0x5ae <LCD_KIT_voidRunCommand>
     ac8:	00 ea       	ldi	r16, 0xA0	; 160
     aca:	1f e0       	ldi	r17, 0x0F	; 15
     acc:	c8 01       	movw	r24, r16
     ace:	01 97       	sbiw	r24, 0x01	; 1
     ad0:	f1 f7       	brne	.-4      	; 0xace <LCD_KIT_voidInitialization+0xb2>
	_delay_ms(1);

	LCD_KIT_voidRunCommand(0x0C);
     ad2:	8c e0       	ldi	r24, 0x0C	; 12
     ad4:	0e 94 d7 02 	call	0x5ae	; 0x5ae <LCD_KIT_voidRunCommand>
     ad8:	c8 01       	movw	r24, r16
     ada:	01 97       	sbiw	r24, 0x01	; 1
     adc:	f1 f7       	brne	.-4      	; 0xada <LCD_KIT_voidInitialization+0xbe>
	_delay_ms(1);

	LCD_KIT_voidRunCommand(0x01);
     ade:	81 e0       	ldi	r24, 0x01	; 1
     ae0:	0e 94 d7 02 	call	0x5ae	; 0x5ae <LCD_KIT_voidRunCommand>
     ae4:	c7 01       	movw	r24, r14
     ae6:	01 97       	sbiw	r24, 0x01	; 1
     ae8:	f1 f7       	brne	.-4      	; 0xae6 <LCD_KIT_voidInitialization+0xca>
	_delay_ms(2);

	LCD_KIT_voidRunCommand(0x06);
     aea:	86 e0       	ldi	r24, 0x06	; 6
     aec:	0e 94 d7 02 	call	0x5ae	; 0x5ae <LCD_KIT_voidRunCommand>

	LCD_KIT_voidRunCommand(0x80);
     af0:	80 e8       	ldi	r24, 0x80	; 128
     af2:	0e 94 d7 02 	call	0x5ae	; 0x5ae <LCD_KIT_voidRunCommand>

	return;
}
     af6:	1f 91       	pop	r17
     af8:	0f 91       	pop	r16
     afa:	ff 90       	pop	r15
     afc:	ef 90       	pop	r14
     afe:	08 95       	ret

00000b00 <KEYBAD_voidGetPressedKey>:

	//return;
}

void KEYBAD_voidGetPressedKey(u8 *Row, u8 *Col,u8 *Flag)
{
     b00:	4f 92       	push	r4
     b02:	5f 92       	push	r5
     b04:	6f 92       	push	r6
     b06:	7f 92       	push	r7
     b08:	8f 92       	push	r8
     b0a:	9f 92       	push	r9
     b0c:	af 92       	push	r10
     b0e:	bf 92       	push	r11
     b10:	cf 92       	push	r12
     b12:	df 92       	push	r13
     b14:	ef 92       	push	r14
     b16:	ff 92       	push	r15
     b18:	0f 93       	push	r16
     b1a:	1f 93       	push	r17
     b1c:	cf 93       	push	r28
     b1e:	df 93       	push	r29
     b20:	4c 01       	movw	r8, r24
     b22:	5b 01       	movw	r10, r22
     b24:	6a 01       	movw	r12, r20
     b26:	00 e0       	ldi	r16, 0x00	; 0
     b28:	c3 e0       	ldi	r28, 0x03	; 3
     b2a:	d0 e0       	ldi	r29, 0x00	; 0
	for(u8 i=0;i<5;i++)
	{
		if(i==1)
		{	continue;	}

		DIO_voidSetPortValueMask(PortD,~(1<<(i+3)),0x17);
     b2c:	21 e0       	ldi	r18, 0x01	; 1
     b2e:	62 2e       	mov	r6, r18
     b30:	71 2c       	mov	r7, r1

		for(u8 j=0;j<4;j++)
		{
			if(!DIO_u8GetPinValue(PortC,j+2))
     b32:	95 e0       	ldi	r25, 0x05	; 5
     b34:	49 2e       	mov	r4, r25
			{
				*Row=3-j;
				*Col=4-i;
     b36:	84 e0       	ldi	r24, 0x04	; 4
     b38:	58 2e       	mov	r5, r24

				*Flag=1;
     b3a:	ee 24       	eor	r14, r14
     b3c:	e3 94       	inc	r14

void KEYBAD_voidGetPressedKey(u8 *Row, u8 *Col,u8 *Flag)
{
	for(u8 i=0;i<5;i++)
	{
		if(i==1)
     b3e:	01 30       	cpi	r16, 0x01	; 1
     b40:	f1 f0       	breq	.+60     	; 0xb7e <KEYBAD_voidGetPressedKey+0x7e>
		{	continue;	}

		DIO_voidSetPortValueMask(PortD,~(1<<(i+3)),0x17);
     b42:	b3 01       	movw	r22, r6
     b44:	0c 2e       	mov	r0, r28
     b46:	02 c0       	rjmp	.+4      	; 0xb4c <KEYBAD_voidGetPressedKey+0x4c>
     b48:	66 0f       	add	r22, r22
     b4a:	77 1f       	adc	r23, r23
     b4c:	0a 94       	dec	r0
     b4e:	e2 f7       	brpl	.-8      	; 0xb48 <KEYBAD_voidGetPressedKey+0x48>
     b50:	60 95       	com	r22
     b52:	83 e0       	ldi	r24, 0x03	; 3
     b54:	47 e1       	ldi	r20, 0x17	; 23
     b56:	0e 94 b6 01 	call	0x36c	; 0x36c <DIO_voidSetPortValueMask>
     b5a:	13 e0       	ldi	r17, 0x03	; 3
		for(u8 j=0;j<4;j++)
		{
			if(!DIO_u8GetPinValue(PortC,j+2))
			{
				*Row=3-j;
				*Col=4-i;
     b5c:	f5 2c       	mov	r15, r5
     b5e:	f0 1a       	sub	r15, r16

		DIO_voidSetPortValueMask(PortD,~(1<<(i+3)),0x17);

		for(u8 j=0;j<4;j++)
		{
			if(!DIO_u8GetPinValue(PortC,j+2))
     b60:	64 2d       	mov	r22, r4
     b62:	61 1b       	sub	r22, r17
     b64:	82 e0       	ldi	r24, 0x02	; 2
     b66:	0e 94 f0 01 	call	0x3e0	; 0x3e0 <DIO_u8GetPinValue>
     b6a:	88 23       	and	r24, r24
     b6c:	31 f4       	brne	.+12     	; 0xb7a <KEYBAD_voidGetPressedKey+0x7a>
			{
				*Row=3-j;
     b6e:	f4 01       	movw	r30, r8
     b70:	10 83       	st	Z, r17
				*Col=4-i;
     b72:	f5 01       	movw	r30, r10
     b74:	f0 82       	st	Z, r15

				*Flag=1;
     b76:	f6 01       	movw	r30, r12
     b78:	e0 82       	st	Z, r14
     b7a:	11 50       	subi	r17, 0x01	; 1
     b7c:	88 f7       	brcc	.-30     	; 0xb60 <KEYBAD_voidGetPressedKey+0x60>
	//return;
}

void KEYBAD_voidGetPressedKey(u8 *Row, u8 *Col,u8 *Flag)
{
	for(u8 i=0;i<5;i++)
     b7e:	0f 5f       	subi	r16, 0xFF	; 255
     b80:	21 96       	adiw	r28, 0x01	; 1
     b82:	05 30       	cpi	r16, 0x05	; 5
     b84:	e1 f6       	brne	.-72     	; 0xb3e <KEYBAD_voidGetPressedKey+0x3e>
				*Flag=1;
			}
		}
	}

	DIO_voidSetPortValueMask(PortD,0xFF,0x17);
     b86:	83 e0       	ldi	r24, 0x03	; 3
     b88:	6f ef       	ldi	r22, 0xFF	; 255
     b8a:	47 e1       	ldi	r20, 0x17	; 23
     b8c:	0e 94 b6 01 	call	0x36c	; 0x36c <DIO_voidSetPortValueMask>

	return;
}
     b90:	df 91       	pop	r29
     b92:	cf 91       	pop	r28
     b94:	1f 91       	pop	r17
     b96:	0f 91       	pop	r16
     b98:	ff 90       	pop	r15
     b9a:	ef 90       	pop	r14
     b9c:	df 90       	pop	r13
     b9e:	cf 90       	pop	r12
     ba0:	bf 90       	pop	r11
     ba2:	af 90       	pop	r10
     ba4:	9f 90       	pop	r9
     ba6:	8f 90       	pop	r8
     ba8:	7f 90       	pop	r7
     baa:	6f 90       	pop	r6
     bac:	5f 90       	pop	r5
     bae:	4f 90       	pop	r4
     bb0:	08 95       	ret

00000bb2 <KEYBAD_voidInitialization>:
#include "KEYBAD_int.h"


void KEYBAD_voidInitialization(void)
{
	DIO_voidSetPinDirection(PortC,Pin5,Input);
     bb2:	82 e0       	ldi	r24, 0x02	; 2
     bb4:	65 e0       	ldi	r22, 0x05	; 5
     bb6:	40 e0       	ldi	r20, 0x00	; 0
     bb8:	0e 94 51 00 	call	0xa2	; 0xa2 <DIO_voidSetPinDirection>
	DIO_voidSetPinDirection(PortC,Pin4,Input);
     bbc:	82 e0       	ldi	r24, 0x02	; 2
     bbe:	64 e0       	ldi	r22, 0x04	; 4
     bc0:	40 e0       	ldi	r20, 0x00	; 0
     bc2:	0e 94 51 00 	call	0xa2	; 0xa2 <DIO_voidSetPinDirection>
	DIO_voidSetPinDirection(PortC,Pin3,Input);
     bc6:	82 e0       	ldi	r24, 0x02	; 2
     bc8:	63 e0       	ldi	r22, 0x03	; 3
     bca:	40 e0       	ldi	r20, 0x00	; 0
     bcc:	0e 94 51 00 	call	0xa2	; 0xa2 <DIO_voidSetPinDirection>
	DIO_voidSetPinDirection(PortC,Pin2,Input);
     bd0:	82 e0       	ldi	r24, 0x02	; 2
     bd2:	62 e0       	ldi	r22, 0x02	; 2
     bd4:	40 e0       	ldi	r20, 0x00	; 0
     bd6:	0e 94 51 00 	call	0xa2	; 0xa2 <DIO_voidSetPinDirection>

	DIO_voidSetPinValue(PortC,Pin5,High);
     bda:	82 e0       	ldi	r24, 0x02	; 2
     bdc:	65 e0       	ldi	r22, 0x05	; 5
     bde:	41 e0       	ldi	r20, 0x01	; 1
     be0:	0e 94 c2 00 	call	0x184	; 0x184 <DIO_voidSetPinValue>
	DIO_voidSetPinValue(PortC,Pin4,High);
     be4:	82 e0       	ldi	r24, 0x02	; 2
     be6:	64 e0       	ldi	r22, 0x04	; 4
     be8:	41 e0       	ldi	r20, 0x01	; 1
     bea:	0e 94 c2 00 	call	0x184	; 0x184 <DIO_voidSetPinValue>
	DIO_voidSetPinValue(PortC,Pin3,High);
     bee:	82 e0       	ldi	r24, 0x02	; 2
     bf0:	63 e0       	ldi	r22, 0x03	; 3
     bf2:	41 e0       	ldi	r20, 0x01	; 1
     bf4:	0e 94 c2 00 	call	0x184	; 0x184 <DIO_voidSetPinValue>
	DIO_voidSetPinValue(PortC,Pin2,High);
     bf8:	82 e0       	ldi	r24, 0x02	; 2
     bfa:	62 e0       	ldi	r22, 0x02	; 2
     bfc:	41 e0       	ldi	r20, 0x01	; 1
     bfe:	0e 94 c2 00 	call	0x184	; 0x184 <DIO_voidSetPinValue>




	DIO_voidSetPinDirection(PortD,Pin7,Output);
     c02:	83 e0       	ldi	r24, 0x03	; 3
     c04:	67 e0       	ldi	r22, 0x07	; 7
     c06:	41 e0       	ldi	r20, 0x01	; 1
     c08:	0e 94 51 00 	call	0xa2	; 0xa2 <DIO_voidSetPinDirection>
	DIO_voidSetPinDirection(PortD,Pin6,Output);
     c0c:	83 e0       	ldi	r24, 0x03	; 3
     c0e:	66 e0       	ldi	r22, 0x06	; 6
     c10:	41 e0       	ldi	r20, 0x01	; 1
     c12:	0e 94 51 00 	call	0xa2	; 0xa2 <DIO_voidSetPinDirection>
	DIO_voidSetPinDirection(PortD,Pin5,Output);
     c16:	83 e0       	ldi	r24, 0x03	; 3
     c18:	65 e0       	ldi	r22, 0x05	; 5
     c1a:	41 e0       	ldi	r20, 0x01	; 1
     c1c:	0e 94 51 00 	call	0xa2	; 0xa2 <DIO_voidSetPinDirection>
	DIO_voidSetPinDirection(PortD,Pin3,Output);
     c20:	83 e0       	ldi	r24, 0x03	; 3
     c22:	63 e0       	ldi	r22, 0x03	; 3
     c24:	41 e0       	ldi	r20, 0x01	; 1
     c26:	0e 94 51 00 	call	0xa2	; 0xa2 <DIO_voidSetPinDirection>

	DIO_voidSetPinValue(PortD,Pin7,High);
     c2a:	83 e0       	ldi	r24, 0x03	; 3
     c2c:	67 e0       	ldi	r22, 0x07	; 7
     c2e:	41 e0       	ldi	r20, 0x01	; 1
     c30:	0e 94 c2 00 	call	0x184	; 0x184 <DIO_voidSetPinValue>
	DIO_voidSetPinValue(PortD,Pin6,High);
     c34:	83 e0       	ldi	r24, 0x03	; 3
     c36:	66 e0       	ldi	r22, 0x06	; 6
     c38:	41 e0       	ldi	r20, 0x01	; 1
     c3a:	0e 94 c2 00 	call	0x184	; 0x184 <DIO_voidSetPinValue>
	DIO_voidSetPinValue(PortD,Pin5,High);
     c3e:	83 e0       	ldi	r24, 0x03	; 3
     c40:	65 e0       	ldi	r22, 0x05	; 5
     c42:	41 e0       	ldi	r20, 0x01	; 1
     c44:	0e 94 c2 00 	call	0x184	; 0x184 <DIO_voidSetPinValue>
	DIO_voidSetPinValue(PortD,Pin3,High);
     c48:	83 e0       	ldi	r24, 0x03	; 3
     c4a:	63 e0       	ldi	r22, 0x03	; 3
     c4c:	41 e0       	ldi	r20, 0x01	; 1
     c4e:	0e 94 c2 00 	call	0x184	; 0x184 <DIO_voidSetPinValue>

	//return;
}
     c52:	08 95       	ret

00000c54 <xEventGroupClearBits>:
}
/*-----------------------------------------------------------*/

EventBits_t xEventGroupClearBits( EventGroupHandle_t xEventGroup,
                                  const EventBits_t uxBitsToClear )
{
     c54:	fc 01       	movw	r30, r24
    /* Check the user is not attempting to clear the bits used by the kernel
     * itself. */
    configASSERT( xEventGroup );
    configASSERT( ( uxBitsToClear & eventEVENT_BITS_CONTROL_BYTES ) == 0 );

    taskENTER_CRITICAL();
     c56:	0f b6       	in	r0, 0x3f	; 63
     c58:	f8 94       	cli
     c5a:	0f 92       	push	r0
    {
        traceEVENT_GROUP_CLEAR_BITS( xEventGroup, uxBitsToClear );

        /* The value returned is the event group value prior to the bits being
         * cleared. */
        uxReturn = pxEventBits->uxEventBits;
     c5c:	20 81       	ld	r18, Z
     c5e:	31 81       	ldd	r19, Z+1	; 0x01

        /* Clear the bits. */
        pxEventBits->uxEventBits &= ~uxBitsToClear;
     c60:	60 95       	com	r22
     c62:	70 95       	com	r23
     c64:	62 23       	and	r22, r18
     c66:	73 23       	and	r23, r19
     c68:	71 83       	std	Z+1, r23	; 0x01
     c6a:	60 83       	st	Z, r22
    }
    taskEXIT_CRITICAL();
     c6c:	0f 90       	pop	r0
     c6e:	0f be       	out	0x3f, r0	; 63

    return uxReturn;
}
     c70:	c9 01       	movw	r24, r18
     c72:	08 95       	ret

00000c74 <xEventGroupGetBitsFromISR>:

#endif /* if ( ( configUSE_TRACE_FACILITY == 1 ) && ( INCLUDE_xTimerPendFunctionCall == 1 ) && ( configUSE_TIMERS == 1 ) ) */
/*-----------------------------------------------------------*/

EventBits_t xEventGroupGetBitsFromISR( EventGroupHandle_t xEventGroup )
{
     c74:	fc 01       	movw	r30, r24
        uxReturn = pxEventBits->uxEventBits;
    }
    portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

    return uxReturn;
} /*lint !e818 EventGroupHandle_t is a typedef used in other functions to so can't be pointer to const. */
     c76:	80 81       	ld	r24, Z
     c78:	91 81       	ldd	r25, Z+1	; 0x01
     c7a:	08 95       	ret

00000c7c <vEventGroupClearBitsCallback>:
/* For internal use only - execute a 'clear bits' command that was pended from
 * an interrupt. */
void vEventGroupClearBitsCallback( void * pvEventGroup,
                                   const uint32_t ulBitsToClear )
{
    ( void ) xEventGroupClearBits( pvEventGroup, ( EventBits_t ) ulBitsToClear ); /*lint !e9079 Can't avoid cast to void* as a generic timer callback prototype. Callback casts back to original type so safe. */
     c7c:	ba 01       	movw	r22, r20
     c7e:	0e 94 2a 06 	call	0xc54	; 0xc54 <xEventGroupClearBits>
}
     c82:	08 95       	ret

00000c84 <xEventGroupSetBits>:
} /*lint !e818 EventGroupHandle_t is a typedef used in other functions to so can't be pointer to const. */
/*-----------------------------------------------------------*/

EventBits_t xEventGroupSetBits( EventGroupHandle_t xEventGroup,
                                const EventBits_t uxBitsToSet )
{
     c84:	cf 92       	push	r12
     c86:	df 92       	push	r13
     c88:	ef 92       	push	r14
     c8a:	ff 92       	push	r15
     c8c:	0f 93       	push	r16
     c8e:	1f 93       	push	r17
     c90:	cf 93       	push	r28
     c92:	df 93       	push	r29
     c94:	ec 01       	movw	r28, r24
     c96:	8b 01       	movw	r16, r22
     * itself. */
    configASSERT( xEventGroup );
    configASSERT( ( uxBitsToSet & eventEVENT_BITS_CONTROL_BYTES ) == 0 );

    pxList = &( pxEventBits->xTasksWaitingForBits );
    pxListEnd = listGET_END_MARKER( pxList ); /*lint !e826 !e740 !e9087 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
     c98:	85 e0       	ldi	r24, 0x05	; 5
     c9a:	e8 2e       	mov	r14, r24
     c9c:	f1 2c       	mov	r15, r1
     c9e:	ec 0e       	add	r14, r28
     ca0:	fd 1e       	adc	r15, r29
    vTaskSuspendAll();
     ca2:	0e 94 89 15 	call	0x2b12	; 0x2b12 <vTaskSuspendAll>
    {
        traceEVENT_GROUP_SET_BITS( xEventGroup, uxBitsToSet );

        pxListItem = listGET_HEAD_ENTRY( pxList );
     ca6:	ef 81       	ldd	r30, Y+7	; 0x07
     ca8:	f8 85       	ldd	r31, Y+8	; 0x08

        /* Set the bits. */
        pxEventBits->uxEventBits |= uxBitsToSet;
     caa:	88 81       	ld	r24, Y
     cac:	99 81       	ldd	r25, Y+1	; 0x01
     cae:	80 2b       	or	r24, r16
     cb0:	91 2b       	or	r25, r17
     cb2:	99 83       	std	Y+1, r25	; 0x01
     cb4:	88 83       	st	Y, r24
     cb6:	00 e0       	ldi	r16, 0x00	; 0
     cb8:	10 e0       	ldi	r17, 0x00	; 0
     cba:	24 c0       	rjmp	.+72     	; 0xd04 <xEventGroupSetBits+0x80>

        /* See if the new bit value should unblock any tasks. */
        while( pxListItem != pxListEnd )
        {
            pxNext = listGET_NEXT( pxListItem );
     cbc:	d2 80       	ldd	r13, Z+2	; 0x02
     cbe:	c3 80       	ldd	r12, Z+3	; 0x03
            uxBitsWaitedFor = listGET_LIST_ITEM_VALUE( pxListItem );
     cc0:	80 81       	ld	r24, Z
     cc2:	91 81       	ldd	r25, Z+1	; 0x01
            xMatchFound = pdFALSE;

            /* Split the bits waited for from the control bits. */
            uxControlBits = uxBitsWaitedFor & eventEVENT_BITS_CONTROL_BYTES;
     cc4:	bc 01       	movw	r22, r24
     cc6:	60 70       	andi	r22, 0x00	; 0
            uxBitsWaitedFor &= ~eventEVENT_BITS_CONTROL_BYTES;
     cc8:	ac 01       	movw	r20, r24
     cca:	50 70       	andi	r21, 0x00	; 0
     ccc:	28 81       	ld	r18, Y
     cce:	39 81       	ldd	r19, Y+1	; 0x01

            if( ( uxControlBits & eventWAIT_FOR_ALL_BITS ) == ( EventBits_t ) 0 )
     cd0:	92 fd       	sbrc	r25, 2
     cd2:	05 c0       	rjmp	.+10     	; 0xcde <xEventGroupSetBits+0x5a>
            {
                /* Just looking for single bit being set. */
                if( ( uxBitsWaitedFor & pxEventBits->uxEventBits ) != ( EventBits_t ) 0 )
     cd4:	24 23       	and	r18, r20
     cd6:	35 23       	and	r19, r21
     cd8:	23 2b       	or	r18, r19
     cda:	31 f4       	brne	.+12     	; 0xce8 <xEventGroupSetBits+0x64>
     cdc:	0f c0       	rjmp	.+30     	; 0xcfc <xEventGroupSetBits+0x78>
                else
                {
                    mtCOVERAGE_TEST_MARKER();
                }
            }
            else if( ( uxBitsWaitedFor & pxEventBits->uxEventBits ) == uxBitsWaitedFor )
     cde:	24 23       	and	r18, r20
     ce0:	35 23       	and	r19, r21
     ce2:	24 17       	cp	r18, r20
     ce4:	35 07       	cpc	r19, r21
     ce6:	51 f4       	brne	.+20     	; 0xcfc <xEventGroupSetBits+0x78>
            }

            if( xMatchFound != pdFALSE )
            {
                /* The bits match.  Should the bits be cleared on exit? */
                if( ( uxControlBits & eventCLEAR_EVENTS_ON_EXIT_BIT ) != ( EventBits_t ) 0 )
     ce8:	70 ff       	sbrs	r23, 0
     cea:	02 c0       	rjmp	.+4      	; 0xcf0 <xEventGroupSetBits+0x6c>
                {
                    uxBitsToClear |= uxBitsWaitedFor;
     cec:	04 2b       	or	r16, r20
     cee:	15 2b       	or	r17, r21
                /* Store the actual event flag value in the task's event list
                 * item before removing the task from the event list.  The
                 * eventUNBLOCKED_DUE_TO_BIT_SET bit is set so the task knows
                 * that is was unblocked due to its required bits matching, rather
                 * than because it timed out. */
                vTaskRemoveFromUnorderedEventList( pxListItem, pxEventBits->uxEventBits | eventUNBLOCKED_DUE_TO_BIT_SET );
     cf0:	68 81       	ld	r22, Y
     cf2:	79 81       	ldd	r23, Y+1	; 0x01
     cf4:	72 60       	ori	r23, 0x02	; 2
     cf6:	cf 01       	movw	r24, r30
     cf8:	0e 94 b3 17 	call	0x2f66	; 0x2f66 <vTaskRemoveFromUnorderedEventList>
     cfc:	8d 2d       	mov	r24, r13
     cfe:	9c 2d       	mov	r25, r12
     d00:	9c 01       	movw	r18, r24
     d02:	f9 01       	movw	r30, r18

        /* Set the bits. */
        pxEventBits->uxEventBits |= uxBitsToSet;

        /* See if the new bit value should unblock any tasks. */
        while( pxListItem != pxListEnd )
     d04:	ee 15       	cp	r30, r14
     d06:	ff 05       	cpc	r31, r15
     d08:	c9 f6       	brne	.-78     	; 0xcbc <xEventGroupSetBits+0x38>
            pxListItem = pxNext;
        }

        /* Clear any bits that matched when the eventCLEAR_EVENTS_ON_EXIT_BIT
         * bit was set in the control word. */
        pxEventBits->uxEventBits &= ~uxBitsToClear;
     d0a:	00 95       	com	r16
     d0c:	10 95       	com	r17
     d0e:	88 81       	ld	r24, Y
     d10:	99 81       	ldd	r25, Y+1	; 0x01
     d12:	80 23       	and	r24, r16
     d14:	91 23       	and	r25, r17
     d16:	99 83       	std	Y+1, r25	; 0x01
     d18:	88 83       	st	Y, r24
    }
    ( void ) xTaskResumeAll();
     d1a:	0e 94 9b 1b 	call	0x3736	; 0x3736 <xTaskResumeAll>

    return pxEventBits->uxEventBits;
}
     d1e:	88 81       	ld	r24, Y
     d20:	99 81       	ldd	r25, Y+1	; 0x01
     d22:	df 91       	pop	r29
     d24:	cf 91       	pop	r28
     d26:	1f 91       	pop	r17
     d28:	0f 91       	pop	r16
     d2a:	ff 90       	pop	r15
     d2c:	ef 90       	pop	r14
     d2e:	df 90       	pop	r13
     d30:	cf 90       	pop	r12
     d32:	08 95       	ret

00000d34 <vEventGroupSetBitsCallback>:
/* For internal use only - execute a 'set bits' command that was pended from
 * an interrupt. */
void vEventGroupSetBitsCallback( void * pvEventGroup,
                                 const uint32_t ulBitsToSet )
{
    ( void ) xEventGroupSetBits( pvEventGroup, ( EventBits_t ) ulBitsToSet ); /*lint !e9079 Can't avoid cast to void* as a generic timer callback prototype. Callback casts back to original type so safe. */
     d34:	ba 01       	movw	r22, r20
     d36:	0e 94 42 06 	call	0xc84	; 0xc84 <xEventGroupSetBits>
}
     d3a:	08 95       	ret

00000d3c <vEventGroupDelete>:
    return pxEventBits->uxEventBits;
}
/*-----------------------------------------------------------*/

void vEventGroupDelete( EventGroupHandle_t xEventGroup )
{
     d3c:	cf 93       	push	r28
     d3e:	df 93       	push	r29
     d40:	ec 01       	movw	r28, r24

    configASSERT( pxEventBits );

    pxTasksWaitingForBits = &( pxEventBits->xTasksWaitingForBits );

    vTaskSuspendAll();
     d42:	0e 94 89 15 	call	0x2b12	; 0x2b12 <vTaskSuspendAll>
     d46:	06 c0       	rjmp	.+12     	; 0xd54 <vEventGroupDelete+0x18>
        while( listCURRENT_LIST_LENGTH( pxTasksWaitingForBits ) > ( UBaseType_t ) 0 )
        {
            /* Unblock the task, returning 0 as the event list is being deleted
             * and cannot therefore have any bits set. */
            configASSERT( pxTasksWaitingForBits->xListEnd.pxNext != ( const ListItem_t * ) &( pxTasksWaitingForBits->xListEnd ) );
            vTaskRemoveFromUnorderedEventList( pxTasksWaitingForBits->xListEnd.pxNext, eventUNBLOCKED_DUE_TO_BIT_SET );
     d48:	8f 81       	ldd	r24, Y+7	; 0x07
     d4a:	98 85       	ldd	r25, Y+8	; 0x08
     d4c:	60 e0       	ldi	r22, 0x00	; 0
     d4e:	72 e0       	ldi	r23, 0x02	; 2
     d50:	0e 94 b3 17 	call	0x2f66	; 0x2f66 <vTaskRemoveFromUnorderedEventList>

    vTaskSuspendAll();
    {
        traceEVENT_GROUP_DELETE( xEventGroup );

        while( listCURRENT_LIST_LENGTH( pxTasksWaitingForBits ) > ( UBaseType_t ) 0 )
     d54:	8a 81       	ldd	r24, Y+2	; 0x02
     d56:	88 23       	and	r24, r24
     d58:	b9 f7       	brne	.-18     	; 0xd48 <vEventGroupDelete+0xc>
             * and cannot therefore have any bits set. */
            configASSERT( pxTasksWaitingForBits->xListEnd.pxNext != ( const ListItem_t * ) &( pxTasksWaitingForBits->xListEnd ) );
            vTaskRemoveFromUnorderedEventList( pxTasksWaitingForBits->xListEnd.pxNext, eventUNBLOCKED_DUE_TO_BIT_SET );
        }
    }
    ( void ) xTaskResumeAll();
     d5a:	0e 94 9b 1b 	call	0x3736	; 0x3736 <xTaskResumeAll>

    #if ( ( configSUPPORT_DYNAMIC_ALLOCATION == 1 ) && ( configSUPPORT_STATIC_ALLOCATION == 0 ) )
    {
        /* The event group can only have been allocated dynamically - free
         * it again. */
        vPortFree( pxEventBits );
     d5e:	ce 01       	movw	r24, r28
     d60:	0e 94 b2 07 	call	0xf64	; 0xf64 <vPortFree>
        {
            mtCOVERAGE_TEST_MARKER();
        }
    }
    #endif /* configSUPPORT_DYNAMIC_ALLOCATION */
}
     d64:	df 91       	pop	r29
     d66:	cf 91       	pop	r28
     d68:	08 95       	ret

00000d6a <xEventGroupWaitBits>:
EventBits_t xEventGroupWaitBits( EventGroupHandle_t xEventGroup,
                                 const EventBits_t uxBitsToWaitFor,
                                 const BaseType_t xClearOnExit,
                                 const BaseType_t xWaitForAllBits,
                                 TickType_t xTicksToWait )
{
     d6a:	af 92       	push	r10
     d6c:	bf 92       	push	r11
     d6e:	cf 92       	push	r12
     d70:	df 92       	push	r13
     d72:	ef 92       	push	r14
     d74:	ff 92       	push	r15
     d76:	0f 93       	push	r16
     d78:	1f 93       	push	r17
     d7a:	cf 93       	push	r28
     d7c:	df 93       	push	r29
     d7e:	6c 01       	movw	r12, r24
     d80:	7b 01       	movw	r14, r22
     d82:	a4 2e       	mov	r10, r20
     d84:	b2 2e       	mov	r11, r18
    {
        configASSERT( !( ( xTaskGetSchedulerState() == taskSCHEDULER_SUSPENDED ) && ( xTicksToWait != 0 ) ) );
    }
    #endif

    vTaskSuspendAll();
     d86:	0e 94 89 15 	call	0x2b12	; 0x2b12 <vTaskSuspendAll>
    {
        const EventBits_t uxCurrentEventBits = pxEventBits->uxEventBits;
     d8a:	f6 01       	movw	r30, r12
     d8c:	20 81       	ld	r18, Z
     d8e:	31 81       	ldd	r19, Z+1	; 0x01
     d90:	c7 01       	movw	r24, r14
     d92:	82 23       	and	r24, r18
     d94:	93 23       	and	r25, r19
                                        const EventBits_t uxBitsToWaitFor,
                                        const BaseType_t xWaitForAllBits )
{
    BaseType_t xWaitConditionMet = pdFALSE;

    if( xWaitForAllBits == pdFALSE )
     d96:	bb 20       	and	r11, r11
     d98:	21 f4       	brne	.+8      	; 0xda2 <xEventGroupWaitBits+0x38>
    {
        /* Task only has to wait for one bit within uxBitsToWaitFor to be
         * set.  Is one already set? */
        if( ( uxCurrentEventBits & uxBitsToWaitFor ) != ( EventBits_t ) 0 )
     d9a:	89 2b       	or	r24, r25
     d9c:	09 f0       	breq	.+2      	; 0xda0 <xEventGroupWaitBits+0x36>
     d9e:	5a c0       	rjmp	.+180    	; 0xe54 <xEventGroupWaitBits+0xea>
     da0:	04 c0       	rjmp	.+8      	; 0xdaa <xEventGroupWaitBits+0x40>
    }
    else
    {
        /* Task has to wait for all the bits in uxBitsToWaitFor to be set.
         * Are they set already? */
        if( ( uxCurrentEventBits & uxBitsToWaitFor ) == uxBitsToWaitFor )
     da2:	8e 15       	cp	r24, r14
     da4:	9f 05       	cpc	r25, r15
     da6:	09 f4       	brne	.+2      	; 0xdaa <xEventGroupWaitBits+0x40>
     da8:	55 c0       	rjmp	.+170    	; 0xe54 <xEventGroupWaitBits+0xea>
            else
            {
                mtCOVERAGE_TEST_MARKER();
            }
        }
        else if( xTicksToWait == ( TickType_t ) 0 )
     daa:	01 15       	cp	r16, r1
     dac:	11 05       	cpc	r17, r1
     dae:	59 f4       	brne	.+22     	; 0xdc6 <xEventGroupWaitBits+0x5c>
     db0:	e9 01       	movw	r28, r18
     db2:	1b c0       	rjmp	.+54     	; 0xdea <xEventGroupWaitBits+0x80>
            xTicksToWait = ( TickType_t ) 0;

            /* Clear the wait bits if requested to do so. */
            if( xClearOnExit != pdFALSE )
            {
                pxEventBits->uxEventBits &= ~uxBitsToWaitFor;
     db4:	c7 01       	movw	r24, r14
     db6:	80 95       	com	r24
     db8:	90 95       	com	r25
     dba:	82 23       	and	r24, r18
     dbc:	93 23       	and	r25, r19
     dbe:	f6 01       	movw	r30, r12
     dc0:	91 83       	std	Z+1, r25	; 0x01
     dc2:	80 83       	st	Z, r24
     dc4:	4a c0       	rjmp	.+148    	; 0xe5a <xEventGroupWaitBits+0xf0>
        {
            /* The task is going to block to wait for its required bits to be
             * set.  uxControlBits are used to remember the specified behaviour of
             * this call to xEventGroupWaitBits() - for use when the event bits
             * unblock the task. */
            if( xClearOnExit != pdFALSE )
     dc6:	aa 20       	and	r10, r10
     dc8:	19 f0       	breq	.+6      	; 0xdd0 <xEventGroupWaitBits+0x66>
     dca:	60 e0       	ldi	r22, 0x00	; 0
     dcc:	71 e0       	ldi	r23, 0x01	; 1
     dce:	02 c0       	rjmp	.+4      	; 0xdd4 <xEventGroupWaitBits+0x6a>
     dd0:	60 e0       	ldi	r22, 0x00	; 0
     dd2:	70 e0       	ldi	r23, 0x00	; 0
            else
            {
                mtCOVERAGE_TEST_MARKER();
            }

            if( xWaitForAllBits != pdFALSE )
     dd4:	b1 10       	cpse	r11, r1
            {
                uxControlBits |= eventWAIT_FOR_ALL_BITS;
     dd6:	74 60       	ori	r23, 0x04	; 4
            }

            /* Store the bits that the calling task is waiting for in the
             * task's event list item so the kernel knows when a match is
             * found.  Then enter the blocked state. */
            vTaskPlaceOnUnorderedEventList( &( pxEventBits->xTasksWaitingForBits ), ( uxBitsToWaitFor | uxControlBits ), xTicksToWait );
     dd8:	6e 29       	or	r22, r14
     dda:	7f 29       	or	r23, r15
     ddc:	c6 01       	movw	r24, r12
     dde:	02 96       	adiw	r24, 0x02	; 2
     de0:	a8 01       	movw	r20, r16
     de2:	0e 94 dd 1f 	call	0x3fba	; 0x3fba <vTaskPlaceOnUnorderedEventList>
     de6:	c0 e0       	ldi	r28, 0x00	; 0
     de8:	d0 e0       	ldi	r29, 0x00	; 0
            uxReturn = 0;

            traceEVENT_GROUP_WAIT_BITS_BLOCK( xEventGroup, uxBitsToWaitFor );
        }
    }
    xAlreadyYielded = xTaskResumeAll();
     dea:	0e 94 9b 1b 	call	0x3736	; 0x3736 <xTaskResumeAll>

    if( xTicksToWait != ( TickType_t ) 0 )
     dee:	01 2b       	or	r16, r17
     df0:	29 f1       	breq	.+74     	; 0xe3c <xEventGroupWaitBits+0xd2>
    {
        if( xAlreadyYielded == pdFALSE )
     df2:	88 23       	and	r24, r24
     df4:	11 f4       	brne	.+4      	; 0xdfa <xEventGroupWaitBits+0x90>
        {
            portYIELD_WITHIN_API();
     df6:	0e 94 64 09 	call	0x12c8	; 0x12c8 <vPortYield>

        /* The task blocked to wait for its required bits to be set - at this
         * point either the required bits were set or the block time expired.  If
         * the required bits were set they will have been stored in the task's
         * event list item, and they should now be retrieved then cleared. */
        uxReturn = uxTaskResetEventItemValue();
     dfa:	0e 94 aa 18 	call	0x3154	; 0x3154 <uxTaskResetEventItemValue>

        if( ( uxReturn & eventUNBLOCKED_DUE_TO_BIT_SET ) == ( EventBits_t ) 0 )
     dfe:	91 fd       	sbrc	r25, 1
     e00:	1b c0       	rjmp	.+54     	; 0xe38 <xEventGroupWaitBits+0xce>
        {
            taskENTER_CRITICAL();
     e02:	0f b6       	in	r0, 0x3f	; 63
     e04:	f8 94       	cli
     e06:	0f 92       	push	r0
            {
                /* The task timed out, just return the current event bit value. */
                uxReturn = pxEventBits->uxEventBits;
     e08:	f6 01       	movw	r30, r12
     e0a:	80 81       	ld	r24, Z
     e0c:	91 81       	ldd	r25, Z+1	; 0x01
     e0e:	97 01       	movw	r18, r14
     e10:	28 23       	and	r18, r24
     e12:	39 23       	and	r19, r25
                                        const EventBits_t uxBitsToWaitFor,
                                        const BaseType_t xWaitForAllBits )
{
    BaseType_t xWaitConditionMet = pdFALSE;

    if( xWaitForAllBits == pdFALSE )
     e14:	bb 20       	and	r11, r11
     e16:	19 f4       	brne	.+6      	; 0xe1e <xEventGroupWaitBits+0xb4>
    {
        /* Task only has to wait for one bit within uxBitsToWaitFor to be
         * set.  Is one already set? */
        if( ( uxCurrentEventBits & uxBitsToWaitFor ) != ( EventBits_t ) 0 )
     e18:	23 2b       	or	r18, r19
     e1a:	19 f5       	brne	.+70     	; 0xe62 <xEventGroupWaitBits+0xf8>
     e1c:	0b c0       	rjmp	.+22     	; 0xe34 <xEventGroupWaitBits+0xca>
    }
    else
    {
        /* Task has to wait for all the bits in uxBitsToWaitFor to be set.
         * Are they set already? */
        if( ( uxCurrentEventBits & uxBitsToWaitFor ) == uxBitsToWaitFor )
     e1e:	2e 15       	cp	r18, r14
     e20:	3f 05       	cpc	r19, r15
     e22:	41 f4       	brne	.+16     	; 0xe34 <xEventGroupWaitBits+0xca>
     e24:	1e c0       	rjmp	.+60     	; 0xe62 <xEventGroupWaitBits+0xf8>
                 * task leaving the Blocked state and running again. */
                if( prvTestWaitCondition( uxReturn, uxBitsToWaitFor, xWaitForAllBits ) != pdFALSE )
                {
                    if( xClearOnExit != pdFALSE )
                    {
                        pxEventBits->uxEventBits &= ~uxBitsToWaitFor;
     e26:	e0 94       	com	r14
     e28:	f0 94       	com	r15
     e2a:	e8 22       	and	r14, r24
     e2c:	f9 22       	and	r15, r25
     e2e:	f6 01       	movw	r30, r12
     e30:	f1 82       	std	Z+1, r15	; 0x01
     e32:	e0 82       	st	Z, r14
                    mtCOVERAGE_TEST_MARKER();
                }

                xTimeoutOccurred = pdTRUE;
            }
            taskEXIT_CRITICAL();
     e34:	0f 90       	pop	r0
     e36:	0f be       	out	0x3f, r0	; 63
        {
            /* The task unblocked because the bits were set. */
        }

        /* The task blocked so control bits may have been set. */
        uxReturn &= ~eventEVENT_BITS_CONTROL_BYTES;
     e38:	ec 01       	movw	r28, r24
     e3a:	d0 70       	andi	r29, 0x00	; 0

    /* Prevent compiler warnings when trace macros are not used. */
    ( void ) xTimeoutOccurred;

    return uxReturn;
}
     e3c:	ce 01       	movw	r24, r28
     e3e:	df 91       	pop	r29
     e40:	cf 91       	pop	r28
     e42:	1f 91       	pop	r17
     e44:	0f 91       	pop	r16
     e46:	ff 90       	pop	r15
     e48:	ef 90       	pop	r14
     e4a:	df 90       	pop	r13
     e4c:	cf 90       	pop	r12
     e4e:	bf 90       	pop	r11
     e50:	af 90       	pop	r10
     e52:	08 95       	ret
             * block. */
            uxReturn = uxCurrentEventBits;
            xTicksToWait = ( TickType_t ) 0;

            /* Clear the wait bits if requested to do so. */
            if( xClearOnExit != pdFALSE )
     e54:	aa 20       	and	r10, r10
     e56:	09 f0       	breq	.+2      	; 0xe5a <xEventGroupWaitBits+0xf0>
     e58:	ad cf       	rjmp	.-166    	; 0xdb4 <xEventGroupWaitBits+0x4a>
     e5a:	e9 01       	movw	r28, r18
     e5c:	00 e0       	ldi	r16, 0x00	; 0
     e5e:	10 e0       	ldi	r17, 0x00	; 0
     e60:	c4 cf       	rjmp	.-120    	; 0xdea <xEventGroupWaitBits+0x80>

                /* It is possible that the event bits were updated between this
                 * task leaving the Blocked state and running again. */
                if( prvTestWaitCondition( uxReturn, uxBitsToWaitFor, xWaitForAllBits ) != pdFALSE )
                {
                    if( xClearOnExit != pdFALSE )
     e62:	aa 20       	and	r10, r10
     e64:	01 f7       	brne	.-64     	; 0xe26 <xEventGroupWaitBits+0xbc>
     e66:	e6 cf       	rjmp	.-52     	; 0xe34 <xEventGroupWaitBits+0xca>

00000e68 <xEventGroupSync>:

EventBits_t xEventGroupSync( EventGroupHandle_t xEventGroup,
                             const EventBits_t uxBitsToSet,
                             const EventBits_t uxBitsToWaitFor,
                             TickType_t xTicksToWait )
{
     e68:	af 92       	push	r10
     e6a:	bf 92       	push	r11
     e6c:	cf 92       	push	r12
     e6e:	df 92       	push	r13
     e70:	ef 92       	push	r14
     e72:	ff 92       	push	r15
     e74:	0f 93       	push	r16
     e76:	1f 93       	push	r17
     e78:	cf 93       	push	r28
     e7a:	df 93       	push	r29
     e7c:	6c 01       	movw	r12, r24
     e7e:	8b 01       	movw	r16, r22
     e80:	7a 01       	movw	r14, r20
     e82:	59 01       	movw	r10, r18
    {
        configASSERT( !( ( xTaskGetSchedulerState() == taskSCHEDULER_SUSPENDED ) && ( xTicksToWait != 0 ) ) );
    }
    #endif

    vTaskSuspendAll();
     e84:	0e 94 89 15 	call	0x2b12	; 0x2b12 <vTaskSuspendAll>
    {
        uxOriginalBitValue = pxEventBits->uxEventBits;
     e88:	f6 01       	movw	r30, r12
     e8a:	c0 81       	ld	r28, Z
     e8c:	d1 81       	ldd	r29, Z+1	; 0x01

        ( void ) xEventGroupSetBits( xEventGroup, uxBitsToSet );
     e8e:	c6 01       	movw	r24, r12
     e90:	b8 01       	movw	r22, r16
     e92:	0e 94 42 06 	call	0xc84	; 0xc84 <xEventGroupSetBits>

        if( ( ( uxOriginalBitValue | uxBitsToSet ) & uxBitsToWaitFor ) == uxBitsToWaitFor )
     e96:	c0 2b       	or	r28, r16
     e98:	d1 2b       	or	r29, r17
     e9a:	c7 01       	movw	r24, r14
     e9c:	8c 23       	and	r24, r28
     e9e:	9d 23       	and	r25, r29
     ea0:	8e 15       	cp	r24, r14
     ea2:	9f 05       	cpc	r25, r15
     ea4:	69 f4       	brne	.+26     	; 0xec0 <xEventGroupSync+0x58>
            /* All the rendezvous bits are now set - no need to block. */
            uxReturn = ( uxOriginalBitValue | uxBitsToSet );

            /* Rendezvous always clear the bits.  They will have been cleared
             * already unless this is the only task in the rendezvous. */
            pxEventBits->uxEventBits &= ~uxBitsToWaitFor;
     ea6:	97 01       	movw	r18, r14
     ea8:	20 95       	com	r18
     eaa:	30 95       	com	r19
     eac:	f6 01       	movw	r30, r12
     eae:	80 81       	ld	r24, Z
     eb0:	91 81       	ldd	r25, Z+1	; 0x01
     eb2:	82 23       	and	r24, r18
     eb4:	93 23       	and	r25, r19
     eb6:	91 83       	std	Z+1, r25	; 0x01
     eb8:	80 83       	st	Z, r24
     eba:	aa 24       	eor	r10, r10
     ebc:	bb 24       	eor	r11, r11
     ebe:	10 c0       	rjmp	.+32     	; 0xee0 <xEventGroupSync+0x78>

            xTicksToWait = 0;
        }
        else
        {
            if( xTicksToWait != ( TickType_t ) 0 )
     ec0:	a1 14       	cp	r10, r1
     ec2:	b1 04       	cpc	r11, r1
     ec4:	51 f0       	breq	.+20     	; 0xeda <xEventGroupSync+0x72>
                traceEVENT_GROUP_SYNC_BLOCK( xEventGroup, uxBitsToSet, uxBitsToWaitFor );

                /* Store the bits that the calling task is waiting for in the
                 * task's event list item so the kernel knows when a match is
                 * found.  Then enter the blocked state. */
                vTaskPlaceOnUnorderedEventList( &( pxEventBits->xTasksWaitingForBits ), ( uxBitsToWaitFor | eventCLEAR_EVENTS_ON_EXIT_BIT | eventWAIT_FOR_ALL_BITS ), xTicksToWait );
     ec6:	b7 01       	movw	r22, r14
     ec8:	75 60       	ori	r23, 0x05	; 5
     eca:	c6 01       	movw	r24, r12
     ecc:	02 96       	adiw	r24, 0x02	; 2
     ece:	a5 01       	movw	r20, r10
     ed0:	0e 94 dd 1f 	call	0x3fba	; 0x3fba <vTaskPlaceOnUnorderedEventList>
     ed4:	c0 e0       	ldi	r28, 0x00	; 0
     ed6:	d0 e0       	ldi	r29, 0x00	; 0
     ed8:	03 c0       	rjmp	.+6      	; 0xee0 <xEventGroupSync+0x78>
            }
            else
            {
                /* The rendezvous bits were not set, but no block time was
                 * specified - just return the current event bit value. */
                uxReturn = pxEventBits->uxEventBits;
     eda:	f6 01       	movw	r30, r12
     edc:	c0 81       	ld	r28, Z
     ede:	d1 81       	ldd	r29, Z+1	; 0x01
                xTimeoutOccurred = pdTRUE;
            }
        }
    }
    xAlreadyYielded = xTaskResumeAll();
     ee0:	0e 94 9b 1b 	call	0x3736	; 0x3736 <xTaskResumeAll>

    if( xTicksToWait != ( TickType_t ) 0 )
     ee4:	ab 28       	or	r10, r11
     ee6:	f9 f0       	breq	.+62     	; 0xf26 <xEventGroupSync+0xbe>
    {
        if( xAlreadyYielded == pdFALSE )
     ee8:	88 23       	and	r24, r24
     eea:	11 f4       	brne	.+4      	; 0xef0 <xEventGroupSync+0x88>
        {
            portYIELD_WITHIN_API();
     eec:	0e 94 64 09 	call	0x12c8	; 0x12c8 <vPortYield>

        /* The task blocked to wait for its required bits to be set - at this
         * point either the required bits were set or the block time expired.  If
         * the required bits were set they will have been stored in the task's
         * event list item, and they should now be retrieved then cleared. */
        uxReturn = uxTaskResetEventItemValue();
     ef0:	0e 94 aa 18 	call	0x3154	; 0x3154 <uxTaskResetEventItemValue>
     ef4:	9c 01       	movw	r18, r24

        if( ( uxReturn & eventUNBLOCKED_DUE_TO_BIT_SET ) == ( EventBits_t ) 0 )
     ef6:	91 fd       	sbrc	r25, 1
     ef8:	14 c0       	rjmp	.+40     	; 0xf22 <xEventGroupSync+0xba>
        {
            /* The task timed out, just return the current event bit value. */
            taskENTER_CRITICAL();
     efa:	0f b6       	in	r0, 0x3f	; 63
     efc:	f8 94       	cli
     efe:	0f 92       	push	r0
            {
                uxReturn = pxEventBits->uxEventBits;
     f00:	f6 01       	movw	r30, r12
     f02:	20 81       	ld	r18, Z
     f04:	31 81       	ldd	r19, Z+1	; 0x01

                /* Although the task got here because it timed out before the
                 * bits it was waiting for were set, it is possible that since it
                 * unblocked another task has set the bits.  If this is the case
                 * then it needs to clear the bits before exiting. */
                if( ( uxReturn & uxBitsToWaitFor ) == uxBitsToWaitFor )
     f06:	c7 01       	movw	r24, r14
     f08:	82 23       	and	r24, r18
     f0a:	93 23       	and	r25, r19
     f0c:	8e 15       	cp	r24, r14
     f0e:	9f 05       	cpc	r25, r15
     f10:	31 f4       	brne	.+12     	; 0xf1e <xEventGroupSync+0xb6>
                {
                    pxEventBits->uxEventBits &= ~uxBitsToWaitFor;
     f12:	e0 94       	com	r14
     f14:	f0 94       	com	r15
     f16:	e2 22       	and	r14, r18
     f18:	f3 22       	and	r15, r19
     f1a:	f1 82       	std	Z+1, r15	; 0x01
     f1c:	e0 82       	st	Z, r14
                else
                {
                    mtCOVERAGE_TEST_MARKER();
                }
            }
            taskEXIT_CRITICAL();
     f1e:	0f 90       	pop	r0
     f20:	0f be       	out	0x3f, r0	; 63
            /* The task unblocked because the bits were set. */
        }

        /* Control bits might be set as the task had blocked should not be
         * returned. */
        uxReturn &= ~eventEVENT_BITS_CONTROL_BYTES;
     f22:	e9 01       	movw	r28, r18
     f24:	d0 70       	andi	r29, 0x00	; 0

    /* Prevent compiler warnings when trace macros are not used. */
    ( void ) xTimeoutOccurred;

    return uxReturn;
}
     f26:	ce 01       	movw	r24, r28
     f28:	df 91       	pop	r29
     f2a:	cf 91       	pop	r28
     f2c:	1f 91       	pop	r17
     f2e:	0f 91       	pop	r16
     f30:	ff 90       	pop	r15
     f32:	ef 90       	pop	r14
     f34:	df 90       	pop	r13
     f36:	cf 90       	pop	r12
     f38:	bf 90       	pop	r11
     f3a:	af 90       	pop	r10
     f3c:	08 95       	ret

00000f3e <xEventGroupCreate>:
/*-----------------------------------------------------------*/

#if ( configSUPPORT_DYNAMIC_ALLOCATION == 1 )

    EventGroupHandle_t xEventGroupCreate( void )
    {
     f3e:	cf 93       	push	r28
     f40:	df 93       	push	r29
         * TickType_t alignment requirements the cast is safe.  In other cases,
         * where the natural word size of the architecture is less than
         * sizeof( TickType_t ), the TickType_t variables will be accessed in two
         * or more reads operations, and the alignment requirements is only that
         * of each individual read. */
        pxEventBits = ( EventGroup_t * ) pvPortMalloc( sizeof( EventGroup_t ) ); /*lint !e9087 !e9079 see comment above. */
     f42:	8b e0       	ldi	r24, 0x0B	; 11
     f44:	90 e0       	ldi	r25, 0x00	; 0
     f46:	0e 94 c2 07 	call	0xf84	; 0xf84 <pvPortMalloc>
     f4a:	ec 01       	movw	r28, r24

        if( pxEventBits != NULL )
     f4c:	00 97       	sbiw	r24, 0x00	; 0
     f4e:	31 f0       	breq	.+12     	; 0xf5c <xEventGroupCreate+0x1e>
        {
            pxEventBits->uxEventBits = 0;
     f50:	fc 01       	movw	r30, r24
     f52:	11 92       	st	Z+, r1
     f54:	11 92       	st	Z+, r1
            vListInitialise( &( pxEventBits->xTasksWaitingForBits ) );
     f56:	cf 01       	movw	r24, r30
     f58:	0e 94 f6 07 	call	0xfec	; 0xfec <vListInitialise>
        {
            traceEVENT_GROUP_CREATE_FAILED(); /*lint !e9063 Else branch only exists to allow tracing and does not generate code if trace macros are not defined. */
        }

        return pxEventBits;
    }
     f5c:	ce 01       	movw	r24, r28
     f5e:	df 91       	pop	r29
     f60:	cf 91       	pop	r28
     f62:	08 95       	ret

00000f64 <vPortFree>:
     * https://www.FreeRTOS.org for more information. */
    ( void ) pv;

    /* Force an assert as it is invalid to call this function. */
    configASSERT( pv == NULL );
}
     f64:	08 95       	ret

00000f66 <vPortInitialiseBlocks>:
/*-----------------------------------------------------------*/

void vPortInitialiseBlocks( void )
{
    /* Only required when static memory is not cleared. */
    xNextFreeByte = ( size_t ) 0;
     f66:	10 92 17 01 	sts	0x0117, r1
     f6a:	10 92 16 01 	sts	0x0116, r1
}
     f6e:	08 95       	ret

00000f70 <xPortGetFreeHeapSize>:
/*-----------------------------------------------------------*/

size_t xPortGetFreeHeapSize( void )
{
     f70:	2b ed       	ldi	r18, 0xDB	; 219
     f72:	35 e0       	ldi	r19, 0x05	; 5
     f74:	80 91 16 01 	lds	r24, 0x0116
     f78:	90 91 17 01 	lds	r25, 0x0117
     f7c:	28 1b       	sub	r18, r24
     f7e:	39 0b       	sbc	r19, r25
    return( configADJUSTED_HEAP_SIZE - xNextFreeByte );
}
     f80:	c9 01       	movw	r24, r18
     f82:	08 95       	ret

00000f84 <pvPortMalloc>:
static size_t xNextFreeByte = ( size_t ) 0;

/*-----------------------------------------------------------*/

void * pvPortMalloc( size_t xWantedSize )
{
     f84:	cf 93       	push	r28
     f86:	df 93       	push	r29
     f88:	ec 01       	movw	r28, r24
            }
        }
    }
    #endif /* if ( portBYTE_ALIGNMENT != 1 ) */

    vTaskSuspendAll();
     f8a:	0e 94 89 15 	call	0x2b12	; 0x2b12 <vTaskSuspendAll>
    {
        if( pucAlignedHeap == NULL )
     f8e:	80 91 18 01 	lds	r24, 0x0118
     f92:	90 91 19 01 	lds	r25, 0x0119
     f96:	89 2b       	or	r24, r25
     f98:	31 f4       	brne	.+12     	; 0xfa6 <pvPortMalloc+0x22>
        {
            /* Ensure the heap starts on a correctly aligned boundary. */
            pucAlignedHeap = ( uint8_t * ) ( ( ( portPOINTER_SIZE_TYPE ) & ucHeap[ portBYTE_ALIGNMENT - 1 ] ) & ( ~( ( portPOINTER_SIZE_TYPE ) portBYTE_ALIGNMENT_MASK ) ) );
     f9a:	8a e1       	ldi	r24, 0x1A	; 26
     f9c:	91 e0       	ldi	r25, 0x01	; 1
     f9e:	90 93 19 01 	sts	0x0119, r25
     fa2:	80 93 18 01 	sts	0x0118, r24
        }

        /* Check there is enough room left for the allocation and. */
        if( ( xWantedSize > 0 ) &&                                /* valid size */
     fa6:	20 97       	sbiw	r28, 0x00	; 0
     fa8:	c9 f0       	breq	.+50     	; 0xfdc <pvPortMalloc+0x58>
     faa:	20 91 16 01 	lds	r18, 0x0116
     fae:	30 91 17 01 	lds	r19, 0x0117
     fb2:	ce 01       	movw	r24, r28
     fb4:	82 0f       	add	r24, r18
     fb6:	93 1f       	adc	r25, r19
     fb8:	45 e0       	ldi	r20, 0x05	; 5
     fba:	8b 3d       	cpi	r24, 0xDB	; 219
     fbc:	94 07       	cpc	r25, r20
     fbe:	70 f4       	brcc	.+28     	; 0xfdc <pvPortMalloc+0x58>
     fc0:	28 17       	cp	r18, r24
     fc2:	39 07       	cpc	r19, r25
     fc4:	58 f4       	brcc	.+22     	; 0xfdc <pvPortMalloc+0x58>
            ( ( xNextFreeByte + xWantedSize ) < configADJUSTED_HEAP_SIZE ) &&
            ( ( xNextFreeByte + xWantedSize ) > xNextFreeByte ) ) /* Check for overflow. */
        {
            /* Return the next free byte then increment the index past this
             * block. */
            pvReturn = pucAlignedHeap + xNextFreeByte;
     fc6:	c0 91 18 01 	lds	r28, 0x0118
     fca:	d0 91 19 01 	lds	r29, 0x0119
     fce:	c2 0f       	add	r28, r18
     fd0:	d3 1f       	adc	r29, r19
            xNextFreeByte += xWantedSize;
     fd2:	90 93 17 01 	sts	0x0117, r25
     fd6:	80 93 16 01 	sts	0x0116, r24
     fda:	02 c0       	rjmp	.+4      	; 0xfe0 <pvPortMalloc+0x5c>
     fdc:	c0 e0       	ldi	r28, 0x00	; 0
     fde:	d0 e0       	ldi	r29, 0x00	; 0
        }

        traceMALLOC( pvReturn, xWantedSize );
    }
    ( void ) xTaskResumeAll();
     fe0:	0e 94 9b 1b 	call	0x3736	; 0x3736 <xTaskResumeAll>
        }
    }
    #endif

    return pvReturn;
}
     fe4:	ce 01       	movw	r24, r28
     fe6:	df 91       	pop	r29
     fe8:	cf 91       	pop	r28
     fea:	08 95       	ret

00000fec <vListInitialise>:
/*-----------------------------------------------------------
* PUBLIC LIST API documented in list.h
*----------------------------------------------------------*/

void vListInitialise( List_t * const pxList )
{
     fec:	fc 01       	movw	r30, r24
    /* The list structure contains a list item which is used to mark the
     * end of the list.  To initialise the list the list end is inserted
     * as the only list entry. */
    pxList->pxIndex = ( ListItem_t * ) &( pxList->xListEnd ); /*lint !e826 !e740 !e9087 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
     fee:	9c 01       	movw	r18, r24
     ff0:	2d 5f       	subi	r18, 0xFD	; 253
     ff2:	3f 4f       	sbci	r19, 0xFF	; 255
     ff4:	32 83       	std	Z+2, r19	; 0x02
     ff6:	21 83       	std	Z+1, r18	; 0x01

    listSET_FIRST_LIST_ITEM_INTEGRITY_CHECK_VALUE( &( pxList->xListEnd ) );

    /* The list end value is the highest possible value in the list to
     * ensure it remains at the end of the list. */
    pxList->xListEnd.xItemValue = portMAX_DELAY;
     ff8:	8f ef       	ldi	r24, 0xFF	; 255
     ffa:	9f ef       	ldi	r25, 0xFF	; 255
     ffc:	94 83       	std	Z+4, r25	; 0x04
     ffe:	83 83       	std	Z+3, r24	; 0x03

    /* The list end next and previous pointers point to itself so we know
     * when the list is empty. */
    pxList->xListEnd.pxNext = ( ListItem_t * ) &( pxList->xListEnd );     /*lint !e826 !e740 !e9087 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
    1000:	36 83       	std	Z+6, r19	; 0x06
    1002:	25 83       	std	Z+5, r18	; 0x05
    pxList->xListEnd.pxPrevious = ( ListItem_t * ) &( pxList->xListEnd ); /*lint !e826 !e740 !e9087 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
    1004:	30 87       	std	Z+8, r19	; 0x08
    1006:	27 83       	std	Z+7, r18	; 0x07
        pxList->xListEnd.pxContainer = NULL;
        listSET_SECOND_LIST_ITEM_INTEGRITY_CHECK_VALUE( &( pxList->xListEnd ) );
    }
    #endif

    pxList->uxNumberOfItems = ( UBaseType_t ) 0U;
    1008:	10 82       	st	Z, r1

    /* Write known values into the list if
     * configUSE_LIST_DATA_INTEGRITY_CHECK_BYTES is set to 1. */
    listSET_LIST_INTEGRITY_CHECK_1_VALUE( pxList );
    listSET_LIST_INTEGRITY_CHECK_2_VALUE( pxList );
}
    100a:	08 95       	ret

0000100c <vListInitialiseItem>:
/*-----------------------------------------------------------*/

void vListInitialiseItem( ListItem_t * const pxItem )
{
    /* Make sure the list item is not recorded as being on a list. */
    pxItem->pxContainer = NULL;
    100c:	fc 01       	movw	r30, r24
    100e:	11 86       	std	Z+9, r1	; 0x09
    1010:	10 86       	std	Z+8, r1	; 0x08

    /* Write known values into the list item if
     * configUSE_LIST_DATA_INTEGRITY_CHECK_BYTES is set to 1. */
    listSET_FIRST_LIST_ITEM_INTEGRITY_CHECK_VALUE( pxItem );
    listSET_SECOND_LIST_ITEM_INTEGRITY_CHECK_VALUE( pxItem );
}
    1012:	08 95       	ret

00001014 <vListInsertEnd>:
/*-----------------------------------------------------------*/

void vListInsertEnd( List_t * const pxList,
                     ListItem_t * const pxNewListItem )
{
    1014:	ac 01       	movw	r20, r24
    ListItem_t * const pxIndex = pxList->pxIndex;
    1016:	fc 01       	movw	r30, r24
    1018:	a1 81       	ldd	r26, Z+1	; 0x01
    101a:	b2 81       	ldd	r27, Z+2	; 0x02
    listTEST_LIST_ITEM_INTEGRITY( pxNewListItem );

    /* Insert a new list item into pxList, but rather than sort the list,
     * makes the new list item the last item to be removed by a call to
     * listGET_OWNER_OF_NEXT_ENTRY(). */
    pxNewListItem->pxNext = pxIndex;
    101c:	fb 01       	movw	r30, r22
    101e:	b3 83       	std	Z+3, r27	; 0x03
    1020:	a2 83       	std	Z+2, r26	; 0x02
    pxNewListItem->pxPrevious = pxIndex->pxPrevious;
    1022:	14 96       	adiw	r26, 0x04	; 4
    1024:	8d 91       	ld	r24, X+
    1026:	9c 91       	ld	r25, X
    1028:	15 97       	sbiw	r26, 0x05	; 5
    102a:	95 83       	std	Z+5, r25	; 0x05
    102c:	84 83       	std	Z+4, r24	; 0x04

    /* Only used during decision coverage testing. */
    mtCOVERAGE_TEST_DELAY();

    pxIndex->pxPrevious->pxNext = pxNewListItem;
    102e:	14 96       	adiw	r26, 0x04	; 4
    1030:	ed 91       	ld	r30, X+
    1032:	fc 91       	ld	r31, X
    1034:	15 97       	sbiw	r26, 0x05	; 5
    1036:	73 83       	std	Z+3, r23	; 0x03
    1038:	62 83       	std	Z+2, r22	; 0x02
    pxIndex->pxPrevious = pxNewListItem;
    103a:	15 96       	adiw	r26, 0x05	; 5
    103c:	7c 93       	st	X, r23
    103e:	6e 93       	st	-X, r22
    1040:	14 97       	sbiw	r26, 0x04	; 4

    /* Remember which list the item is in. */
    pxNewListItem->pxContainer = pxList;
    1042:	fb 01       	movw	r30, r22
    1044:	51 87       	std	Z+9, r21	; 0x09
    1046:	40 87       	std	Z+8, r20	; 0x08

    ( pxList->uxNumberOfItems )++;
    1048:	fa 01       	movw	r30, r20
    104a:	80 81       	ld	r24, Z
    104c:	8f 5f       	subi	r24, 0xFF	; 255
    104e:	80 83       	st	Z, r24
}
    1050:	08 95       	ret

00001052 <vListInsert>:
/*-----------------------------------------------------------*/

void vListInsert( List_t * const pxList,
                  ListItem_t * const pxNewListItem )
{
    1052:	cf 93       	push	r28
    1054:	df 93       	push	r29
    1056:	9c 01       	movw	r18, r24
    1058:	eb 01       	movw	r28, r22
    ListItem_t * pxIterator;
    const TickType_t xValueOfInsertion = pxNewListItem->xItemValue;
    105a:	48 81       	ld	r20, Y
    105c:	59 81       	ldd	r21, Y+1	; 0x01
     * new list item should be placed after it.  This ensures that TCBs which are
     * stored in ready lists (all of which have the same xItemValue value) get a
     * share of the CPU.  However, if the xItemValue is the same as the back marker
     * the iteration loop below will not end.  Therefore the value is checked
     * first, and the algorithm slightly modified if necessary. */
    if( xValueOfInsertion == portMAX_DELAY )
    105e:	8f ef       	ldi	r24, 0xFF	; 255
    1060:	4f 3f       	cpi	r20, 0xFF	; 255
    1062:	58 07       	cpc	r21, r24
    1064:	21 f4       	brne	.+8      	; 0x106e <vListInsert+0x1c>
    {
        pxIterator = pxList->xListEnd.pxPrevious;
    1066:	f9 01       	movw	r30, r18
    1068:	a7 81       	ldd	r26, Z+7	; 0x07
    106a:	b0 85       	ldd	r27, Z+8	; 0x08
    106c:	0d c0       	rjmp	.+26     	; 0x1088 <vListInsert+0x36>
        *   5) If the FreeRTOS port supports interrupt nesting then ensure that
        *      the priority of the tick interrupt is at or below
        *      configMAX_SYSCALL_INTERRUPT_PRIORITY.
        **********************************************************************/

        for( pxIterator = ( ListItem_t * ) &( pxList->xListEnd ); pxIterator->pxNext->xItemValue <= xValueOfInsertion; pxIterator = pxIterator->pxNext ) /*lint !e826 !e740 !e9087 The mini list structure is used as the list end to save RAM.  This is checked and valid. *//*lint !e440 The iterator moves to a different value, not xValueOfInsertion. */
    106e:	d9 01       	movw	r26, r18
    1070:	13 96       	adiw	r26, 0x03	; 3
    1072:	12 96       	adiw	r26, 0x02	; 2
    1074:	ed 91       	ld	r30, X+
    1076:	fc 91       	ld	r31, X
    1078:	13 97       	sbiw	r26, 0x03	; 3
    107a:	80 81       	ld	r24, Z
    107c:	91 81       	ldd	r25, Z+1	; 0x01
    107e:	48 17       	cp	r20, r24
    1080:	59 07       	cpc	r21, r25
    1082:	10 f0       	brcs	.+4      	; 0x1088 <vListInsert+0x36>
    1084:	df 01       	movw	r26, r30
    1086:	f5 cf       	rjmp	.-22     	; 0x1072 <vListInsert+0x20>
            /* There is nothing to do here, just iterating to the wanted
             * insertion position. */
        }
    }

    pxNewListItem->pxNext = pxIterator->pxNext;
    1088:	12 96       	adiw	r26, 0x02	; 2
    108a:	ed 91       	ld	r30, X+
    108c:	fc 91       	ld	r31, X
    108e:	13 97       	sbiw	r26, 0x03	; 3
    1090:	fb 83       	std	Y+3, r31	; 0x03
    1092:	ea 83       	std	Y+2, r30	; 0x02
    pxNewListItem->pxNext->pxPrevious = pxNewListItem;
    1094:	d5 83       	std	Z+5, r29	; 0x05
    1096:	c4 83       	std	Z+4, r28	; 0x04
    pxNewListItem->pxPrevious = pxIterator;
    1098:	bd 83       	std	Y+5, r27	; 0x05
    109a:	ac 83       	std	Y+4, r26	; 0x04
    pxIterator->pxNext = pxNewListItem;
    109c:	13 96       	adiw	r26, 0x03	; 3
    109e:	dc 93       	st	X, r29
    10a0:	ce 93       	st	-X, r28
    10a2:	12 97       	sbiw	r26, 0x02	; 2

    /* Remember which list the item is in.  This allows fast removal of the
     * item later. */
    pxNewListItem->pxContainer = pxList;
    10a4:	39 87       	std	Y+9, r19	; 0x09
    10a6:	28 87       	std	Y+8, r18	; 0x08

    ( pxList->uxNumberOfItems )++;
    10a8:	f9 01       	movw	r30, r18
    10aa:	80 81       	ld	r24, Z
    10ac:	8f 5f       	subi	r24, 0xFF	; 255
    10ae:	80 83       	st	Z, r24
}
    10b0:	df 91       	pop	r29
    10b2:	cf 91       	pop	r28
    10b4:	08 95       	ret

000010b6 <uxListRemove>:
/*-----------------------------------------------------------*/

UBaseType_t uxListRemove( ListItem_t * const pxItemToRemove )
{
    10b6:	cf 93       	push	r28
    10b8:	df 93       	push	r29
    10ba:	dc 01       	movw	r26, r24
/* The list item knows which list it is in.  Obtain the list from the list
 * item. */
    List_t * const pxList = pxItemToRemove->pxContainer;
    10bc:	18 96       	adiw	r26, 0x08	; 8
    10be:	cd 91       	ld	r28, X+
    10c0:	dc 91       	ld	r29, X
    10c2:	19 97       	sbiw	r26, 0x09	; 9

    pxItemToRemove->pxNext->pxPrevious = pxItemToRemove->pxPrevious;
    10c4:	12 96       	adiw	r26, 0x02	; 2
    10c6:	4d 91       	ld	r20, X+
    10c8:	5c 91       	ld	r21, X
    10ca:	13 97       	sbiw	r26, 0x03	; 3
    10cc:	14 96       	adiw	r26, 0x04	; 4
    10ce:	8d 91       	ld	r24, X+
    10d0:	9c 91       	ld	r25, X
    10d2:	15 97       	sbiw	r26, 0x05	; 5
    10d4:	fa 01       	movw	r30, r20
    10d6:	95 83       	std	Z+5, r25	; 0x05
    10d8:	84 83       	std	Z+4, r24	; 0x04
    pxItemToRemove->pxPrevious->pxNext = pxItemToRemove->pxNext;
    10da:	14 96       	adiw	r26, 0x04	; 4
    10dc:	2d 91       	ld	r18, X+
    10de:	3c 91       	ld	r19, X
    10e0:	15 97       	sbiw	r26, 0x05	; 5
    10e2:	f9 01       	movw	r30, r18
    10e4:	53 83       	std	Z+3, r21	; 0x03
    10e6:	42 83       	std	Z+2, r20	; 0x02

    /* Only used during decision coverage testing. */
    mtCOVERAGE_TEST_DELAY();

    /* Make sure the index is left pointing to a valid item. */
    if( pxList->pxIndex == pxItemToRemove )
    10e8:	89 81       	ldd	r24, Y+1	; 0x01
    10ea:	9a 81       	ldd	r25, Y+2	; 0x02
    10ec:	8a 17       	cp	r24, r26
    10ee:	9b 07       	cpc	r25, r27
    10f0:	11 f4       	brne	.+4      	; 0x10f6 <uxListRemove+0x40>
    {
        pxList->pxIndex = pxItemToRemove->pxPrevious;
    10f2:	3a 83       	std	Y+2, r19	; 0x02
    10f4:	29 83       	std	Y+1, r18	; 0x01
    else
    {
        mtCOVERAGE_TEST_MARKER();
    }

    pxItemToRemove->pxContainer = NULL;
    10f6:	19 96       	adiw	r26, 0x09	; 9
    10f8:	1c 92       	st	X, r1
    10fa:	1e 92       	st	-X, r1
    10fc:	18 97       	sbiw	r26, 0x08	; 8
    ( pxList->uxNumberOfItems )--;
    10fe:	88 81       	ld	r24, Y
    1100:	81 50       	subi	r24, 0x01	; 1
    1102:	88 83       	st	Y, r24

    return pxList->uxNumberOfItems;
    1104:	88 81       	ld	r24, Y
}
    1106:	df 91       	pop	r29
    1108:	cf 91       	pop	r28
    110a:	08 95       	ret

0000110c <pxPortInitialiseStack>:

/* 
 * See header file for description. 
 */
StackType_t *pxPortInitialiseStack( StackType_t *pxTopOfStack, TaskFunction_t pxCode, void *pvParameters )
{
    110c:	fc 01       	movw	r30, r24
uint16_t usAddress;

	/* Place a few bytes of known values on the bottom of the stack. 
	This is just useful for debugging. */

	*pxTopOfStack = 0x11;
    110e:	91 e1       	ldi	r25, 0x11	; 17
    1110:	90 83       	st	Z, r25
	pxTopOfStack--;
	*pxTopOfStack = 0x22;
    1112:	22 e2       	ldi	r18, 0x22	; 34
    1114:	22 93       	st	-Z, r18
	pxTopOfStack--;
	*pxTopOfStack = 0x33;
    1116:	83 e3       	ldi	r24, 0x33	; 51
    1118:	82 93       	st	-Z, r24
	/*lint -e950 -e611 -e923 Lint doesn't like this much - but nothing I can do about it. */

	/* The start of the task code will be popped off the stack last, so place
	it on first. */
	usAddress = ( uint16_t ) pxCode;
	*pxTopOfStack = ( StackType_t ) ( usAddress & ( uint16_t ) 0x00ff );
    111a:	62 93       	st	-Z, r22
	pxTopOfStack--;

	usAddress >>= 8;
	*pxTopOfStack = ( StackType_t ) ( usAddress & ( uint16_t ) 0x00ff );
    111c:	72 93       	st	-Z, r23

	/* Next simulate the stack as if after a call to portSAVE_CONTEXT().  
	portSAVE_CONTEXT places the flags on the stack immediately after r0
	to ensure the interrupts get disabled as soon as possible, and so ensuring
	the stack use is minimal should a context switch interrupt occur. */
	*pxTopOfStack = ( StackType_t ) 0x00;	/* R0 */
    111e:	12 92       	st	-Z, r1
	pxTopOfStack--;
	*pxTopOfStack = portFLAGS_INT_ENABLED;
    1120:	80 e8       	ldi	r24, 0x80	; 128
    1122:	82 93       	st	-Z, r24
	pxTopOfStack--;


	/* Now the remaining registers.   The compiler expects R1 to be 0. */
	*pxTopOfStack = ( StackType_t ) 0x00;	/* R1 */
    1124:	12 92       	st	-Z, r1
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x02;	/* R2 */
    1126:	82 e0       	ldi	r24, 0x02	; 2
    1128:	82 93       	st	-Z, r24
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x03;	/* R3 */
    112a:	83 e0       	ldi	r24, 0x03	; 3
    112c:	82 93       	st	-Z, r24
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x04;	/* R4 */
    112e:	84 e0       	ldi	r24, 0x04	; 4
    1130:	82 93       	st	-Z, r24
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x05;	/* R5 */
    1132:	85 e0       	ldi	r24, 0x05	; 5
    1134:	82 93       	st	-Z, r24
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x06;	/* R6 */
    1136:	86 e0       	ldi	r24, 0x06	; 6
    1138:	82 93       	st	-Z, r24
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x07;	/* R7 */
    113a:	87 e0       	ldi	r24, 0x07	; 7
    113c:	82 93       	st	-Z, r24
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x08;	/* R8 */
    113e:	88 e0       	ldi	r24, 0x08	; 8
    1140:	82 93       	st	-Z, r24
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x09;	/* R9 */
    1142:	89 e0       	ldi	r24, 0x09	; 9
    1144:	82 93       	st	-Z, r24
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x10;	/* R10 */
    1146:	80 e1       	ldi	r24, 0x10	; 16
    1148:	82 93       	st	-Z, r24
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x11;	/* R11 */
    114a:	92 93       	st	-Z, r25
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x12;	/* R12 */
    114c:	82 e1       	ldi	r24, 0x12	; 18
    114e:	82 93       	st	-Z, r24
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x13;	/* R13 */
    1150:	83 e1       	ldi	r24, 0x13	; 19
    1152:	82 93       	st	-Z, r24
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x14;	/* R14 */
    1154:	84 e1       	ldi	r24, 0x14	; 20
    1156:	82 93       	st	-Z, r24
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x15;	/* R15 */
    1158:	85 e1       	ldi	r24, 0x15	; 21
    115a:	82 93       	st	-Z, r24
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x16;	/* R16 */
    115c:	86 e1       	ldi	r24, 0x16	; 22
    115e:	82 93       	st	-Z, r24
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x17;	/* R17 */
    1160:	87 e1       	ldi	r24, 0x17	; 23
    1162:	82 93       	st	-Z, r24
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x18;	/* R18 */
    1164:	88 e1       	ldi	r24, 0x18	; 24
    1166:	82 93       	st	-Z, r24
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x19;	/* R19 */
    1168:	89 e1       	ldi	r24, 0x19	; 25
    116a:	82 93       	st	-Z, r24
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x20;	/* R20 */
    116c:	80 e2       	ldi	r24, 0x20	; 32
    116e:	82 93       	st	-Z, r24
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x21;	/* R21 */
    1170:	81 e2       	ldi	r24, 0x21	; 33
    1172:	82 93       	st	-Z, r24
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x22;	/* R22 */
    1174:	22 93       	st	-Z, r18
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x23;	/* R23 */
    1176:	83 e2       	ldi	r24, 0x23	; 35
    1178:	82 93       	st	-Z, r24
	pxTopOfStack--;

	/* Place the parameter on the stack in the expected location. */
	usAddress = ( uint16_t ) pvParameters;
	*pxTopOfStack = ( StackType_t ) ( usAddress & ( uint16_t ) 0x00ff );
    117a:	42 93       	st	-Z, r20
	pxTopOfStack--;

	usAddress >>= 8;
	*pxTopOfStack = ( StackType_t ) ( usAddress & ( uint16_t ) 0x00ff );
    117c:	52 93       	st	-Z, r21
	pxTopOfStack--;

	*pxTopOfStack = ( StackType_t ) 0x26;	/* R26 X */
    117e:	86 e2       	ldi	r24, 0x26	; 38
    1180:	82 93       	st	-Z, r24
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x27;	/* R27 */
    1182:	87 e2       	ldi	r24, 0x27	; 39
    1184:	82 93       	st	-Z, r24
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x28;	/* R28 Y */
    1186:	88 e2       	ldi	r24, 0x28	; 40
    1188:	82 93       	st	-Z, r24
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x29;	/* R29 */
    118a:	89 e2       	ldi	r24, 0x29	; 41
    118c:	82 93       	st	-Z, r24
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x30;	/* R30 Z */
    118e:	80 e3       	ldi	r24, 0x30	; 48
    1190:	82 93       	st	-Z, r24
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x031;	/* R31 */
    1192:	81 e3       	ldi	r24, 0x31	; 49
    1194:	82 93       	st	-Z, r24
    1196:	31 97       	sbiw	r30, 0x01	; 1
	pxTopOfStack--;

	/*lint +e950 +e611 +e923 */

	return pxTopOfStack;
}
    1198:	cf 01       	movw	r24, r30
    119a:	08 95       	ret

0000119c <xPortStartScheduler>:
	/* Setup compare match value for compare match A.  Interrupts are disabled 
	before this is called so we need not worry here. */
	ucLowByte = ( uint8_t ) ( ulCompareMatch & ( uint32_t ) 0xff );
	ulCompareMatch >>= 8;
	ucHighByte = ( uint8_t ) ( ulCompareMatch & ( uint32_t ) 0xff );
	OCR1AH = ucHighByte;
    119c:	1b bc       	out	0x2b, r1	; 43
	OCR1AL = ucLowByte;
    119e:	8c e7       	ldi	r24, 0x7C	; 124
    11a0:	8a bd       	out	0x2a, r24	; 42

	/* Setup clock source and compare match behaviour. */
	ucLowByte = portCLEAR_COUNTER_ON_MATCH | portPRESCALE_64;
	TCCR1B = ucLowByte;
    11a2:	8b e0       	ldi	r24, 0x0B	; 11
    11a4:	8e bd       	out	0x2e, r24	; 46

	/* Enable the interrupt - this is okay as interrupt are currently globally
	disabled. */
	ucLowByte = TIMSK;
    11a6:	89 b7       	in	r24, 0x39	; 57
	ucLowByte |= portCOMPARE_MATCH_A_INTERRUPT_ENABLE;
    11a8:	80 61       	ori	r24, 0x10	; 16
	TIMSK = ucLowByte;
    11aa:	89 bf       	out	0x39, r24	; 57
{
	/* Setup the hardware to generate the tick. */
	prvSetupTimerInterrupt();

	/* Restore the context of the first task that is going to run. */
	portRESTORE_CONTEXT();
    11ac:	a0 91 f7 06 	lds	r26, 0x06F7
    11b0:	b0 91 f8 06 	lds	r27, 0x06F8
    11b4:	cd 91       	ld	r28, X+
    11b6:	cd bf       	out	0x3d, r28	; 61
    11b8:	dd 91       	ld	r29, X+
    11ba:	de bf       	out	0x3e, r29	; 62
    11bc:	ff 91       	pop	r31
    11be:	ef 91       	pop	r30
    11c0:	df 91       	pop	r29
    11c2:	cf 91       	pop	r28
    11c4:	bf 91       	pop	r27
    11c6:	af 91       	pop	r26
    11c8:	9f 91       	pop	r25
    11ca:	8f 91       	pop	r24
    11cc:	7f 91       	pop	r23
    11ce:	6f 91       	pop	r22
    11d0:	5f 91       	pop	r21
    11d2:	4f 91       	pop	r20
    11d4:	3f 91       	pop	r19
    11d6:	2f 91       	pop	r18
    11d8:	1f 91       	pop	r17
    11da:	0f 91       	pop	r16
    11dc:	ff 90       	pop	r15
    11de:	ef 90       	pop	r14
    11e0:	df 90       	pop	r13
    11e2:	cf 90       	pop	r12
    11e4:	bf 90       	pop	r11
    11e6:	af 90       	pop	r10
    11e8:	9f 90       	pop	r9
    11ea:	8f 90       	pop	r8
    11ec:	7f 90       	pop	r7
    11ee:	6f 90       	pop	r6
    11f0:	5f 90       	pop	r5
    11f2:	4f 90       	pop	r4
    11f4:	3f 90       	pop	r3
    11f6:	2f 90       	pop	r2
    11f8:	1f 90       	pop	r1
    11fa:	0f 90       	pop	r0
    11fc:	0f be       	out	0x3f, r0	; 63
    11fe:	0f 90       	pop	r0

	/* Simulate a function call end as generated by the compiler.  We will now
	jump to the start of the task the context of which we have just restored. */
	asm volatile ( "ret" );
    1200:	08 95       	ret

	/* Should not get here. */
	return pdTRUE;
}
    1202:	81 e0       	ldi	r24, 0x01	; 1
    1204:	08 95       	ret

00001206 <vPortEndScheduler>:

void vPortEndScheduler( void )
{
	/* It is unlikely that the AVR port will get stopped.  If required simply
	disable the tick interrupt here. */
}
    1206:	08 95       	ret

00001208 <vPortYieldFromTick>:
 * call comes from the tick ISR.
 */
void vPortYieldFromTick( void ) __attribute__ ( ( naked ) );
void vPortYieldFromTick( void )
{
	portSAVE_CONTEXT();
    1208:	0f 92       	push	r0
    120a:	0f b6       	in	r0, 0x3f	; 63
    120c:	f8 94       	cli
    120e:	0f 92       	push	r0
    1210:	1f 92       	push	r1
    1212:	11 24       	eor	r1, r1
    1214:	2f 92       	push	r2
    1216:	3f 92       	push	r3
    1218:	4f 92       	push	r4
    121a:	5f 92       	push	r5
    121c:	6f 92       	push	r6
    121e:	7f 92       	push	r7
    1220:	8f 92       	push	r8
    1222:	9f 92       	push	r9
    1224:	af 92       	push	r10
    1226:	bf 92       	push	r11
    1228:	cf 92       	push	r12
    122a:	df 92       	push	r13
    122c:	ef 92       	push	r14
    122e:	ff 92       	push	r15
    1230:	0f 93       	push	r16
    1232:	1f 93       	push	r17
    1234:	2f 93       	push	r18
    1236:	3f 93       	push	r19
    1238:	4f 93       	push	r20
    123a:	5f 93       	push	r21
    123c:	6f 93       	push	r22
    123e:	7f 93       	push	r23
    1240:	8f 93       	push	r24
    1242:	9f 93       	push	r25
    1244:	af 93       	push	r26
    1246:	bf 93       	push	r27
    1248:	cf 93       	push	r28
    124a:	df 93       	push	r29
    124c:	ef 93       	push	r30
    124e:	ff 93       	push	r31
    1250:	a0 91 f7 06 	lds	r26, 0x06F7
    1254:	b0 91 f8 06 	lds	r27, 0x06F8
    1258:	0d b6       	in	r0, 0x3d	; 61
    125a:	0d 92       	st	X+, r0
    125c:	0e b6       	in	r0, 0x3e	; 62
    125e:	0d 92       	st	X+, r0
	if( xTaskIncrementTick() != pdFALSE )
    1260:	0e 94 ae 15 	call	0x2b5c	; 0x2b5c <xTaskIncrementTick>
    1264:	88 23       	and	r24, r24
    1266:	11 f0       	breq	.+4      	; 0x126c <vPortYieldFromTick+0x64>
	{
		vTaskSwitchContext();
    1268:	0e 94 c6 16 	call	0x2d8c	; 0x2d8c <vTaskSwitchContext>
	}
	portRESTORE_CONTEXT();
    126c:	a0 91 f7 06 	lds	r26, 0x06F7
    1270:	b0 91 f8 06 	lds	r27, 0x06F8
    1274:	cd 91       	ld	r28, X+
    1276:	cd bf       	out	0x3d, r28	; 61
    1278:	dd 91       	ld	r29, X+
    127a:	de bf       	out	0x3e, r29	; 62
    127c:	ff 91       	pop	r31
    127e:	ef 91       	pop	r30
    1280:	df 91       	pop	r29
    1282:	cf 91       	pop	r28
    1284:	bf 91       	pop	r27
    1286:	af 91       	pop	r26
    1288:	9f 91       	pop	r25
    128a:	8f 91       	pop	r24
    128c:	7f 91       	pop	r23
    128e:	6f 91       	pop	r22
    1290:	5f 91       	pop	r21
    1292:	4f 91       	pop	r20
    1294:	3f 91       	pop	r19
    1296:	2f 91       	pop	r18
    1298:	1f 91       	pop	r17
    129a:	0f 91       	pop	r16
    129c:	ff 90       	pop	r15
    129e:	ef 90       	pop	r14
    12a0:	df 90       	pop	r13
    12a2:	cf 90       	pop	r12
    12a4:	bf 90       	pop	r11
    12a6:	af 90       	pop	r10
    12a8:	9f 90       	pop	r9
    12aa:	8f 90       	pop	r8
    12ac:	7f 90       	pop	r7
    12ae:	6f 90       	pop	r6
    12b0:	5f 90       	pop	r5
    12b2:	4f 90       	pop	r4
    12b4:	3f 90       	pop	r3
    12b6:	2f 90       	pop	r2
    12b8:	1f 90       	pop	r1
    12ba:	0f 90       	pop	r0
    12bc:	0f be       	out	0x3f, r0	; 63
    12be:	0f 90       	pop	r0

	asm volatile ( "ret" );
    12c0:	08 95       	ret

000012c2 <__vector_7>:
	 * count is incremented after the context is saved.
	 */
	void TIMER1_COMPA_vect( void ) __attribute__ ( ( signal, naked ) );
	void TIMER1_COMPA_vect( void )
	{
		vPortYieldFromTick();
    12c2:	0e 94 04 09 	call	0x1208	; 0x1208 <vPortYieldFromTick>
		asm volatile ( "reti" );
    12c6:	18 95       	reti

000012c8 <vPortYield>:
 * can use a naked attribute.
 */
void vPortYield( void ) __attribute__ ( ( naked ) );
void vPortYield( void )
{
	portSAVE_CONTEXT();
    12c8:	0f 92       	push	r0
    12ca:	0f b6       	in	r0, 0x3f	; 63
    12cc:	f8 94       	cli
    12ce:	0f 92       	push	r0
    12d0:	1f 92       	push	r1
    12d2:	11 24       	eor	r1, r1
    12d4:	2f 92       	push	r2
    12d6:	3f 92       	push	r3
    12d8:	4f 92       	push	r4
    12da:	5f 92       	push	r5
    12dc:	6f 92       	push	r6
    12de:	7f 92       	push	r7
    12e0:	8f 92       	push	r8
    12e2:	9f 92       	push	r9
    12e4:	af 92       	push	r10
    12e6:	bf 92       	push	r11
    12e8:	cf 92       	push	r12
    12ea:	df 92       	push	r13
    12ec:	ef 92       	push	r14
    12ee:	ff 92       	push	r15
    12f0:	0f 93       	push	r16
    12f2:	1f 93       	push	r17
    12f4:	2f 93       	push	r18
    12f6:	3f 93       	push	r19
    12f8:	4f 93       	push	r20
    12fa:	5f 93       	push	r21
    12fc:	6f 93       	push	r22
    12fe:	7f 93       	push	r23
    1300:	8f 93       	push	r24
    1302:	9f 93       	push	r25
    1304:	af 93       	push	r26
    1306:	bf 93       	push	r27
    1308:	cf 93       	push	r28
    130a:	df 93       	push	r29
    130c:	ef 93       	push	r30
    130e:	ff 93       	push	r31
    1310:	a0 91 f7 06 	lds	r26, 0x06F7
    1314:	b0 91 f8 06 	lds	r27, 0x06F8
    1318:	0d b6       	in	r0, 0x3d	; 61
    131a:	0d 92       	st	X+, r0
    131c:	0e b6       	in	r0, 0x3e	; 62
    131e:	0d 92       	st	X+, r0
	vTaskSwitchContext();
    1320:	0e 94 c6 16 	call	0x2d8c	; 0x2d8c <vTaskSwitchContext>
	portRESTORE_CONTEXT();
    1324:	a0 91 f7 06 	lds	r26, 0x06F7
    1328:	b0 91 f8 06 	lds	r27, 0x06F8
    132c:	cd 91       	ld	r28, X+
    132e:	cd bf       	out	0x3d, r28	; 61
    1330:	dd 91       	ld	r29, X+
    1332:	de bf       	out	0x3e, r29	; 62
    1334:	ff 91       	pop	r31
    1336:	ef 91       	pop	r30
    1338:	df 91       	pop	r29
    133a:	cf 91       	pop	r28
    133c:	bf 91       	pop	r27
    133e:	af 91       	pop	r26
    1340:	9f 91       	pop	r25
    1342:	8f 91       	pop	r24
    1344:	7f 91       	pop	r23
    1346:	6f 91       	pop	r22
    1348:	5f 91       	pop	r21
    134a:	4f 91       	pop	r20
    134c:	3f 91       	pop	r19
    134e:	2f 91       	pop	r18
    1350:	1f 91       	pop	r17
    1352:	0f 91       	pop	r16
    1354:	ff 90       	pop	r15
    1356:	ef 90       	pop	r14
    1358:	df 90       	pop	r13
    135a:	cf 90       	pop	r12
    135c:	bf 90       	pop	r11
    135e:	af 90       	pop	r10
    1360:	9f 90       	pop	r9
    1362:	8f 90       	pop	r8
    1364:	7f 90       	pop	r7
    1366:	6f 90       	pop	r6
    1368:	5f 90       	pop	r5
    136a:	4f 90       	pop	r4
    136c:	3f 90       	pop	r3
    136e:	2f 90       	pop	r2
    1370:	1f 90       	pop	r1
    1372:	0f 90       	pop	r0
    1374:	0f be       	out	0x3f, r0	; 63
    1376:	0f 90       	pop	r0

	asm volatile ( "ret" );
    1378:	08 95       	ret

0000137a <uxQueueMessagesWaiting>:
    return xReturn;
}
/*-----------------------------------------------------------*/

UBaseType_t uxQueueMessagesWaiting( const QueueHandle_t xQueue )
{
    137a:	fc 01       	movw	r30, r24
    UBaseType_t uxReturn;

    configASSERT( xQueue );

    taskENTER_CRITICAL();
    137c:	0f b6       	in	r0, 0x3f	; 63
    137e:	f8 94       	cli
    1380:	0f 92       	push	r0
    {
        uxReturn = ( ( Queue_t * ) xQueue )->uxMessagesWaiting;
    1382:	82 8d       	ldd	r24, Z+26	; 0x1a
    }
    taskEXIT_CRITICAL();
    1384:	0f 90       	pop	r0
    1386:	0f be       	out	0x3f, r0	; 63

    return uxReturn;
} /*lint !e818 Pointer cannot be declared const as xQueue is a typedef not pointer. */
    1388:	08 95       	ret

0000138a <uxQueueSpacesAvailable>:
/*-----------------------------------------------------------*/

UBaseType_t uxQueueSpacesAvailable( const QueueHandle_t xQueue )
{
    138a:	fc 01       	movw	r30, r24
    UBaseType_t uxReturn;
    Queue_t * const pxQueue = xQueue;

    configASSERT( pxQueue );

    taskENTER_CRITICAL();
    138c:	0f b6       	in	r0, 0x3f	; 63
    138e:	f8 94       	cli
    1390:	0f 92       	push	r0
    {
        uxReturn = pxQueue->uxLength - pxQueue->uxMessagesWaiting;
    1392:	92 8d       	ldd	r25, Z+26	; 0x1a
    }
    taskEXIT_CRITICAL();
    1394:	0f 90       	pop	r0
    1396:	0f be       	out	0x3f, r0	; 63
    1398:	83 8d       	ldd	r24, Z+27	; 0x1b

    return uxReturn;
} /*lint !e818 Pointer cannot be declared const as xQueue is a typedef not pointer. */
    139a:	89 1b       	sub	r24, r25
    139c:	08 95       	ret

0000139e <uxQueueMessagesWaitingFromISR>:
/*-----------------------------------------------------------*/

UBaseType_t uxQueueMessagesWaitingFromISR( const QueueHandle_t xQueue )
{
    139e:	fc 01       	movw	r30, r24
    UBaseType_t uxReturn;
    Queue_t * const pxQueue = xQueue;

    configASSERT( pxQueue );
    uxReturn = pxQueue->uxMessagesWaiting;
    13a0:	82 8d       	ldd	r24, Z+26	; 0x1a

    return uxReturn;
} /*lint !e818 Pointer cannot be declared const as xQueue is a typedef not pointer. */
    13a2:	08 95       	ret

000013a4 <xQueueIsQueueEmptyFromISR>:
    return xReturn;
}
/*-----------------------------------------------------------*/

BaseType_t xQueueIsQueueEmptyFromISR( const QueueHandle_t xQueue )
{
    13a4:	fc 01       	movw	r30, r24
    BaseType_t xReturn;
    Queue_t * const pxQueue = xQueue;

    configASSERT( pxQueue );

    if( pxQueue->uxMessagesWaiting == ( UBaseType_t ) 0 )
    13a6:	82 8d       	ldd	r24, Z+26	; 0x1a
    13a8:	90 e0       	ldi	r25, 0x00	; 0
    13aa:	88 23       	and	r24, r24
    13ac:	09 f4       	brne	.+2      	; 0x13b0 <xQueueIsQueueEmptyFromISR+0xc>
    13ae:	91 e0       	ldi	r25, 0x01	; 1
    {
        xReturn = pdFALSE;
    }

    return xReturn;
} /*lint !e818 xQueue could not be pointer to const because it is a typedef. */
    13b0:	89 2f       	mov	r24, r25
    13b2:	08 95       	ret

000013b4 <xQueueIsQueueFullFromISR>:
    return xReturn;
}
/*-----------------------------------------------------------*/

BaseType_t xQueueIsQueueFullFromISR( const QueueHandle_t xQueue )
{
    13b4:	fc 01       	movw	r30, r24
    BaseType_t xReturn;
    Queue_t * const pxQueue = xQueue;

    configASSERT( pxQueue );

    if( pxQueue->uxMessagesWaiting == pxQueue->uxLength )
    13b6:	92 8d       	ldd	r25, Z+26	; 0x1a
    13b8:	20 e0       	ldi	r18, 0x00	; 0
    13ba:	83 8d       	ldd	r24, Z+27	; 0x1b
    13bc:	98 17       	cp	r25, r24
    13be:	09 f4       	brne	.+2      	; 0x13c2 <xQueueIsQueueFullFromISR+0xe>
    13c0:	21 e0       	ldi	r18, 0x01	; 1
    {
        xReturn = pdFALSE;
    }

    return xReturn;
} /*lint !e818 xQueue could not be pointer to const because it is a typedef. */
    13c2:	82 2f       	mov	r24, r18
    13c4:	08 95       	ret

000013c6 <xQueueAddToSet>:

#if ( configUSE_QUEUE_SETS == 1 )

    BaseType_t xQueueAddToSet( QueueSetMemberHandle_t xQueueOrSemaphore,
                               QueueSetHandle_t xQueueSet )
    {
    13c6:	fc 01       	movw	r30, r24
        BaseType_t xReturn;

        taskENTER_CRITICAL();
    13c8:	0f b6       	in	r0, 0x3f	; 63
    13ca:	f8 94       	cli
    13cc:	0f 92       	push	r0
        {
            if( ( ( Queue_t * ) xQueueOrSemaphore )->pxQueueSetContainer != NULL )
    13ce:	87 8d       	ldd	r24, Z+31	; 0x1f
    13d0:	90 a1       	ldd	r25, Z+32	; 0x20
    13d2:	89 2b       	or	r24, r25
    13d4:	39 f4       	brne	.+14     	; 0x13e4 <xQueueAddToSet+0x1e>
            {
                /* Cannot add a queue/semaphore to more than one queue set. */
                xReturn = pdFAIL;
            }
            else if( ( ( Queue_t * ) xQueueOrSemaphore )->uxMessagesWaiting != ( UBaseType_t ) 0 )
    13d6:	82 8d       	ldd	r24, Z+26	; 0x1a
    13d8:	88 23       	and	r24, r24
    13da:	21 f4       	brne	.+8      	; 0x13e4 <xQueueAddToSet+0x1e>
                 * items in the queue/semaphore. */
                xReturn = pdFAIL;
            }
            else
            {
                ( ( Queue_t * ) xQueueOrSemaphore )->pxQueueSetContainer = xQueueSet;
    13dc:	70 a3       	std	Z+32, r23	; 0x20
    13de:	67 8f       	std	Z+31, r22	; 0x1f
    13e0:	81 e0       	ldi	r24, 0x01	; 1
    13e2:	01 c0       	rjmp	.+2      	; 0x13e6 <xQueueAddToSet+0x20>
    13e4:	80 e0       	ldi	r24, 0x00	; 0
                xReturn = pdPASS;
            }
        }
        taskEXIT_CRITICAL();
    13e6:	0f 90       	pop	r0
    13e8:	0f be       	out	0x3f, r0	; 63

        return xReturn;
    }
    13ea:	08 95       	ret

000013ec <xQueueRemoveFromSet>:

#if ( configUSE_QUEUE_SETS == 1 )

    BaseType_t xQueueRemoveFromSet( QueueSetMemberHandle_t xQueueOrSemaphore,
                                    QueueSetHandle_t xQueueSet )
    {
    13ec:	fc 01       	movw	r30, r24
        BaseType_t xReturn;
        Queue_t * const pxQueueOrSemaphore = ( Queue_t * ) xQueueOrSemaphore;

        if( pxQueueOrSemaphore->pxQueueSetContainer != xQueueSet )
    13ee:	87 8d       	ldd	r24, Z+31	; 0x1f
    13f0:	90 a1       	ldd	r25, Z+32	; 0x20
    13f2:	86 17       	cp	r24, r22
    13f4:	97 07       	cpc	r25, r23
    13f6:	61 f4       	brne	.+24     	; 0x1410 <xQueueRemoveFromSet+0x24>
        {
            /* The queue was not a member of the set. */
            xReturn = pdFAIL;
        }
        else if( pxQueueOrSemaphore->uxMessagesWaiting != ( UBaseType_t ) 0 )
    13f8:	82 8d       	ldd	r24, Z+26	; 0x1a
    13fa:	88 23       	and	r24, r24
    13fc:	49 f4       	brne	.+18     	; 0x1410 <xQueueRemoveFromSet+0x24>
             * the queue. */
            xReturn = pdFAIL;
        }
        else
        {
            taskENTER_CRITICAL();
    13fe:	0f b6       	in	r0, 0x3f	; 63
    1400:	f8 94       	cli
    1402:	0f 92       	push	r0
            {
                /* The queue is no longer contained in the set. */
                pxQueueOrSemaphore->pxQueueSetContainer = NULL;
    1404:	10 a2       	std	Z+32, r1	; 0x20
    1406:	17 8e       	std	Z+31, r1	; 0x1f
            }
            taskEXIT_CRITICAL();
    1408:	0f 90       	pop	r0
    140a:	0f be       	out	0x3f, r0	; 63
    140c:	81 e0       	ldi	r24, 0x01	; 1
    140e:	08 95       	ret
    1410:	80 e0       	ldi	r24, 0x00	; 0
            xReturn = pdPASS;
        }

        return xReturn;
    } /*lint !e818 xQueueSet could not be declared as pointing to const as it is a typedef. */
    1412:	08 95       	ret

00001414 <vQueueDelete>:

    #if ( ( configSUPPORT_DYNAMIC_ALLOCATION == 1 ) && ( configSUPPORT_STATIC_ALLOCATION == 0 ) )
    {
        /* The queue can only have been allocated dynamically - free it
         * again. */
        vPortFree( pxQueue );
    1414:	0e 94 b2 07 	call	0xf64	; 0xf64 <vPortFree>
        /* The queue must have been statically allocated, so is not going to be
         * deleted.  Avoid compiler warnings about the unused parameter. */
        ( void ) pxQueue;
    }
    #endif /* configSUPPORT_DYNAMIC_ALLOCATION */
}
    1418:	08 95       	ret

0000141a <prvCopyDataFromQueue>:
}
/*-----------------------------------------------------------*/

static void prvCopyDataFromQueue( Queue_t * const pxQueue,
                                  void * const pvBuffer )
{
    141a:	fc 01       	movw	r30, r24
    141c:	56 2f       	mov	r21, r22
    141e:	a7 2f       	mov	r26, r23
    if( pxQueue->uxItemSize != ( UBaseType_t ) 0 )
    1420:	24 8d       	ldd	r18, Z+28	; 0x1c
    1422:	22 23       	and	r18, r18
    1424:	b9 f0       	breq	.+46     	; 0x1454 <prvCopyDataFromQueue+0x3a>
    {
        pxQueue->u.xQueue.pcReadFrom += pxQueue->uxItemSize;           /*lint !e9016 Pointer arithmetic on char types ok, especially in this use case where it is the clearest way of conveying intent. */
    1426:	86 81       	ldd	r24, Z+6	; 0x06
    1428:	97 81       	ldd	r25, Z+7	; 0x07
    142a:	82 0f       	add	r24, r18
    142c:	91 1d       	adc	r25, r1
    142e:	97 83       	std	Z+7, r25	; 0x07
    1430:	86 83       	std	Z+6, r24	; 0x06

        if( pxQueue->u.xQueue.pcReadFrom >= pxQueue->u.xQueue.pcTail ) /*lint !e946 MISRA exception justified as use of the relational operator is the cleanest solutions. */
    1432:	24 81       	ldd	r18, Z+4	; 0x04
    1434:	35 81       	ldd	r19, Z+5	; 0x05
    1436:	82 17       	cp	r24, r18
    1438:	93 07       	cpc	r25, r19
    143a:	20 f0       	brcs	.+8      	; 0x1444 <prvCopyDataFromQueue+0x2a>
        {
            pxQueue->u.xQueue.pcReadFrom = pxQueue->pcHead;
    143c:	80 81       	ld	r24, Z
    143e:	91 81       	ldd	r25, Z+1	; 0x01
    1440:	97 83       	std	Z+7, r25	; 0x07
    1442:	86 83       	std	Z+6, r24	; 0x06
        else
        {
            mtCOVERAGE_TEST_MARKER();
        }

        ( void ) memcpy( ( void * ) pvBuffer, ( void * ) pxQueue->u.xQueue.pcReadFrom, ( size_t ) pxQueue->uxItemSize ); /*lint !e961 !e418 !e9087 MISRA exception as the casts are only redundant for some ports.  Also previous logic ensures a null pointer can only be passed to memcpy() when the count is 0.  Cast to void required by function signature and safe as no alignment requirement and copy length specified in bytes. */
    1444:	44 8d       	ldd	r20, Z+28	; 0x1c
    1446:	66 81       	ldd	r22, Z+6	; 0x06
    1448:	77 81       	ldd	r23, Z+7	; 0x07
    144a:	85 2f       	mov	r24, r21
    144c:	9a 2f       	mov	r25, r26
    144e:	50 e0       	ldi	r21, 0x00	; 0
    1450:	0e 94 55 26 	call	0x4caa	; 0x4caa <memcpy>
    1454:	08 95       	ret

00001456 <xQueuePeekFromISR>:
}
/*-----------------------------------------------------------*/

BaseType_t xQueuePeekFromISR( QueueHandle_t xQueue,
                              void * const pvBuffer )
{
    1456:	0f 93       	push	r16
    1458:	1f 93       	push	r17
    145a:	cf 93       	push	r28
    145c:	df 93       	push	r29
    145e:	ec 01       	movw	r28, r24
    portASSERT_IF_INTERRUPT_PRIORITY_INVALID();

    uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
    {
        /* Cannot block in an ISR, so check there is data available. */
        if( pxQueue->uxMessagesWaiting > ( UBaseType_t ) 0 )
    1460:	8a 8d       	ldd	r24, Y+26	; 0x1a
    1462:	88 23       	and	r24, r24
    1464:	41 f0       	breq	.+16     	; 0x1476 <xQueuePeekFromISR+0x20>
        {
            traceQUEUE_PEEK_FROM_ISR( pxQueue );

            /* Remember the read position so it can be reset as nothing is
             * actually being removed from the queue. */
            pcOriginalReadPosition = pxQueue->u.xQueue.pcReadFrom;
    1466:	0e 81       	ldd	r16, Y+6	; 0x06
    1468:	1f 81       	ldd	r17, Y+7	; 0x07
            prvCopyDataFromQueue( pxQueue, pvBuffer );
    146a:	ce 01       	movw	r24, r28
    146c:	0e 94 0d 0a 	call	0x141a	; 0x141a <prvCopyDataFromQueue>
            pxQueue->u.xQueue.pcReadFrom = pcOriginalReadPosition;
    1470:	1f 83       	std	Y+7, r17	; 0x07
    1472:	0e 83       	std	Y+6, r16	; 0x06
    1474:	81 e0       	ldi	r24, 0x01	; 1
        }
    }
    portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

    return xReturn;
}
    1476:	df 91       	pop	r29
    1478:	cf 91       	pop	r28
    147a:	1f 91       	pop	r17
    147c:	0f 91       	pop	r16
    147e:	08 95       	ret

00001480 <xQueueReceiveFromISR>:
/*-----------------------------------------------------------*/

BaseType_t xQueueReceiveFromISR( QueueHandle_t xQueue,
                                 void * const pvBuffer,
                                 BaseType_t * const pxHigherPriorityTaskWoken )
{
    1480:	ef 92       	push	r14
    1482:	ff 92       	push	r15
    1484:	0f 93       	push	r16
    1486:	1f 93       	push	r17
    1488:	cf 93       	push	r28
    148a:	df 93       	push	r29
    148c:	ec 01       	movw	r28, r24
    148e:	7a 01       	movw	r14, r20
     * link: https://www.FreeRTOS.org/RTOS-Cortex-M3-M4.html */
    portASSERT_IF_INTERRUPT_PRIORITY_INVALID();

    uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
    {
        const UBaseType_t uxMessagesWaiting = pxQueue->uxMessagesWaiting;
    1490:	1a 8d       	ldd	r17, Y+26	; 0x1a

        /* Cannot block in an ISR, so check there is data available. */
        if( uxMessagesWaiting > ( UBaseType_t ) 0 )
    1492:	11 23       	and	r17, r17
    1494:	11 f4       	brne	.+4      	; 0x149a <xQueueReceiveFromISR+0x1a>
    1496:	80 e0       	ldi	r24, 0x00	; 0
    1498:	1e c0       	rjmp	.+60     	; 0x14d6 <xQueueReceiveFromISR+0x56>
        {
            const int8_t cRxLock = pxQueue->cRxLock;
    149a:	0d 8d       	ldd	r16, Y+29	; 0x1d

            traceQUEUE_RECEIVE_FROM_ISR( pxQueue );

            prvCopyDataFromQueue( pxQueue, pvBuffer );
    149c:	0e 94 0d 0a 	call	0x141a	; 0x141a <prvCopyDataFromQueue>
            pxQueue->uxMessagesWaiting = uxMessagesWaiting - ( UBaseType_t ) 1;
    14a0:	11 50       	subi	r17, 0x01	; 1
    14a2:	1a 8f       	std	Y+26, r17	; 0x1a

            /* If the queue is locked the event list will not be modified.
             * Instead update the lock count so the task that unlocks the queue
             * will know that an ISR has removed data while the queue was
             * locked. */
            if( cRxLock == queueUNLOCKED )
    14a4:	0f 3f       	cpi	r16, 0xFF	; 255
    14a6:	81 f4       	brne	.+32     	; 0x14c8 <xQueueReceiveFromISR+0x48>
            {
                if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    14a8:	88 85       	ldd	r24, Y+8	; 0x08
    14aa:	88 23       	and	r24, r24
    14ac:	99 f0       	breq	.+38     	; 0x14d4 <xQueueReceiveFromISR+0x54>
                {
                    if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
    14ae:	ce 01       	movw	r24, r28
    14b0:	08 96       	adiw	r24, 0x08	; 8
    14b2:	0e 94 00 17 	call	0x2e00	; 0x2e00 <xTaskRemoveFromEventList>
    14b6:	88 23       	and	r24, r24
    14b8:	69 f0       	breq	.+26     	; 0x14d4 <xQueueReceiveFromISR+0x54>
                    {
                        /* The task waiting has a higher priority than us so
                         * force a context switch. */
                        if( pxHigherPriorityTaskWoken != NULL )
    14ba:	e1 14       	cp	r14, r1
    14bc:	f1 04       	cpc	r15, r1
    14be:	51 f0       	breq	.+20     	; 0x14d4 <xQueueReceiveFromISR+0x54>
                        {
                            *pxHigherPriorityTaskWoken = pdTRUE;
    14c0:	81 e0       	ldi	r24, 0x01	; 1
    14c2:	f7 01       	movw	r30, r14
    14c4:	80 83       	st	Z, r24
    14c6:	07 c0       	rjmp	.+14     	; 0x14d6 <xQueueReceiveFromISR+0x56>
            }
            else
            {
                /* Increment the lock count so the task that unlocks the queue
                 * knows that data was removed while it was locked. */
                prvIncrementQueueRxLock( pxQueue, cRxLock );
    14c8:	0e 94 a0 15 	call	0x2b40	; 0x2b40 <uxTaskGetNumberOfTasks>
    14cc:	08 17       	cp	r16, r24
    14ce:	10 f4       	brcc	.+4      	; 0x14d4 <xQueueReceiveFromISR+0x54>
    14d0:	0f 5f       	subi	r16, 0xFF	; 255
    14d2:	0d 8f       	std	Y+29, r16	; 0x1d
    14d4:	81 e0       	ldi	r24, 0x01	; 1
        }
    }
    portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

    return xReturn;
}
    14d6:	df 91       	pop	r29
    14d8:	cf 91       	pop	r28
    14da:	1f 91       	pop	r17
    14dc:	0f 91       	pop	r16
    14de:	ff 90       	pop	r15
    14e0:	ef 90       	pop	r14
    14e2:	08 95       	ret

000014e4 <xQueueSelectFromSetFromISR>:
/*-----------------------------------------------------------*/

#if ( configUSE_QUEUE_SETS == 1 )

    QueueSetMemberHandle_t xQueueSelectFromSetFromISR( QueueSetHandle_t xQueueSet )
    {
    14e4:	df 93       	push	r29
    14e6:	cf 93       	push	r28
    14e8:	00 d0       	rcall	.+0      	; 0x14ea <xQueueSelectFromSetFromISR+0x6>
    14ea:	cd b7       	in	r28, 0x3d	; 61
    14ec:	de b7       	in	r29, 0x3e	; 62
        QueueSetMemberHandle_t xReturn = NULL;
    14ee:	1a 82       	std	Y+2, r1	; 0x02
    14f0:	19 82       	std	Y+1, r1	; 0x01

        ( void ) xQueueReceiveFromISR( ( QueueHandle_t ) xQueueSet, &xReturn, NULL ); /*lint !e961 Casting from one typedef to another is not redundant. */
    14f2:	be 01       	movw	r22, r28
    14f4:	6f 5f       	subi	r22, 0xFF	; 255
    14f6:	7f 4f       	sbci	r23, 0xFF	; 255
    14f8:	40 e0       	ldi	r20, 0x00	; 0
    14fa:	50 e0       	ldi	r21, 0x00	; 0
    14fc:	0e 94 40 0a 	call	0x1480	; 0x1480 <xQueueReceiveFromISR>
        return xReturn;
    }
    1500:	89 81       	ldd	r24, Y+1	; 0x01
    1502:	9a 81       	ldd	r25, Y+2	; 0x02
    1504:	0f 90       	pop	r0
    1506:	0f 90       	pop	r0
    1508:	cf 91       	pop	r28
    150a:	df 91       	pop	r29
    150c:	08 95       	ret

0000150e <prvCopyDataToQueue>:
/*-----------------------------------------------------------*/

static BaseType_t prvCopyDataToQueue( Queue_t * const pxQueue,
                                      const void * pvItemToQueue,
                                      const BaseType_t xPosition )
{
    150e:	0f 93       	push	r16
    1510:	1f 93       	push	r17
    1512:	cf 93       	push	r28
    1514:	df 93       	push	r29
    1516:	ec 01       	movw	r28, r24
    1518:	04 2f       	mov	r16, r20
    BaseType_t xReturn = pdFALSE;
    UBaseType_t uxMessagesWaiting;

    /* This function is called from a critical section. */

    uxMessagesWaiting = pxQueue->uxMessagesWaiting;
    151a:	1a 8d       	ldd	r17, Y+26	; 0x1a

    if( pxQueue->uxItemSize == ( UBaseType_t ) 0 )
    151c:	4c 8d       	ldd	r20, Y+28	; 0x1c
    151e:	44 23       	and	r20, r20
    1520:	61 f4       	brne	.+24     	; 0x153a <prvCopyDataToQueue+0x2c>
    {
        #if ( configUSE_MUTEXES == 1 )
        {
            if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
    1522:	88 81       	ld	r24, Y
    1524:	99 81       	ldd	r25, Y+1	; 0x01
    1526:	89 2b       	or	r24, r25
    1528:	09 f0       	breq	.+2      	; 0x152c <prvCopyDataToQueue+0x1e>
    152a:	3f c0       	rjmp	.+126    	; 0x15aa <prvCopyDataToQueue+0x9c>
            {
                /* The mutex is no longer being held. */
                xReturn = xTaskPriorityDisinherit( pxQueue->u.xSemaphore.xMutexHolder );
    152c:	8c 81       	ldd	r24, Y+4	; 0x04
    152e:	9d 81       	ldd	r25, Y+5	; 0x05
    1530:	0e 94 f8 1c 	call	0x39f0	; 0x39f0 <xTaskPriorityDisinherit>
                pxQueue->u.xSemaphore.xMutexHolder = NULL;
    1534:	1d 82       	std	Y+5, r1	; 0x05
    1536:	1c 82       	std	Y+4, r1	; 0x04
    1538:	39 c0       	rjmp	.+114    	; 0x15ac <prvCopyDataToQueue+0x9e>
                mtCOVERAGE_TEST_MARKER();
            }
        }
        #endif /* configUSE_MUTEXES */
    }
    else if( xPosition == queueSEND_TO_BACK )
    153a:	00 23       	and	r16, r16
    153c:	b1 f4       	brne	.+44     	; 0x156a <prvCopyDataToQueue+0x5c>
    {
        ( void ) memcpy( ( void * ) pxQueue->pcWriteTo, pvItemToQueue, ( size_t ) pxQueue->uxItemSize ); /*lint !e961 !e418 !e9087 MISRA exception as the casts are only redundant for some ports, plus previous logic ensures a null pointer can only be passed to memcpy() if the copy size is 0.  Cast to void required by function signature and safe as no alignment requirement and copy length specified in bytes. */
    153e:	8a 81       	ldd	r24, Y+2	; 0x02
    1540:	9b 81       	ldd	r25, Y+3	; 0x03
    1542:	50 e0       	ldi	r21, 0x00	; 0
    1544:	0e 94 55 26 	call	0x4caa	; 0x4caa <memcpy>
        pxQueue->pcWriteTo += pxQueue->uxItemSize;                                                       /*lint !e9016 Pointer arithmetic on char types ok, especially in this use case where it is the clearest way of conveying intent. */
    1548:	8c 8d       	ldd	r24, Y+28	; 0x1c
    154a:	2a 81       	ldd	r18, Y+2	; 0x02
    154c:	3b 81       	ldd	r19, Y+3	; 0x03
    154e:	28 0f       	add	r18, r24
    1550:	31 1d       	adc	r19, r1
    1552:	3b 83       	std	Y+3, r19	; 0x03
    1554:	2a 83       	std	Y+2, r18	; 0x02

        if( pxQueue->pcWriteTo >= pxQueue->u.xQueue.pcTail )                                             /*lint !e946 MISRA exception justified as comparison of pointers is the cleanest solution. */
    1556:	8c 81       	ldd	r24, Y+4	; 0x04
    1558:	9d 81       	ldd	r25, Y+5	; 0x05
    155a:	28 17       	cp	r18, r24
    155c:	39 07       	cpc	r19, r25
    155e:	28 f1       	brcs	.+74     	; 0x15aa <prvCopyDataToQueue+0x9c>
        {
            pxQueue->pcWriteTo = pxQueue->pcHead;
    1560:	88 81       	ld	r24, Y
    1562:	99 81       	ldd	r25, Y+1	; 0x01
    1564:	9b 83       	std	Y+3, r25	; 0x03
    1566:	8a 83       	std	Y+2, r24	; 0x02
    1568:	20 c0       	rjmp	.+64     	; 0x15aa <prvCopyDataToQueue+0x9c>
            mtCOVERAGE_TEST_MARKER();
        }
    }
    else
    {
        ( void ) memcpy( ( void * ) pxQueue->u.xQueue.pcReadFrom, pvItemToQueue, ( size_t ) pxQueue->uxItemSize ); /*lint !e961 !e9087 !e418 MISRA exception as the casts are only redundant for some ports.  Cast to void required by function signature and safe as no alignment requirement and copy length specified in bytes.  Assert checks null pointer only used when length is 0. */
    156a:	8e 81       	ldd	r24, Y+6	; 0x06
    156c:	9f 81       	ldd	r25, Y+7	; 0x07
    156e:	50 e0       	ldi	r21, 0x00	; 0
    1570:	0e 94 55 26 	call	0x4caa	; 0x4caa <memcpy>
        pxQueue->u.xQueue.pcReadFrom -= pxQueue->uxItemSize;
    1574:	8c 8d       	ldd	r24, Y+28	; 0x1c
    1576:	90 e0       	ldi	r25, 0x00	; 0
    1578:	44 27       	eor	r20, r20
    157a:	55 27       	eor	r21, r21
    157c:	48 1b       	sub	r20, r24
    157e:	59 0b       	sbc	r21, r25
    1580:	8e 81       	ldd	r24, Y+6	; 0x06
    1582:	9f 81       	ldd	r25, Y+7	; 0x07
    1584:	84 0f       	add	r24, r20
    1586:	95 1f       	adc	r25, r21
    1588:	9f 83       	std	Y+7, r25	; 0x07
    158a:	8e 83       	std	Y+6, r24	; 0x06

        if( pxQueue->u.xQueue.pcReadFrom < pxQueue->pcHead ) /*lint !e946 MISRA exception justified as comparison of pointers is the cleanest solution. */
    158c:	28 81       	ld	r18, Y
    158e:	39 81       	ldd	r19, Y+1	; 0x01
    1590:	82 17       	cp	r24, r18
    1592:	93 07       	cpc	r25, r19
    1594:	30 f4       	brcc	.+12     	; 0x15a2 <prvCopyDataToQueue+0x94>
        {
            pxQueue->u.xQueue.pcReadFrom = ( pxQueue->u.xQueue.pcTail - pxQueue->uxItemSize );
    1596:	8c 81       	ldd	r24, Y+4	; 0x04
    1598:	9d 81       	ldd	r25, Y+5	; 0x05
    159a:	84 0f       	add	r24, r20
    159c:	95 1f       	adc	r25, r21
    159e:	9f 83       	std	Y+7, r25	; 0x07
    15a0:	8e 83       	std	Y+6, r24	; 0x06
        else
        {
            mtCOVERAGE_TEST_MARKER();
        }

        if( xPosition == queueOVERWRITE )
    15a2:	02 30       	cpi	r16, 0x02	; 2
    15a4:	11 f4       	brne	.+4      	; 0x15aa <prvCopyDataToQueue+0x9c>
        {
            if( uxMessagesWaiting > ( UBaseType_t ) 0 )
    15a6:	11 11       	cpse	r17, r1
            {
                /* An item is not being added but overwritten, so subtract
                 * one from the recorded number of items in the queue so when
                 * one is added again below the number of recorded items remains
                 * correct. */
                --uxMessagesWaiting;
    15a8:	11 50       	subi	r17, 0x01	; 1
    15aa:	80 e0       	ldi	r24, 0x00	; 0
        {
            mtCOVERAGE_TEST_MARKER();
        }
    }

    pxQueue->uxMessagesWaiting = uxMessagesWaiting + ( UBaseType_t ) 1;
    15ac:	1f 5f       	subi	r17, 0xFF	; 255
    15ae:	1a 8f       	std	Y+26, r17	; 0x1a

    return xReturn;
}
    15b0:	df 91       	pop	r29
    15b2:	cf 91       	pop	r28
    15b4:	1f 91       	pop	r17
    15b6:	0f 91       	pop	r16
    15b8:	08 95       	ret

000015ba <prvNotifyQueueSetContainer>:
/*-----------------------------------------------------------*/

#if ( configUSE_QUEUE_SETS == 1 )

    static BaseType_t prvNotifyQueueSetContainer( const Queue_t * const pxQueue )
    {
    15ba:	ef 92       	push	r14
    15bc:	ff 92       	push	r15
    15be:	0f 93       	push	r16
    15c0:	1f 93       	push	r17
    15c2:	df 93       	push	r29
    15c4:	cf 93       	push	r28
    15c6:	00 d0       	rcall	.+0      	; 0x15c8 <prvNotifyQueueSetContainer+0xe>
    15c8:	cd b7       	in	r28, 0x3d	; 61
    15ca:	de b7       	in	r29, 0x3e	; 62
    15cc:	9a 83       	std	Y+2, r25	; 0x02
    15ce:	89 83       	std	Y+1, r24	; 0x01
        Queue_t * pxQueueSetContainer = pxQueue->pxQueueSetContainer;
    15d0:	fc 01       	movw	r30, r24
    15d2:	07 8d       	ldd	r16, Z+31	; 0x1f
    15d4:	10 a1       	ldd	r17, Z+32	; 0x20
         * to prvNotifyQueueSetContainer is preceded by a check that
         * pxQueueSetContainer != NULL */
        configASSERT( pxQueueSetContainer ); /* LCOV_EXCL_BR_LINE */
        configASSERT( pxQueueSetContainer->uxMessagesWaiting < pxQueueSetContainer->uxLength );

        if( pxQueueSetContainer->uxMessagesWaiting < pxQueueSetContainer->uxLength )
    15d6:	f8 01       	movw	r30, r16
    15d8:	92 8d       	ldd	r25, Z+26	; 0x1a
    15da:	83 8d       	ldd	r24, Z+27	; 0x1b
    15dc:	98 17       	cp	r25, r24
    15de:	10 f0       	brcs	.+4      	; 0x15e4 <prvNotifyQueueSetContainer+0x2a>
    15e0:	ee 24       	eor	r14, r14
    15e2:	21 c0       	rjmp	.+66     	; 0x1626 <prvNotifyQueueSetContainer+0x6c>
        {
            const int8_t cTxLock = pxQueueSetContainer->cTxLock;
    15e4:	f8 01       	movw	r30, r16
    15e6:	f6 8c       	ldd	r15, Z+30	; 0x1e

            traceQUEUE_SET_SEND( pxQueueSetContainer );

            /* The data copied is the handle of the queue that contains data. */
            xReturn = prvCopyDataToQueue( pxQueueSetContainer, &pxQueue, queueSEND_TO_BACK );
    15e8:	c8 01       	movw	r24, r16
    15ea:	be 01       	movw	r22, r28
    15ec:	6f 5f       	subi	r22, 0xFF	; 255
    15ee:	7f 4f       	sbci	r23, 0xFF	; 255
    15f0:	40 e0       	ldi	r20, 0x00	; 0
    15f2:	0e 94 87 0a 	call	0x150e	; 0x150e <prvCopyDataToQueue>
    15f6:	e8 2e       	mov	r14, r24

            if( cTxLock == queueUNLOCKED )
    15f8:	ff ef       	ldi	r31, 0xFF	; 255
    15fa:	ff 16       	cp	r15, r31
    15fc:	69 f4       	brne	.+26     	; 0x1618 <prvNotifyQueueSetContainer+0x5e>
            {
                if( listLIST_IS_EMPTY( &( pxQueueSetContainer->xTasksWaitingToReceive ) ) == pdFALSE )
    15fe:	f8 01       	movw	r30, r16
    1600:	81 89       	ldd	r24, Z+17	; 0x11
    1602:	88 23       	and	r24, r24
    1604:	81 f0       	breq	.+32     	; 0x1626 <prvNotifyQueueSetContainer+0x6c>
                {
                    if( xTaskRemoveFromEventList( &( pxQueueSetContainer->xTasksWaitingToReceive ) ) != pdFALSE )
    1606:	c8 01       	movw	r24, r16
    1608:	41 96       	adiw	r24, 0x11	; 17
    160a:	0e 94 00 17 	call	0x2e00	; 0x2e00 <xTaskRemoveFromEventList>
    160e:	88 23       	and	r24, r24
    1610:	51 f0       	breq	.+20     	; 0x1626 <prvNotifyQueueSetContainer+0x6c>
    1612:	ee 24       	eor	r14, r14
    1614:	e3 94       	inc	r14
    1616:	07 c0       	rjmp	.+14     	; 0x1626 <prvNotifyQueueSetContainer+0x6c>
                    mtCOVERAGE_TEST_MARKER();
                }
            }
            else
            {
                prvIncrementQueueTxLock( pxQueueSetContainer, cTxLock );
    1618:	0e 94 a0 15 	call	0x2b40	; 0x2b40 <uxTaskGetNumberOfTasks>
    161c:	f8 16       	cp	r15, r24
    161e:	18 f4       	brcc	.+6      	; 0x1626 <prvNotifyQueueSetContainer+0x6c>
    1620:	f3 94       	inc	r15
    1622:	f8 01       	movw	r30, r16
    1624:	f6 8e       	std	Z+30, r15	; 0x1e
        {
            mtCOVERAGE_TEST_MARKER();
        }

        return xReturn;
    }
    1626:	8e 2d       	mov	r24, r14
    1628:	0f 90       	pop	r0
    162a:	0f 90       	pop	r0
    162c:	cf 91       	pop	r28
    162e:	df 91       	pop	r29
    1630:	1f 91       	pop	r17
    1632:	0f 91       	pop	r16
    1634:	ff 90       	pop	r15
    1636:	ef 90       	pop	r14
    1638:	08 95       	ret

0000163a <prvUnlockQueue>:
    }
}
/*-----------------------------------------------------------*/

static void prvUnlockQueue( Queue_t * const pxQueue )
{
    163a:	ef 92       	push	r14
    163c:	ff 92       	push	r15
    163e:	1f 93       	push	r17
    1640:	cf 93       	push	r28
    1642:	df 93       	push	r29
    1644:	ec 01       	movw	r28, r24

    /* The lock counts contains the number of extra data items placed or
     * removed from the queue while the queue was locked.  When a queue is
     * locked items can be added or removed, but the event lists cannot be
     * updated. */
    taskENTER_CRITICAL();
    1646:	0f b6       	in	r0, 0x3f	; 63
    1648:	f8 94       	cli
    164a:	0f 92       	push	r0
    {
        int8_t cTxLock = pxQueue->cTxLock;
    164c:	1e 8d       	ldd	r17, Y+30	; 0x1e
                    /* Tasks that are removed from the event list will get
                     * added to the pending ready list as the scheduler is still
                     * suspended. */
                    if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
                    {
                        if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    164e:	91 e1       	ldi	r25, 0x11	; 17
    1650:	e9 2e       	mov	r14, r25
    1652:	f1 2c       	mov	r15, r1
    1654:	ec 0e       	add	r14, r28
    1656:	fd 1e       	adc	r15, r29
    1658:	13 c0       	rjmp	.+38     	; 0x1680 <prvUnlockQueue+0x46>
        {
            /* Data was posted while the queue was locked.  Are any tasks
             * blocked waiting for data to become available? */
            #if ( configUSE_QUEUE_SETS == 1 )
            {
                if( pxQueue->pxQueueSetContainer != NULL )
    165a:	8f 8d       	ldd	r24, Y+31	; 0x1f
    165c:	98 a1       	ldd	r25, Y+32	; 0x20
    165e:	89 2b       	or	r24, r25
    1660:	21 f0       	breq	.+8      	; 0x166a <prvUnlockQueue+0x30>
                {
                    if( prvNotifyQueueSetContainer( pxQueue ) != pdFALSE )
    1662:	ce 01       	movw	r24, r28
    1664:	0e 94 dd 0a 	call	0x15ba	; 0x15ba <prvNotifyQueueSetContainer>
    1668:	06 c0       	rjmp	.+12     	; 0x1676 <prvUnlockQueue+0x3c>
                else
                {
                    /* Tasks that are removed from the event list will get
                     * added to the pending ready list as the scheduler is still
                     * suspended. */
                    if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    166a:	89 89       	ldd	r24, Y+17	; 0x11
    166c:	88 23       	and	r24, r24
    166e:	51 f0       	breq	.+20     	; 0x1684 <prvUnlockQueue+0x4a>
                    {
                        if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    1670:	c7 01       	movw	r24, r14
    1672:	0e 94 00 17 	call	0x2e00	; 0x2e00 <xTaskRemoveFromEventList>
    1676:	88 23       	and	r24, r24
    1678:	11 f0       	breq	.+4      	; 0x167e <prvUnlockQueue+0x44>
                        {
                            /* The task waiting has a higher priority so record that a
                             * context switch is required. */
                            vTaskMissedYield();
    167a:	0e 94 a0 18 	call	0x3140	; 0x3140 <vTaskMissedYield>
                    break;
                }
            }
            #endif /* configUSE_QUEUE_SETS */

            --cTxLock;
    167e:	11 50       	subi	r17, 0x01	; 1
    taskENTER_CRITICAL();
    {
        int8_t cTxLock = pxQueue->cTxLock;

        /* See if data was added to the queue while it was locked. */
        while( cTxLock > queueLOCKED_UNMODIFIED )
    1680:	11 16       	cp	r1, r17
    1682:	5c f3       	brlt	.-42     	; 0x165a <prvUnlockQueue+0x20>
            #endif /* configUSE_QUEUE_SETS */

            --cTxLock;
        }

        pxQueue->cTxLock = queueUNLOCKED;
    1684:	8f ef       	ldi	r24, 0xFF	; 255
    1686:	8e 8f       	std	Y+30, r24	; 0x1e
    }
    taskEXIT_CRITICAL();
    1688:	0f 90       	pop	r0
    168a:	0f be       	out	0x3f, r0	; 63

    /* Do the same for the Rx lock. */
    taskENTER_CRITICAL();
    168c:	0f b6       	in	r0, 0x3f	; 63
    168e:	f8 94       	cli
    1690:	0f 92       	push	r0
    {
        int8_t cRxLock = pxQueue->cRxLock;
    1692:	1d 8d       	ldd	r17, Y+29	; 0x1d

        while( cRxLock > queueLOCKED_UNMODIFIED )
        {
            if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
            {
                if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
    1694:	88 e0       	ldi	r24, 0x08	; 8
    1696:	e8 2e       	mov	r14, r24
    1698:	f1 2c       	mov	r15, r1
    169a:	ec 0e       	add	r14, r28
    169c:	fd 1e       	adc	r15, r29
    169e:	0b c0       	rjmp	.+22     	; 0x16b6 <prvUnlockQueue+0x7c>
    {
        int8_t cRxLock = pxQueue->cRxLock;

        while( cRxLock > queueLOCKED_UNMODIFIED )
        {
            if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    16a0:	88 85       	ldd	r24, Y+8	; 0x08
    16a2:	88 23       	and	r24, r24
    16a4:	51 f0       	breq	.+20     	; 0x16ba <prvUnlockQueue+0x80>
            {
                if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
    16a6:	c7 01       	movw	r24, r14
    16a8:	0e 94 00 17 	call	0x2e00	; 0x2e00 <xTaskRemoveFromEventList>
    16ac:	88 23       	and	r24, r24
    16ae:	11 f0       	breq	.+4      	; 0x16b4 <prvUnlockQueue+0x7a>
                {
                    vTaskMissedYield();
    16b0:	0e 94 a0 18 	call	0x3140	; 0x3140 <vTaskMissedYield>
                else
                {
                    mtCOVERAGE_TEST_MARKER();
                }

                --cRxLock;
    16b4:	11 50       	subi	r17, 0x01	; 1
    /* Do the same for the Rx lock. */
    taskENTER_CRITICAL();
    {
        int8_t cRxLock = pxQueue->cRxLock;

        while( cRxLock > queueLOCKED_UNMODIFIED )
    16b6:	11 16       	cp	r1, r17
    16b8:	9c f3       	brlt	.-26     	; 0x16a0 <prvUnlockQueue+0x66>
            {
                break;
            }
        }

        pxQueue->cRxLock = queueUNLOCKED;
    16ba:	8f ef       	ldi	r24, 0xFF	; 255
    16bc:	8d 8f       	std	Y+29, r24	; 0x1d
    }
    taskEXIT_CRITICAL();
    16be:	0f 90       	pop	r0
    16c0:	0f be       	out	0x3f, r0	; 63
}
    16c2:	df 91       	pop	r29
    16c4:	cf 91       	pop	r28
    16c6:	1f 91       	pop	r17
    16c8:	ff 90       	pop	r15
    16ca:	ef 90       	pop	r14
    16cc:	08 95       	ret

000016ce <xQueuePeek>:
/*-----------------------------------------------------------*/

BaseType_t xQueuePeek( QueueHandle_t xQueue,
                       void * const pvBuffer,
                       TickType_t xTicksToWait )
{
    16ce:	8f 92       	push	r8
    16d0:	9f 92       	push	r9
    16d2:	af 92       	push	r10
    16d4:	bf 92       	push	r11
    16d6:	cf 92       	push	r12
    16d8:	df 92       	push	r13
    16da:	ef 92       	push	r14
    16dc:	ff 92       	push	r15
    16de:	0f 93       	push	r16
    16e0:	1f 93       	push	r17
    16e2:	df 93       	push	r29
    16e4:	cf 93       	push	r28
    16e6:	00 d0       	rcall	.+0      	; 0x16e8 <xQueuePeek+0x1a>
    16e8:	00 d0       	rcall	.+0      	; 0x16ea <xQueuePeek+0x1c>
    16ea:	0f 92       	push	r0
    16ec:	cd b7       	in	r28, 0x3d	; 61
    16ee:	de b7       	in	r29, 0x3e	; 62
    16f0:	7c 01       	movw	r14, r24
    16f2:	5b 01       	movw	r10, r22
    16f4:	5d 83       	std	Y+5, r21	; 0x05
    16f6:	4c 83       	std	Y+4, r20	; 0x04
            /* Timeout has not expired yet, check to see if there is data in the
            * queue now, and if not enter the Blocked state to wait for data. */
            if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
            {
                traceBLOCKING_ON_QUEUE_PEEK( pxQueue );
                vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
    16f8:	41 e1       	ldi	r20, 0x11	; 17
    16fa:	c4 2e       	mov	r12, r20
    16fc:	d1 2c       	mov	r13, r1
    16fe:	c8 0e       	add	r12, r24
    1700:	d9 1e       	adc	r13, r25
    1702:	20 e0       	ldi	r18, 0x00	; 0
                else if( xEntryTimeSet == pdFALSE )
                {
                    /* The queue was empty and a block time was specified so
                     * configure the timeout structure ready to enter the blocked
                     * state. */
                    vTaskInternalSetTimeOutState( &xTimeOut );
    1704:	8e 01       	movw	r16, r28
    1706:	0f 5f       	subi	r16, 0xFF	; 255
    1708:	1f 4f       	sbci	r17, 0xFF	; 255

        vTaskSuspendAll();
        prvLockQueue( pxQueue );

        /* Update the timeout state to see if it has expired yet. */
        if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
    170a:	34 e0       	ldi	r19, 0x04	; 4
    170c:	83 2e       	mov	r8, r19
    170e:	91 2c       	mov	r9, r1
    1710:	8c 0e       	add	r8, r28
    1712:	9d 1e       	adc	r9, r29
    1714:	01 c0       	rjmp	.+2      	; 0x1718 <xQueuePeek+0x4a>
            /* Timeout has not expired yet, check to see if there is data in the
            * queue now, and if not enter the Blocked state to wait for data. */
            if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
            {
                traceBLOCKING_ON_QUEUE_PEEK( pxQueue );
                vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
    1716:	21 e0       	ldi	r18, 0x01	; 1
    /*lint -save -e904  This function relaxes the coding standard somewhat to
     * allow return statements within the function itself.  This is done in the
     * interest of execution time efficiency. */
    for( ; ; )
    {
        taskENTER_CRITICAL();
    1718:	0f b6       	in	r0, 0x3f	; 63
    171a:	f8 94       	cli
    171c:	0f 92       	push	r0
        {
            const UBaseType_t uxMessagesWaiting = pxQueue->uxMessagesWaiting;
    171e:	f7 01       	movw	r30, r14
    1720:	82 8d       	ldd	r24, Z+26	; 0x1a

            /* Is there data in the queue now?  To be running the calling task
             * must be the highest priority task wanting to access the queue. */
            if( uxMessagesWaiting > ( UBaseType_t ) 0 )
    1722:	88 23       	and	r24, r24
    1724:	b9 f0       	breq	.+46     	; 0x1754 <xQueuePeek+0x86>
            {
                /* Remember the read position so it can be reset after the data
                 * is read from the queue as this function is only peeking the
                 * data, not removing it. */
                pcOriginalReadPosition = pxQueue->u.xQueue.pcReadFrom;
    1726:	06 81       	ldd	r16, Z+6	; 0x06
    1728:	17 81       	ldd	r17, Z+7	; 0x07

                prvCopyDataFromQueue( pxQueue, pvBuffer );
    172a:	c7 01       	movw	r24, r14
    172c:	b5 01       	movw	r22, r10
    172e:	0e 94 0d 0a 	call	0x141a	; 0x141a <prvCopyDataFromQueue>
                traceQUEUE_PEEK( pxQueue );

                /* The data is not being removed, so reset the read pointer. */
                pxQueue->u.xQueue.pcReadFrom = pcOriginalReadPosition;
    1732:	f7 01       	movw	r30, r14
    1734:	17 83       	std	Z+7, r17	; 0x07
    1736:	06 83       	std	Z+6, r16	; 0x06

                /* The data is being left in the queue, so see if there are
                 * any other tasks waiting for the data. */
                if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    1738:	81 89       	ldd	r24, Z+17	; 0x11
    173a:	88 23       	and	r24, r24
    173c:	39 f0       	breq	.+14     	; 0x174c <xQueuePeek+0x7e>
                {
                    if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    173e:	c6 01       	movw	r24, r12
    1740:	0e 94 00 17 	call	0x2e00	; 0x2e00 <xTaskRemoveFromEventList>
    1744:	88 23       	and	r24, r24
    1746:	11 f0       	breq	.+4      	; 0x174c <xQueuePeek+0x7e>
                    {
                        /* The task waiting has a higher priority than this task. */
                        queueYIELD_IF_USING_PREEMPTION();
    1748:	0e 94 64 09 	call	0x12c8	; 0x12c8 <vPortYield>
                else
                {
                    mtCOVERAGE_TEST_MARKER();
                }

                taskEXIT_CRITICAL();
    174c:	0f 90       	pop	r0
    174e:	0f be       	out	0x3f, r0	; 63
    1750:	81 e0       	ldi	r24, 0x01	; 1
    1752:	54 c0       	rjmp	.+168    	; 0x17fc <xQueuePeek+0x12e>
                return pdPASS;
            }
            else
            {
                if( xTicksToWait == ( TickType_t ) 0 )
    1754:	8c 81       	ldd	r24, Y+4	; 0x04
    1756:	9d 81       	ldd	r25, Y+5	; 0x05
    1758:	89 2b       	or	r24, r25
    175a:	21 f4       	brne	.+8      	; 0x1764 <xQueuePeek+0x96>
                {
                    /* The queue was empty and no block time is specified (or
                     * the block time has expired) so leave now. */
                    taskEXIT_CRITICAL();
    175c:	0f 90       	pop	r0
    175e:	0f be       	out	0x3f, r0	; 63
    1760:	80 e0       	ldi	r24, 0x00	; 0
    1762:	4c c0       	rjmp	.+152    	; 0x17fc <xQueuePeek+0x12e>
                    traceQUEUE_PEEK_FAILED( pxQueue );
                    return errQUEUE_EMPTY;
                }
                else if( xEntryTimeSet == pdFALSE )
    1764:	22 23       	and	r18, r18
    1766:	19 f4       	brne	.+6      	; 0x176e <xQueuePeek+0xa0>
                {
                    /* The queue was empty and a block time was specified so
                     * configure the timeout structure ready to enter the blocked
                     * state. */
                    vTaskInternalSetTimeOutState( &xTimeOut );
    1768:	c8 01       	movw	r24, r16
    176a:	0e 94 5d 18 	call	0x30ba	; 0x30ba <vTaskInternalSetTimeOutState>
                    /* Entry time was already set. */
                    mtCOVERAGE_TEST_MARKER();
                }
            }
        }
        taskEXIT_CRITICAL();
    176e:	0f 90       	pop	r0
    1770:	0f be       	out	0x3f, r0	; 63

        /* Interrupts and other tasks can send to and receive from the queue
         * now that the critical section has been exited. */

        vTaskSuspendAll();
    1772:	0e 94 89 15 	call	0x2b12	; 0x2b12 <vTaskSuspendAll>
        prvLockQueue( pxQueue );
    1776:	0f b6       	in	r0, 0x3f	; 63
    1778:	f8 94       	cli
    177a:	0f 92       	push	r0
    177c:	f7 01       	movw	r30, r14
    177e:	85 8d       	ldd	r24, Z+29	; 0x1d
    1780:	8f 3f       	cpi	r24, 0xFF	; 255
    1782:	09 f4       	brne	.+2      	; 0x1786 <xQueuePeek+0xb8>
    1784:	15 8e       	std	Z+29, r1	; 0x1d
    1786:	f7 01       	movw	r30, r14
    1788:	86 8d       	ldd	r24, Z+30	; 0x1e
    178a:	8f 3f       	cpi	r24, 0xFF	; 255
    178c:	09 f4       	brne	.+2      	; 0x1790 <xQueuePeek+0xc2>
    178e:	16 8e       	std	Z+30, r1	; 0x1e
    1790:	0f 90       	pop	r0
    1792:	0f be       	out	0x3f, r0	; 63

        /* Update the timeout state to see if it has expired yet. */
        if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
    1794:	c8 01       	movw	r24, r16
    1796:	b4 01       	movw	r22, r8
    1798:	0e 94 68 18 	call	0x30d0	; 0x30d0 <xTaskCheckForTimeOut>
    179c:	88 23       	and	r24, r24
    179e:	f9 f4       	brne	.+62     	; 0x17de <xQueuePeek+0x110>

static BaseType_t prvIsQueueEmpty( const Queue_t * pxQueue )
{
    BaseType_t xReturn;

    taskENTER_CRITICAL();
    17a0:	0f b6       	in	r0, 0x3f	; 63
    17a2:	f8 94       	cli
    17a4:	0f 92       	push	r0
    {
        if( pxQueue->uxMessagesWaiting == ( UBaseType_t ) 0 )
    17a6:	f7 01       	movw	r30, r14
    17a8:	82 8d       	ldd	r24, Z+26	; 0x1a
        else
        {
            xReturn = pdFALSE;
        }
    }
    taskEXIT_CRITICAL();
    17aa:	0f 90       	pop	r0
    17ac:	0f be       	out	0x3f, r0	; 63
        /* Update the timeout state to see if it has expired yet. */
        if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
        {
            /* Timeout has not expired yet, check to see if there is data in the
            * queue now, and if not enter the Blocked state to wait for data. */
            if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
    17ae:	88 23       	and	r24, r24
    17b0:	81 f4       	brne	.+32     	; 0x17d2 <xQueuePeek+0x104>
            {
                traceBLOCKING_ON_QUEUE_PEEK( pxQueue );
                vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
    17b2:	6c 81       	ldd	r22, Y+4	; 0x04
    17b4:	7d 81       	ldd	r23, Y+5	; 0x05
    17b6:	c6 01       	movw	r24, r12
    17b8:	0e 94 34 20 	call	0x4068	; 0x4068 <vTaskPlaceOnEventList>
                prvUnlockQueue( pxQueue );
    17bc:	c7 01       	movw	r24, r14
    17be:	0e 94 1d 0b 	call	0x163a	; 0x163a <prvUnlockQueue>

                if( xTaskResumeAll() == pdFALSE )
    17c2:	0e 94 9b 1b 	call	0x3736	; 0x3736 <xTaskResumeAll>
    17c6:	88 23       	and	r24, r24
    17c8:	09 f0       	breq	.+2      	; 0x17cc <xQueuePeek+0xfe>
    17ca:	a5 cf       	rjmp	.-182    	; 0x1716 <xQueuePeek+0x48>
                {
                    portYIELD_WITHIN_API();
    17cc:	0e 94 64 09 	call	0x12c8	; 0x12c8 <vPortYield>
    17d0:	a2 cf       	rjmp	.-188    	; 0x1716 <xQueuePeek+0x48>
            }
            else
            {
                /* There is data in the queue now, so don't enter the blocked
                 * state, instead return to try and obtain the data. */
                prvUnlockQueue( pxQueue );
    17d2:	c7 01       	movw	r24, r14
    17d4:	0e 94 1d 0b 	call	0x163a	; 0x163a <prvUnlockQueue>
                ( void ) xTaskResumeAll();
    17d8:	0e 94 9b 1b 	call	0x3736	; 0x3736 <xTaskResumeAll>
    17dc:	9c cf       	rjmp	.-200    	; 0x1716 <xQueuePeek+0x48>
        }
        else
        {
            /* The timeout has expired.  If there is still no data in the queue
             * exit, otherwise go back and try to read the data again. */
            prvUnlockQueue( pxQueue );
    17de:	c7 01       	movw	r24, r14
    17e0:	0e 94 1d 0b 	call	0x163a	; 0x163a <prvUnlockQueue>
            ( void ) xTaskResumeAll();
    17e4:	0e 94 9b 1b 	call	0x3736	; 0x3736 <xTaskResumeAll>

static BaseType_t prvIsQueueEmpty( const Queue_t * pxQueue )
{
    BaseType_t xReturn;

    taskENTER_CRITICAL();
    17e8:	0f b6       	in	r0, 0x3f	; 63
    17ea:	f8 94       	cli
    17ec:	0f 92       	push	r0
    {
        if( pxQueue->uxMessagesWaiting == ( UBaseType_t ) 0 )
    17ee:	f7 01       	movw	r30, r14
    17f0:	82 8d       	ldd	r24, Z+26	; 0x1a
        else
        {
            xReturn = pdFALSE;
        }
    }
    taskEXIT_CRITICAL();
    17f2:	0f 90       	pop	r0
    17f4:	0f be       	out	0x3f, r0	; 63
            /* The timeout has expired.  If there is still no data in the queue
             * exit, otherwise go back and try to read the data again. */
            prvUnlockQueue( pxQueue );
            ( void ) xTaskResumeAll();

            if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
    17f6:	88 23       	and	r24, r24
    17f8:	09 f0       	breq	.+2      	; 0x17fc <xQueuePeek+0x12e>
    17fa:	8d cf       	rjmp	.-230    	; 0x1716 <xQueuePeek+0x48>
            {
                mtCOVERAGE_TEST_MARKER();
            }
        }
    } /*lint -restore */
}
    17fc:	0f 90       	pop	r0
    17fe:	0f 90       	pop	r0
    1800:	0f 90       	pop	r0
    1802:	0f 90       	pop	r0
    1804:	0f 90       	pop	r0
    1806:	cf 91       	pop	r28
    1808:	df 91       	pop	r29
    180a:	1f 91       	pop	r17
    180c:	0f 91       	pop	r16
    180e:	ff 90       	pop	r15
    1810:	ef 90       	pop	r14
    1812:	df 90       	pop	r13
    1814:	cf 90       	pop	r12
    1816:	bf 90       	pop	r11
    1818:	af 90       	pop	r10
    181a:	9f 90       	pop	r9
    181c:	8f 90       	pop	r8
    181e:	08 95       	ret

00001820 <xQueueReceive>:
/*-----------------------------------------------------------*/

BaseType_t xQueueReceive( QueueHandle_t xQueue,
                          void * const pvBuffer,
                          TickType_t xTicksToWait )
{
    1820:	6f 92       	push	r6
    1822:	7f 92       	push	r7
    1824:	8f 92       	push	r8
    1826:	9f 92       	push	r9
    1828:	af 92       	push	r10
    182a:	bf 92       	push	r11
    182c:	cf 92       	push	r12
    182e:	df 92       	push	r13
    1830:	ff 92       	push	r15
    1832:	0f 93       	push	r16
    1834:	1f 93       	push	r17
    1836:	df 93       	push	r29
    1838:	cf 93       	push	r28
    183a:	00 d0       	rcall	.+0      	; 0x183c <xQueueReceive+0x1c>
    183c:	00 d0       	rcall	.+0      	; 0x183e <xQueueReceive+0x1e>
    183e:	0f 92       	push	r0
    1840:	cd b7       	in	r28, 0x3d	; 61
    1842:	de b7       	in	r29, 0x3e	; 62
    1844:	8c 01       	movw	r16, r24
    1846:	5b 01       	movw	r10, r22
    1848:	5d 83       	std	Y+5, r21	; 0x05
    184a:	4c 83       	std	Y+4, r20	; 0x04
            /* The timeout has not expired.  If the queue is still empty place
             * the task on the list of tasks waiting to receive from the queue. */
            if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
            {
                traceBLOCKING_ON_QUEUE_RECEIVE( pxQueue );
                vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
    184c:	61 e1       	ldi	r22, 0x11	; 17
    184e:	c6 2e       	mov	r12, r22
    1850:	d1 2c       	mov	r13, r1
    1852:	c8 0e       	add	r12, r24
    1854:	d9 1e       	adc	r13, r25
    1856:	20 e0       	ldi	r18, 0x00	; 0
                }
                else if( xEntryTimeSet == pdFALSE )
                {
                    /* The queue was empty and a block time was specified so
                     * configure the timeout structure. */
                    vTaskInternalSetTimeOutState( &xTimeOut );
    1858:	4e 01       	movw	r8, r28
    185a:	08 94       	sec
    185c:	81 1c       	adc	r8, r1
    185e:	91 1c       	adc	r9, r1

        vTaskSuspendAll();
        prvLockQueue( pxQueue );

        /* Update the timeout state to see if it has expired yet. */
        if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
    1860:	54 e0       	ldi	r21, 0x04	; 4
    1862:	65 2e       	mov	r6, r21
    1864:	71 2c       	mov	r7, r1
    1866:	6c 0e       	add	r6, r28
    1868:	7d 1e       	adc	r7, r29
    186a:	01 c0       	rjmp	.+2      	; 0x186e <xQueueReceive+0x4e>
            /* The timeout has not expired.  If the queue is still empty place
             * the task on the list of tasks waiting to receive from the queue. */
            if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
            {
                traceBLOCKING_ON_QUEUE_RECEIVE( pxQueue );
                vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
    186c:	21 e0       	ldi	r18, 0x01	; 1
    /*lint -save -e904  This function relaxes the coding standard somewhat to
     * allow return statements within the function itself.  This is done in the
     * interest of execution time efficiency. */
    for( ; ; )
    {
        taskENTER_CRITICAL();
    186e:	0f b6       	in	r0, 0x3f	; 63
    1870:	f8 94       	cli
    1872:	0f 92       	push	r0
        {
            const UBaseType_t uxMessagesWaiting = pxQueue->uxMessagesWaiting;
    1874:	f8 01       	movw	r30, r16
    1876:	f2 8c       	ldd	r15, Z+26	; 0x1a

            /* Is there data in the queue now?  To be running the calling task
             * must be the highest priority task wanting to access the queue. */
            if( uxMessagesWaiting > ( UBaseType_t ) 0 )
    1878:	ff 20       	and	r15, r15
    187a:	b1 f0       	breq	.+44     	; 0x18a8 <xQueueReceive+0x88>
            {
                /* Data available, remove one item. */
                prvCopyDataFromQueue( pxQueue, pvBuffer );
    187c:	c8 01       	movw	r24, r16
    187e:	b5 01       	movw	r22, r10
    1880:	0e 94 0d 0a 	call	0x141a	; 0x141a <prvCopyDataFromQueue>
                traceQUEUE_RECEIVE( pxQueue );
                pxQueue->uxMessagesWaiting = uxMessagesWaiting - ( UBaseType_t ) 1;
    1884:	fa 94       	dec	r15
    1886:	f8 01       	movw	r30, r16
    1888:	f2 8e       	std	Z+26, r15	; 0x1a

                /* There is now space in the queue, were any tasks waiting to
                 * post to the queue?  If so, unblock the highest priority waiting
                 * task. */
                if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    188a:	80 85       	ldd	r24, Z+8	; 0x08
    188c:	88 23       	and	r24, r24
    188e:	41 f0       	breq	.+16     	; 0x18a0 <xQueueReceive+0x80>
                {
                    if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
    1890:	c8 01       	movw	r24, r16
    1892:	08 96       	adiw	r24, 0x08	; 8
    1894:	0e 94 00 17 	call	0x2e00	; 0x2e00 <xTaskRemoveFromEventList>
    1898:	88 23       	and	r24, r24
    189a:	11 f0       	breq	.+4      	; 0x18a0 <xQueueReceive+0x80>
                    {
                        queueYIELD_IF_USING_PREEMPTION();
    189c:	0e 94 64 09 	call	0x12c8	; 0x12c8 <vPortYield>
                else
                {
                    mtCOVERAGE_TEST_MARKER();
                }

                taskEXIT_CRITICAL();
    18a0:	0f 90       	pop	r0
    18a2:	0f be       	out	0x3f, r0	; 63
    18a4:	81 e0       	ldi	r24, 0x01	; 1
    18a6:	54 c0       	rjmp	.+168    	; 0x1950 <xQueueReceive+0x130>
                return pdPASS;
            }
            else
            {
                if( xTicksToWait == ( TickType_t ) 0 )
    18a8:	8c 81       	ldd	r24, Y+4	; 0x04
    18aa:	9d 81       	ldd	r25, Y+5	; 0x05
    18ac:	89 2b       	or	r24, r25
    18ae:	21 f4       	brne	.+8      	; 0x18b8 <xQueueReceive+0x98>
                {
                    /* The queue was empty and no block time is specified (or
                     * the block time has expired) so leave now. */
                    taskEXIT_CRITICAL();
    18b0:	0f 90       	pop	r0
    18b2:	0f be       	out	0x3f, r0	; 63
    18b4:	80 e0       	ldi	r24, 0x00	; 0
    18b6:	4c c0       	rjmp	.+152    	; 0x1950 <xQueueReceive+0x130>
                    traceQUEUE_RECEIVE_FAILED( pxQueue );
                    return errQUEUE_EMPTY;
                }
                else if( xEntryTimeSet == pdFALSE )
    18b8:	22 23       	and	r18, r18
    18ba:	19 f4       	brne	.+6      	; 0x18c2 <xQueueReceive+0xa2>
                {
                    /* The queue was empty and a block time was specified so
                     * configure the timeout structure. */
                    vTaskInternalSetTimeOutState( &xTimeOut );
    18bc:	c4 01       	movw	r24, r8
    18be:	0e 94 5d 18 	call	0x30ba	; 0x30ba <vTaskInternalSetTimeOutState>
                    /* Entry time was already set. */
                    mtCOVERAGE_TEST_MARKER();
                }
            }
        }
        taskEXIT_CRITICAL();
    18c2:	0f 90       	pop	r0
    18c4:	0f be       	out	0x3f, r0	; 63

        /* Interrupts and other tasks can send to and receive from the queue
         * now the critical section has been exited. */

        vTaskSuspendAll();
    18c6:	0e 94 89 15 	call	0x2b12	; 0x2b12 <vTaskSuspendAll>
        prvLockQueue( pxQueue );
    18ca:	0f b6       	in	r0, 0x3f	; 63
    18cc:	f8 94       	cli
    18ce:	0f 92       	push	r0
    18d0:	f8 01       	movw	r30, r16
    18d2:	85 8d       	ldd	r24, Z+29	; 0x1d
    18d4:	8f 3f       	cpi	r24, 0xFF	; 255
    18d6:	09 f4       	brne	.+2      	; 0x18da <xQueueReceive+0xba>
    18d8:	15 8e       	std	Z+29, r1	; 0x1d
    18da:	f8 01       	movw	r30, r16
    18dc:	86 8d       	ldd	r24, Z+30	; 0x1e
    18de:	8f 3f       	cpi	r24, 0xFF	; 255
    18e0:	09 f4       	brne	.+2      	; 0x18e4 <xQueueReceive+0xc4>
    18e2:	16 8e       	std	Z+30, r1	; 0x1e
    18e4:	0f 90       	pop	r0
    18e6:	0f be       	out	0x3f, r0	; 63

        /* Update the timeout state to see if it has expired yet. */
        if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
    18e8:	c4 01       	movw	r24, r8
    18ea:	b3 01       	movw	r22, r6
    18ec:	0e 94 68 18 	call	0x30d0	; 0x30d0 <xTaskCheckForTimeOut>
    18f0:	88 23       	and	r24, r24
    18f2:	f9 f4       	brne	.+62     	; 0x1932 <xQueueReceive+0x112>

static BaseType_t prvIsQueueEmpty( const Queue_t * pxQueue )
{
    BaseType_t xReturn;

    taskENTER_CRITICAL();
    18f4:	0f b6       	in	r0, 0x3f	; 63
    18f6:	f8 94       	cli
    18f8:	0f 92       	push	r0
    {
        if( pxQueue->uxMessagesWaiting == ( UBaseType_t ) 0 )
    18fa:	f8 01       	movw	r30, r16
    18fc:	82 8d       	ldd	r24, Z+26	; 0x1a
        else
        {
            xReturn = pdFALSE;
        }
    }
    taskEXIT_CRITICAL();
    18fe:	0f 90       	pop	r0
    1900:	0f be       	out	0x3f, r0	; 63
        /* Update the timeout state to see if it has expired yet. */
        if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
        {
            /* The timeout has not expired.  If the queue is still empty place
             * the task on the list of tasks waiting to receive from the queue. */
            if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
    1902:	88 23       	and	r24, r24
    1904:	81 f4       	brne	.+32     	; 0x1926 <xQueueReceive+0x106>
            {
                traceBLOCKING_ON_QUEUE_RECEIVE( pxQueue );
                vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
    1906:	6c 81       	ldd	r22, Y+4	; 0x04
    1908:	7d 81       	ldd	r23, Y+5	; 0x05
    190a:	c6 01       	movw	r24, r12
    190c:	0e 94 34 20 	call	0x4068	; 0x4068 <vTaskPlaceOnEventList>
                prvUnlockQueue( pxQueue );
    1910:	c8 01       	movw	r24, r16
    1912:	0e 94 1d 0b 	call	0x163a	; 0x163a <prvUnlockQueue>

                if( xTaskResumeAll() == pdFALSE )
    1916:	0e 94 9b 1b 	call	0x3736	; 0x3736 <xTaskResumeAll>
    191a:	88 23       	and	r24, r24
    191c:	09 f0       	breq	.+2      	; 0x1920 <xQueueReceive+0x100>
    191e:	a6 cf       	rjmp	.-180    	; 0x186c <xQueueReceive+0x4c>
                {
                    portYIELD_WITHIN_API();
    1920:	0e 94 64 09 	call	0x12c8	; 0x12c8 <vPortYield>
    1924:	a3 cf       	rjmp	.-186    	; 0x186c <xQueueReceive+0x4c>
            }
            else
            {
                /* The queue contains data again.  Loop back to try and read the
                 * data. */
                prvUnlockQueue( pxQueue );
    1926:	c8 01       	movw	r24, r16
    1928:	0e 94 1d 0b 	call	0x163a	; 0x163a <prvUnlockQueue>
                ( void ) xTaskResumeAll();
    192c:	0e 94 9b 1b 	call	0x3736	; 0x3736 <xTaskResumeAll>
    1930:	9d cf       	rjmp	.-198    	; 0x186c <xQueueReceive+0x4c>
        }
        else
        {
            /* Timed out.  If there is no data in the queue exit, otherwise loop
             * back and attempt to read the data. */
            prvUnlockQueue( pxQueue );
    1932:	c8 01       	movw	r24, r16
    1934:	0e 94 1d 0b 	call	0x163a	; 0x163a <prvUnlockQueue>
            ( void ) xTaskResumeAll();
    1938:	0e 94 9b 1b 	call	0x3736	; 0x3736 <xTaskResumeAll>

static BaseType_t prvIsQueueEmpty( const Queue_t * pxQueue )
{
    BaseType_t xReturn;

    taskENTER_CRITICAL();
    193c:	0f b6       	in	r0, 0x3f	; 63
    193e:	f8 94       	cli
    1940:	0f 92       	push	r0
    {
        if( pxQueue->uxMessagesWaiting == ( UBaseType_t ) 0 )
    1942:	f8 01       	movw	r30, r16
    1944:	82 8d       	ldd	r24, Z+26	; 0x1a
        else
        {
            xReturn = pdFALSE;
        }
    }
    taskEXIT_CRITICAL();
    1946:	0f 90       	pop	r0
    1948:	0f be       	out	0x3f, r0	; 63
            /* Timed out.  If there is no data in the queue exit, otherwise loop
             * back and attempt to read the data. */
            prvUnlockQueue( pxQueue );
            ( void ) xTaskResumeAll();

            if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
    194a:	88 23       	and	r24, r24
    194c:	09 f0       	breq	.+2      	; 0x1950 <xQueueReceive+0x130>
    194e:	8e cf       	rjmp	.-228    	; 0x186c <xQueueReceive+0x4c>
            {
                mtCOVERAGE_TEST_MARKER();
            }
        }
    } /*lint -restore */
}
    1950:	0f 90       	pop	r0
    1952:	0f 90       	pop	r0
    1954:	0f 90       	pop	r0
    1956:	0f 90       	pop	r0
    1958:	0f 90       	pop	r0
    195a:	cf 91       	pop	r28
    195c:	df 91       	pop	r29
    195e:	1f 91       	pop	r17
    1960:	0f 91       	pop	r16
    1962:	ff 90       	pop	r15
    1964:	df 90       	pop	r13
    1966:	cf 90       	pop	r12
    1968:	bf 90       	pop	r11
    196a:	af 90       	pop	r10
    196c:	9f 90       	pop	r9
    196e:	8f 90       	pop	r8
    1970:	7f 90       	pop	r7
    1972:	6f 90       	pop	r6
    1974:	08 95       	ret

00001976 <xQueueSelectFromSet>:

#if ( configUSE_QUEUE_SETS == 1 )

    QueueSetMemberHandle_t xQueueSelectFromSet( QueueSetHandle_t xQueueSet,
                                                TickType_t const xTicksToWait )
    {
    1976:	df 93       	push	r29
    1978:	cf 93       	push	r28
    197a:	00 d0       	rcall	.+0      	; 0x197c <xQueueSelectFromSet+0x6>
    197c:	cd b7       	in	r28, 0x3d	; 61
    197e:	de b7       	in	r29, 0x3e	; 62
    1980:	ab 01       	movw	r20, r22
        QueueSetMemberHandle_t xReturn = NULL;
    1982:	1a 82       	std	Y+2, r1	; 0x02
    1984:	19 82       	std	Y+1, r1	; 0x01

        ( void ) xQueueReceive( ( QueueHandle_t ) xQueueSet, &xReturn, xTicksToWait ); /*lint !e961 Casting from one typedef to another is not redundant. */
    1986:	be 01       	movw	r22, r28
    1988:	6f 5f       	subi	r22, 0xFF	; 255
    198a:	7f 4f       	sbci	r23, 0xFF	; 255
    198c:	0e 94 10 0c 	call	0x1820	; 0x1820 <xQueueReceive>
        return xReturn;
    }
    1990:	89 81       	ldd	r24, Y+1	; 0x01
    1992:	9a 81       	ldd	r25, Y+2	; 0x02
    1994:	0f 90       	pop	r0
    1996:	0f 90       	pop	r0
    1998:	cf 91       	pop	r28
    199a:	df 91       	pop	r29
    199c:	08 95       	ret

0000199e <xQueueGiveFromISR>:
}
/*-----------------------------------------------------------*/

BaseType_t xQueueGiveFromISR( QueueHandle_t xQueue,
                              BaseType_t * const pxHigherPriorityTaskWoken )
{
    199e:	ef 92       	push	r14
    19a0:	ff 92       	push	r15
    19a2:	1f 93       	push	r17
    19a4:	cf 93       	push	r28
    19a6:	df 93       	push	r29
    19a8:	ec 01       	movw	r28, r24
    19aa:	7b 01       	movw	r14, r22
     * link: https://www.FreeRTOS.org/RTOS-Cortex-M3-M4.html */
    portASSERT_IF_INTERRUPT_PRIORITY_INVALID();

    uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
    {
        const UBaseType_t uxMessagesWaiting = pxQueue->uxMessagesWaiting;
    19ac:	9a 8d       	ldd	r25, Y+26	; 0x1a

        /* When the queue is used to implement a semaphore no data is ever
         * moved through the queue but it is still valid to see if the queue 'has
         * space'. */
        if( uxMessagesWaiting < pxQueue->uxLength )
    19ae:	8b 8d       	ldd	r24, Y+27	; 0x1b
    19b0:	98 17       	cp	r25, r24
    19b2:	10 f0       	brcs	.+4      	; 0x19b8 <xQueueGiveFromISR+0x1a>
    19b4:	80 e0       	ldi	r24, 0x00	; 0
    19b6:	24 c0       	rjmp	.+72     	; 0x1a00 <xQueueGiveFromISR+0x62>
        {
            const int8_t cTxLock = pxQueue->cTxLock;
    19b8:	1e 8d       	ldd	r17, Y+30	; 0x1e
             * holder - and if there is a mutex holder then the mutex cannot be
             * given from an ISR.  As this is the ISR version of the function it
             * can be assumed there is no mutex holder and no need to determine if
             * priority disinheritance is needed.  Simply increase the count of
             * messages (semaphores) available. */
            pxQueue->uxMessagesWaiting = uxMessagesWaiting + ( UBaseType_t ) 1;
    19ba:	9f 5f       	subi	r25, 0xFF	; 255
    19bc:	9a 8f       	std	Y+26, r25	; 0x1a

            /* The event list is not altered if the queue is locked.  This will
             * be done when the queue is unlocked later. */
            if( cTxLock == queueUNLOCKED )
    19be:	1f 3f       	cpi	r17, 0xFF	; 255
    19c0:	c1 f4       	brne	.+48     	; 0x19f2 <xQueueGiveFromISR+0x54>
            {
                #if ( configUSE_QUEUE_SETS == 1 )
                {
                    if( pxQueue->pxQueueSetContainer != NULL )
    19c2:	8f 8d       	ldd	r24, Y+31	; 0x1f
    19c4:	98 a1       	ldd	r25, Y+32	; 0x20
    19c6:	89 2b       	or	r24, r25
    19c8:	21 f0       	breq	.+8      	; 0x19d2 <xQueueGiveFromISR+0x34>
                    {
                        if( prvNotifyQueueSetContainer( pxQueue ) != pdFALSE )
    19ca:	ce 01       	movw	r24, r28
    19cc:	0e 94 dd 0a 	call	0x15ba	; 0x15ba <prvNotifyQueueSetContainer>
    19d0:	07 c0       	rjmp	.+14     	; 0x19e0 <xQueueGiveFromISR+0x42>
                            mtCOVERAGE_TEST_MARKER();
                        }
                    }
                    else
                    {
                        if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    19d2:	89 89       	ldd	r24, Y+17	; 0x11
    19d4:	88 23       	and	r24, r24
    19d6:	99 f0       	breq	.+38     	; 0x19fe <xQueueGiveFromISR+0x60>
                        {
                            if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    19d8:	ce 01       	movw	r24, r28
    19da:	41 96       	adiw	r24, 0x11	; 17
    19dc:	0e 94 00 17 	call	0x2e00	; 0x2e00 <xTaskRemoveFromEventList>
    19e0:	88 23       	and	r24, r24
    19e2:	69 f0       	breq	.+26     	; 0x19fe <xQueueGiveFromISR+0x60>
                            {
                                /* The task waiting has a higher priority so
                                 *  record that a context switch is required. */
                                if( pxHigherPriorityTaskWoken != NULL )
    19e4:	e1 14       	cp	r14, r1
    19e6:	f1 04       	cpc	r15, r1
    19e8:	51 f0       	breq	.+20     	; 0x19fe <xQueueGiveFromISR+0x60>
                                {
                                    *pxHigherPriorityTaskWoken = pdTRUE;
    19ea:	81 e0       	ldi	r24, 0x01	; 1
    19ec:	f7 01       	movw	r30, r14
    19ee:	80 83       	st	Z, r24
    19f0:	07 c0       	rjmp	.+14     	; 0x1a00 <xQueueGiveFromISR+0x62>
            }
            else
            {
                /* Increment the lock count so the task that unlocks the queue
                 * knows that data was posted while it was locked. */
                prvIncrementQueueTxLock( pxQueue, cTxLock );
    19f2:	0e 94 a0 15 	call	0x2b40	; 0x2b40 <uxTaskGetNumberOfTasks>
    19f6:	18 17       	cp	r17, r24
    19f8:	10 f4       	brcc	.+4      	; 0x19fe <xQueueGiveFromISR+0x60>
    19fa:	1f 5f       	subi	r17, 0xFF	; 255
    19fc:	1e 8f       	std	Y+30, r17	; 0x1e
    19fe:	81 e0       	ldi	r24, 0x01	; 1
        }
    }
    portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

    return xReturn;
}
    1a00:	df 91       	pop	r29
    1a02:	cf 91       	pop	r28
    1a04:	1f 91       	pop	r17
    1a06:	ff 90       	pop	r15
    1a08:	ef 90       	pop	r14
    1a0a:	08 95       	ret

00001a0c <xQueueGenericSendFromISR>:

BaseType_t xQueueGenericSendFromISR( QueueHandle_t xQueue,
                                     const void * const pvItemToQueue,
                                     BaseType_t * const pxHigherPriorityTaskWoken,
                                     const BaseType_t xCopyPosition )
{
    1a0c:	df 92       	push	r13
    1a0e:	ef 92       	push	r14
    1a10:	ff 92       	push	r15
    1a12:	0f 93       	push	r16
    1a14:	1f 93       	push	r17
    1a16:	cf 93       	push	r28
    1a18:	df 93       	push	r29
    1a1a:	ec 01       	movw	r28, r24
    1a1c:	7a 01       	movw	r14, r20
    1a1e:	02 2f       	mov	r16, r18
     * read, instead return a flag to say whether a context switch is required or
     * not (i.e. has a task with a higher priority than us been woken by this
     * post). */
    uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
    {
        if( ( pxQueue->uxMessagesWaiting < pxQueue->uxLength ) || ( xCopyPosition == queueOVERWRITE ) )
    1a20:	9a 8d       	ldd	r25, Y+26	; 0x1a
    1a22:	8b 8d       	ldd	r24, Y+27	; 0x1b
    1a24:	98 17       	cp	r25, r24
    1a26:	20 f0       	brcs	.+8      	; 0x1a30 <xQueueGenericSendFromISR+0x24>
    1a28:	22 30       	cpi	r18, 0x02	; 2
    1a2a:	11 f0       	breq	.+4      	; 0x1a30 <xQueueGenericSendFromISR+0x24>
    1a2c:	80 e0       	ldi	r24, 0x00	; 0
    1a2e:	2b c0       	rjmp	.+86     	; 0x1a86 <xQueueGenericSendFromISR+0x7a>
        {
            const int8_t cTxLock = pxQueue->cTxLock;
    1a30:	1e 8d       	ldd	r17, Y+30	; 0x1e
            const UBaseType_t uxPreviousMessagesWaiting = pxQueue->uxMessagesWaiting;
    1a32:	da 8c       	ldd	r13, Y+26	; 0x1a
            /* Semaphores use xQueueGiveFromISR(), so pxQueue will not be a
             *  semaphore or mutex.  That means prvCopyDataToQueue() cannot result
             *  in a task disinheriting a priority and prvCopyDataToQueue() can be
             *  called here even though the disinherit function does not check if
             *  the scheduler is suspended before accessing the ready lists. */
            ( void ) prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition );
    1a34:	ce 01       	movw	r24, r28
    1a36:	40 2f       	mov	r20, r16
    1a38:	0e 94 87 0a 	call	0x150e	; 0x150e <prvCopyDataToQueue>

            /* The event list is not altered if the queue is locked.  This will
             * be done when the queue is unlocked later. */
            if( cTxLock == queueUNLOCKED )
    1a3c:	1f 3f       	cpi	r17, 0xFF	; 255
    1a3e:	e1 f4       	brne	.+56     	; 0x1a78 <xQueueGenericSendFromISR+0x6c>
            {
                #if ( configUSE_QUEUE_SETS == 1 )
                {
                    if( pxQueue->pxQueueSetContainer != NULL )
    1a40:	8f 8d       	ldd	r24, Y+31	; 0x1f
    1a42:	98 a1       	ldd	r25, Y+32	; 0x20
    1a44:	89 2b       	or	r24, r25
    1a46:	41 f0       	breq	.+16     	; 0x1a58 <xQueueGenericSendFromISR+0x4c>
                    {
                        if( ( xCopyPosition == queueOVERWRITE ) && ( uxPreviousMessagesWaiting != ( UBaseType_t ) 0 ) )
    1a48:	02 30       	cpi	r16, 0x02	; 2
    1a4a:	11 f4       	brne	.+4      	; 0x1a50 <xQueueGenericSendFromISR+0x44>
    1a4c:	dd 20       	and	r13, r13
    1a4e:	d1 f4       	brne	.+52     	; 0x1a84 <xQueueGenericSendFromISR+0x78>
                            /* Do not notify the queue set as an existing item
                             * was overwritten in the queue so the number of items
                             * in the queue has not changed. */
                            mtCOVERAGE_TEST_MARKER();
                        }
                        else if( prvNotifyQueueSetContainer( pxQueue ) != pdFALSE )
    1a50:	ce 01       	movw	r24, r28
    1a52:	0e 94 dd 0a 	call	0x15ba	; 0x15ba <prvNotifyQueueSetContainer>
    1a56:	07 c0       	rjmp	.+14     	; 0x1a66 <xQueueGenericSendFromISR+0x5a>
                            mtCOVERAGE_TEST_MARKER();
                        }
                    }
                    else
                    {
                        if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    1a58:	89 89       	ldd	r24, Y+17	; 0x11
    1a5a:	88 23       	and	r24, r24
    1a5c:	99 f0       	breq	.+38     	; 0x1a84 <xQueueGenericSendFromISR+0x78>
                        {
                            if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    1a5e:	ce 01       	movw	r24, r28
    1a60:	41 96       	adiw	r24, 0x11	; 17
    1a62:	0e 94 00 17 	call	0x2e00	; 0x2e00 <xTaskRemoveFromEventList>
    1a66:	88 23       	and	r24, r24
    1a68:	69 f0       	breq	.+26     	; 0x1a84 <xQueueGenericSendFromISR+0x78>
                            {
                                /* The task waiting has a higher priority so
                                 *  record that a context switch is required. */
                                if( pxHigherPriorityTaskWoken != NULL )
    1a6a:	e1 14       	cp	r14, r1
    1a6c:	f1 04       	cpc	r15, r1
    1a6e:	51 f0       	breq	.+20     	; 0x1a84 <xQueueGenericSendFromISR+0x78>
                                {
                                    *pxHigherPriorityTaskWoken = pdTRUE;
    1a70:	81 e0       	ldi	r24, 0x01	; 1
    1a72:	f7 01       	movw	r30, r14
    1a74:	80 83       	st	Z, r24
    1a76:	07 c0       	rjmp	.+14     	; 0x1a86 <xQueueGenericSendFromISR+0x7a>
            }
            else
            {
                /* Increment the lock count so the task that unlocks the queue
                 * knows that data was posted while it was locked. */
                prvIncrementQueueTxLock( pxQueue, cTxLock );
    1a78:	0e 94 a0 15 	call	0x2b40	; 0x2b40 <uxTaskGetNumberOfTasks>
    1a7c:	18 17       	cp	r17, r24
    1a7e:	10 f4       	brcc	.+4      	; 0x1a84 <xQueueGenericSendFromISR+0x78>
    1a80:	1f 5f       	subi	r17, 0xFF	; 255
    1a82:	1e 8f       	std	Y+30, r17	; 0x1e
    1a84:	81 e0       	ldi	r24, 0x01	; 1
        }
    }
    portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

    return xReturn;
}
    1a86:	df 91       	pop	r29
    1a88:	cf 91       	pop	r28
    1a8a:	1f 91       	pop	r17
    1a8c:	0f 91       	pop	r16
    1a8e:	ff 90       	pop	r15
    1a90:	ef 90       	pop	r14
    1a92:	df 90       	pop	r13
    1a94:	08 95       	ret

00001a96 <xQueueGenericSend>:

BaseType_t xQueueGenericSend( QueueHandle_t xQueue,
                              const void * const pvItemToQueue,
                              TickType_t xTicksToWait,
                              const BaseType_t xCopyPosition )
{
    1a96:	6f 92       	push	r6
    1a98:	7f 92       	push	r7
    1a9a:	8f 92       	push	r8
    1a9c:	9f 92       	push	r9
    1a9e:	af 92       	push	r10
    1aa0:	bf 92       	push	r11
    1aa2:	cf 92       	push	r12
    1aa4:	df 92       	push	r13
    1aa6:	ef 92       	push	r14
    1aa8:	ff 92       	push	r15
    1aaa:	0f 93       	push	r16
    1aac:	1f 93       	push	r17
    1aae:	df 93       	push	r29
    1ab0:	cf 93       	push	r28
    1ab2:	00 d0       	rcall	.+0      	; 0x1ab4 <xQueueGenericSend+0x1e>
    1ab4:	00 d0       	rcall	.+0      	; 0x1ab6 <xQueueGenericSend+0x20>
    1ab6:	0f 92       	push	r0
    1ab8:	cd b7       	in	r28, 0x3d	; 61
    1aba:	de b7       	in	r29, 0x3e	; 62
    1abc:	8c 01       	movw	r16, r24
    1abe:	5b 01       	movw	r10, r22
    1ac0:	5d 83       	std	Y+5, r21	; 0x05
    1ac2:	4c 83       	std	Y+4, r20	; 0x04
    1ac4:	e2 2e       	mov	r14, r18
        if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
        {
            if( prvIsQueueFull( pxQueue ) != pdFALSE )
            {
                traceBLOCKING_ON_QUEUE_SEND( pxQueue );
                vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToSend ), xTicksToWait );
    1ac6:	e8 e0       	ldi	r30, 0x08	; 8
    1ac8:	ce 2e       	mov	r12, r30
    1aca:	d1 2c       	mov	r13, r1
    1acc:	c8 0e       	add	r12, r24
    1ace:	d9 1e       	adc	r13, r25
    1ad0:	20 e0       	ldi	r18, 0x00	; 0
                }
                else if( xEntryTimeSet == pdFALSE )
                {
                    /* The queue was full and a block time was specified so
                     * configure the timeout structure. */
                    vTaskInternalSetTimeOutState( &xTimeOut );
    1ad2:	4e 01       	movw	r8, r28
    1ad4:	08 94       	sec
    1ad6:	81 1c       	adc	r8, r1
    1ad8:	91 1c       	adc	r9, r1

        vTaskSuspendAll();
        prvLockQueue( pxQueue );

        /* Update the timeout state to see if it has expired yet. */
        if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
    1ada:	74 e0       	ldi	r23, 0x04	; 4
    1adc:	67 2e       	mov	r6, r23
    1ade:	71 2c       	mov	r7, r1
    1ae0:	6c 0e       	add	r6, r28
    1ae2:	7d 1e       	adc	r7, r29
    1ae4:	01 c0       	rjmp	.+2      	; 0x1ae8 <xQueueGenericSend+0x52>
        {
            if( prvIsQueueFull( pxQueue ) != pdFALSE )
            {
                traceBLOCKING_ON_QUEUE_SEND( pxQueue );
                vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToSend ), xTicksToWait );
    1ae6:	21 e0       	ldi	r18, 0x01	; 1
    /*lint -save -e904 This function relaxes the coding standard somewhat to
     * allow return statements within the function itself.  This is done in the
     * interest of execution time efficiency. */
    for( ; ; )
    {
        taskENTER_CRITICAL();
    1ae8:	0f b6       	in	r0, 0x3f	; 63
    1aea:	f8 94       	cli
    1aec:	0f 92       	push	r0
        {
            /* Is there room on the queue now?  The running task must be the
             * highest priority task wanting to access the queue.  If the head item
             * in the queue is to be overwritten then it does not matter if the
             * queue is full. */
            if( ( pxQueue->uxMessagesWaiting < pxQueue->uxLength ) || ( xCopyPosition == queueOVERWRITE ) )
    1aee:	f8 01       	movw	r30, r16
    1af0:	92 8d       	ldd	r25, Z+26	; 0x1a
    1af2:	83 8d       	ldd	r24, Z+27	; 0x1b
    1af4:	98 17       	cp	r25, r24
    1af6:	18 f0       	brcs	.+6      	; 0x1afe <xQueueGenericSend+0x68>
    1af8:	f2 e0       	ldi	r31, 0x02	; 2
    1afa:	ef 16       	cp	r14, r31
    1afc:	49 f5       	brne	.+82     	; 0x1b50 <xQueueGenericSend+0xba>
            {
                traceQUEUE_SEND( pxQueue );

                #if ( configUSE_QUEUE_SETS == 1 )
                {
                    const UBaseType_t uxPreviousMessagesWaiting = pxQueue->uxMessagesWaiting;
    1afe:	f8 01       	movw	r30, r16
    1b00:	f2 8c       	ldd	r15, Z+26	; 0x1a

                    xYieldRequired = prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition );
    1b02:	c8 01       	movw	r24, r16
    1b04:	b5 01       	movw	r22, r10
    1b06:	4e 2d       	mov	r20, r14
    1b08:	0e 94 87 0a 	call	0x150e	; 0x150e <prvCopyDataToQueue>
    1b0c:	28 2f       	mov	r18, r24

                    if( pxQueue->pxQueueSetContainer != NULL )
    1b0e:	f8 01       	movw	r30, r16
    1b10:	87 8d       	ldd	r24, Z+31	; 0x1f
    1b12:	90 a1       	ldd	r25, Z+32	; 0x20
    1b14:	89 2b       	or	r24, r25
    1b16:	49 f0       	breq	.+18     	; 0x1b2a <xQueueGenericSend+0x94>
                    {
                        if( ( xCopyPosition == queueOVERWRITE ) && ( uxPreviousMessagesWaiting != ( UBaseType_t ) 0 ) )
    1b18:	f2 e0       	ldi	r31, 0x02	; 2
    1b1a:	ef 16       	cp	r14, r31
    1b1c:	11 f4       	brne	.+4      	; 0x1b22 <xQueueGenericSend+0x8c>
    1b1e:	ff 20       	and	r15, r15
    1b20:	99 f4       	brne	.+38     	; 0x1b48 <xQueueGenericSend+0xb2>
                            /* Do not notify the queue set as an existing item
                             * was overwritten in the queue so the number of items
                             * in the queue has not changed. */
                            mtCOVERAGE_TEST_MARKER();
                        }
                        else if( prvNotifyQueueSetContainer( pxQueue ) != pdFALSE )
    1b22:	c8 01       	movw	r24, r16
    1b24:	0e 94 dd 0a 	call	0x15ba	; 0x15ba <prvNotifyQueueSetContainer>
    1b28:	08 c0       	rjmp	.+16     	; 0x1b3a <xQueueGenericSend+0xa4>
                    }
                    else
                    {
                        /* If there was a task waiting for data to arrive on the
                         * queue then unblock it now. */
                        if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    1b2a:	f8 01       	movw	r30, r16
    1b2c:	81 89       	ldd	r24, Z+17	; 0x11
    1b2e:	88 23       	and	r24, r24
    1b30:	39 f0       	breq	.+14     	; 0x1b40 <xQueueGenericSend+0xaa>
                        {
                            if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    1b32:	c8 01       	movw	r24, r16
    1b34:	41 96       	adiw	r24, 0x11	; 17
    1b36:	0e 94 00 17 	call	0x2e00	; 0x2e00 <xTaskRemoveFromEventList>
    1b3a:	88 23       	and	r24, r24
    1b3c:	29 f0       	breq	.+10     	; 0x1b48 <xQueueGenericSend+0xb2>
    1b3e:	02 c0       	rjmp	.+4      	; 0x1b44 <xQueueGenericSend+0xae>
                            else
                            {
                                mtCOVERAGE_TEST_MARKER();
                            }
                        }
                        else if( xYieldRequired != pdFALSE )
    1b40:	22 23       	and	r18, r18
    1b42:	11 f0       	breq	.+4      	; 0x1b48 <xQueueGenericSend+0xb2>
                        {
                            /* This path is a special case that will only get
                             * executed if the task was holding multiple mutexes
                             * and the mutexes were given back in an order that is
                             * different to that in which they were taken. */
                            queueYIELD_IF_USING_PREEMPTION();
    1b44:	0e 94 64 09 	call	0x12c8	; 0x12c8 <vPortYield>
                        mtCOVERAGE_TEST_MARKER();
                    }
                }
                #endif /* configUSE_QUEUE_SETS */

                taskEXIT_CRITICAL();
    1b48:	0f 90       	pop	r0
    1b4a:	0f be       	out	0x3f, r0	; 63
    1b4c:	81 e0       	ldi	r24, 0x01	; 1
    1b4e:	4c c0       	rjmp	.+152    	; 0x1be8 <xQueueGenericSend+0x152>
                return pdPASS;
            }
            else
            {
                if( xTicksToWait == ( TickType_t ) 0 )
    1b50:	8c 81       	ldd	r24, Y+4	; 0x04
    1b52:	9d 81       	ldd	r25, Y+5	; 0x05
    1b54:	89 2b       	or	r24, r25
    1b56:	19 f4       	brne	.+6      	; 0x1b5e <xQueueGenericSend+0xc8>
                {
                    /* The queue was full and no block time is specified (or
                     * the block time has expired) so leave now. */
                    taskEXIT_CRITICAL();
    1b58:	0f 90       	pop	r0
    1b5a:	0f be       	out	0x3f, r0	; 63
    1b5c:	44 c0       	rjmp	.+136    	; 0x1be6 <xQueueGenericSend+0x150>
                    /* Return to the original privilege level before exiting
                     * the function. */
                    traceQUEUE_SEND_FAILED( pxQueue );
                    return errQUEUE_FULL;
                }
                else if( xEntryTimeSet == pdFALSE )
    1b5e:	22 23       	and	r18, r18
    1b60:	19 f4       	brne	.+6      	; 0x1b68 <xQueueGenericSend+0xd2>
                {
                    /* The queue was full and a block time was specified so
                     * configure the timeout structure. */
                    vTaskInternalSetTimeOutState( &xTimeOut );
    1b62:	c4 01       	movw	r24, r8
    1b64:	0e 94 5d 18 	call	0x30ba	; 0x30ba <vTaskInternalSetTimeOutState>
                    /* Entry time was already set. */
                    mtCOVERAGE_TEST_MARKER();
                }
            }
        }
        taskEXIT_CRITICAL();
    1b68:	0f 90       	pop	r0
    1b6a:	0f be       	out	0x3f, r0	; 63

        /* Interrupts and other tasks can send to and receive from the queue
         * now the critical section has been exited. */

        vTaskSuspendAll();
    1b6c:	0e 94 89 15 	call	0x2b12	; 0x2b12 <vTaskSuspendAll>
        prvLockQueue( pxQueue );
    1b70:	0f b6       	in	r0, 0x3f	; 63
    1b72:	f8 94       	cli
    1b74:	0f 92       	push	r0
    1b76:	f8 01       	movw	r30, r16
    1b78:	85 8d       	ldd	r24, Z+29	; 0x1d
    1b7a:	8f 3f       	cpi	r24, 0xFF	; 255
    1b7c:	09 f4       	brne	.+2      	; 0x1b80 <xQueueGenericSend+0xea>
    1b7e:	15 8e       	std	Z+29, r1	; 0x1d
    1b80:	f8 01       	movw	r30, r16
    1b82:	86 8d       	ldd	r24, Z+30	; 0x1e
    1b84:	8f 3f       	cpi	r24, 0xFF	; 255
    1b86:	09 f4       	brne	.+2      	; 0x1b8a <xQueueGenericSend+0xf4>
    1b88:	16 8e       	std	Z+30, r1	; 0x1e
    1b8a:	0f 90       	pop	r0
    1b8c:	0f be       	out	0x3f, r0	; 63

        /* Update the timeout state to see if it has expired yet. */
        if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
    1b8e:	c4 01       	movw	r24, r8
    1b90:	b3 01       	movw	r22, r6
    1b92:	0e 94 68 18 	call	0x30d0	; 0x30d0 <xTaskCheckForTimeOut>
    1b96:	88 23       	and	r24, r24
    1b98:	09 f5       	brne	.+66     	; 0x1bdc <xQueueGenericSend+0x146>

static BaseType_t prvIsQueueFull( const Queue_t * pxQueue )
{
    BaseType_t xReturn;

    taskENTER_CRITICAL();
    1b9a:	0f b6       	in	r0, 0x3f	; 63
    1b9c:	f8 94       	cli
    1b9e:	0f 92       	push	r0
    {
        if( pxQueue->uxMessagesWaiting == pxQueue->uxLength )
    1ba0:	f8 01       	movw	r30, r16
    1ba2:	92 8d       	ldd	r25, Z+26	; 0x1a
        else
        {
            xReturn = pdFALSE;
        }
    }
    taskEXIT_CRITICAL();
    1ba4:	0f 90       	pop	r0
    1ba6:	0f be       	out	0x3f, r0	; 63
        prvLockQueue( pxQueue );

        /* Update the timeout state to see if it has expired yet. */
        if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
        {
            if( prvIsQueueFull( pxQueue ) != pdFALSE )
    1ba8:	f8 01       	movw	r30, r16
    1baa:	83 8d       	ldd	r24, Z+27	; 0x1b
    1bac:	98 17       	cp	r25, r24
    1bae:	81 f4       	brne	.+32     	; 0x1bd0 <xQueueGenericSend+0x13a>
            {
                traceBLOCKING_ON_QUEUE_SEND( pxQueue );
                vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToSend ), xTicksToWait );
    1bb0:	6c 81       	ldd	r22, Y+4	; 0x04
    1bb2:	7d 81       	ldd	r23, Y+5	; 0x05
    1bb4:	c6 01       	movw	r24, r12
    1bb6:	0e 94 34 20 	call	0x4068	; 0x4068 <vTaskPlaceOnEventList>
                /* Unlocking the queue means queue events can effect the
                 * event list. It is possible that interrupts occurring now
                 * remove this task from the event list again - but as the
                 * scheduler is suspended the task will go onto the pending
                 * ready list instead of the actual ready list. */
                prvUnlockQueue( pxQueue );
    1bba:	c8 01       	movw	r24, r16
    1bbc:	0e 94 1d 0b 	call	0x163a	; 0x163a <prvUnlockQueue>
                /* Resuming the scheduler will move tasks from the pending
                 * ready list into the ready list - so it is feasible that this
                 * task is already in the ready list before it yields - in which
                 * case the yield will not cause a context switch unless there
                 * is also a higher priority task in the pending ready list. */
                if( xTaskResumeAll() == pdFALSE )
    1bc0:	0e 94 9b 1b 	call	0x3736	; 0x3736 <xTaskResumeAll>
    1bc4:	88 23       	and	r24, r24
    1bc6:	09 f0       	breq	.+2      	; 0x1bca <xQueueGenericSend+0x134>
    1bc8:	8e cf       	rjmp	.-228    	; 0x1ae6 <xQueueGenericSend+0x50>
                {
                    portYIELD_WITHIN_API();
    1bca:	0e 94 64 09 	call	0x12c8	; 0x12c8 <vPortYield>
    1bce:	8b cf       	rjmp	.-234    	; 0x1ae6 <xQueueGenericSend+0x50>
                }
            }
            else
            {
                /* Try again. */
                prvUnlockQueue( pxQueue );
    1bd0:	c8 01       	movw	r24, r16
    1bd2:	0e 94 1d 0b 	call	0x163a	; 0x163a <prvUnlockQueue>
                ( void ) xTaskResumeAll();
    1bd6:	0e 94 9b 1b 	call	0x3736	; 0x3736 <xTaskResumeAll>
    1bda:	85 cf       	rjmp	.-246    	; 0x1ae6 <xQueueGenericSend+0x50>
            }
        }
        else
        {
            /* The timeout has expired. */
            prvUnlockQueue( pxQueue );
    1bdc:	c8 01       	movw	r24, r16
    1bde:	0e 94 1d 0b 	call	0x163a	; 0x163a <prvUnlockQueue>
            ( void ) xTaskResumeAll();
    1be2:	0e 94 9b 1b 	call	0x3736	; 0x3736 <xTaskResumeAll>
    1be6:	80 e0       	ldi	r24, 0x00	; 0

            traceQUEUE_SEND_FAILED( pxQueue );
            return errQUEUE_FULL;
        }
    } /*lint -restore */
}
    1be8:	0f 90       	pop	r0
    1bea:	0f 90       	pop	r0
    1bec:	0f 90       	pop	r0
    1bee:	0f 90       	pop	r0
    1bf0:	0f 90       	pop	r0
    1bf2:	cf 91       	pop	r28
    1bf4:	df 91       	pop	r29
    1bf6:	1f 91       	pop	r17
    1bf8:	0f 91       	pop	r16
    1bfa:	ff 90       	pop	r15
    1bfc:	ef 90       	pop	r14
    1bfe:	df 90       	pop	r13
    1c00:	cf 90       	pop	r12
    1c02:	bf 90       	pop	r11
    1c04:	af 90       	pop	r10
    1c06:	9f 90       	pop	r9
    1c08:	8f 90       	pop	r8
    1c0a:	7f 90       	pop	r7
    1c0c:	6f 90       	pop	r6
    1c0e:	08 95       	ret

00001c10 <xQueueSemaphoreTake>:
}
/*-----------------------------------------------------------*/

BaseType_t xQueueSemaphoreTake( QueueHandle_t xQueue,
                                TickType_t xTicksToWait )
{
    1c10:	8f 92       	push	r8
    1c12:	9f 92       	push	r9
    1c14:	af 92       	push	r10
    1c16:	bf 92       	push	r11
    1c18:	df 92       	push	r13
    1c1a:	ef 92       	push	r14
    1c1c:	ff 92       	push	r15
    1c1e:	0f 93       	push	r16
    1c20:	1f 93       	push	r17
    1c22:	df 93       	push	r29
    1c24:	cf 93       	push	r28
    1c26:	00 d0       	rcall	.+0      	; 0x1c28 <xQueueSemaphoreTake+0x18>
    1c28:	00 d0       	rcall	.+0      	; 0x1c2a <xQueueSemaphoreTake+0x1a>
    1c2a:	0f 92       	push	r0
    1c2c:	cd b7       	in	r28, 0x3d	; 61
    1c2e:	de b7       	in	r29, 0x3e	; 62
    1c30:	8c 01       	movw	r16, r24
    1c32:	7d 83       	std	Y+5, r23	; 0x05
    1c34:	6c 83       	std	Y+4, r22	; 0x04
                        mtCOVERAGE_TEST_MARKER();
                    }
                }
                #endif /* if ( configUSE_MUTEXES == 1 ) */

                vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
    1c36:	a1 e1       	ldi	r26, 0x11	; 17
    1c38:	ea 2e       	mov	r14, r26
    1c3a:	f1 2c       	mov	r15, r1
    1c3c:	e8 0e       	add	r14, r24
    1c3e:	f9 1e       	adc	r15, r25
    1c40:	20 e0       	ldi	r18, 0x00	; 0
    1c42:	dd 24       	eor	r13, r13
                }
                else if( xEntryTimeSet == pdFALSE )
                {
                    /* The semaphore count was 0 and a block time was specified
                     * so configure the timeout structure ready to block. */
                    vTaskInternalSetTimeOutState( &xTimeOut );
    1c44:	5e 01       	movw	r10, r28
    1c46:	08 94       	sec
    1c48:	a1 1c       	adc	r10, r1
    1c4a:	b1 1c       	adc	r11, r1

        vTaskSuspendAll();
        prvLockQueue( pxQueue );

        /* Update the timeout state to see if it has expired yet. */
        if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
    1c4c:	f4 e0       	ldi	r31, 0x04	; 4
    1c4e:	8f 2e       	mov	r8, r31
    1c50:	91 2c       	mov	r9, r1
    1c52:	8c 0e       	add	r8, r28
    1c54:	9d 1e       	adc	r9, r29
    1c56:	01 c0       	rjmp	.+2      	; 0x1c5a <xQueueSemaphoreTake+0x4a>
                        mtCOVERAGE_TEST_MARKER();
                    }
                }
                #endif /* if ( configUSE_MUTEXES == 1 ) */

                vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
    1c58:	21 e0       	ldi	r18, 0x01	; 1
    /*lint -save -e904 This function relaxes the coding standard somewhat to allow return
     * statements within the function itself.  This is done in the interest
     * of execution time efficiency. */
    for( ; ; )
    {
        taskENTER_CRITICAL();
    1c5a:	0f b6       	in	r0, 0x3f	; 63
    1c5c:	f8 94       	cli
    1c5e:	0f 92       	push	r0
        {
            /* Semaphores are queues with an item size of 0, and where the
             * number of messages in the queue is the semaphore's count value. */
            const UBaseType_t uxSemaphoreCount = pxQueue->uxMessagesWaiting;
    1c60:	d8 01       	movw	r26, r16
    1c62:	5a 96       	adiw	r26, 0x1a	; 26
    1c64:	8c 91       	ld	r24, X
    1c66:	5a 97       	sbiw	r26, 0x1a	; 26

            /* Is there data in the queue now?  To be running the calling task
             * must be the highest priority task wanting to access the queue. */
            if( uxSemaphoreCount > ( UBaseType_t ) 0 )
    1c68:	88 23       	and	r24, r24
    1c6a:	f1 f0       	breq	.+60     	; 0x1ca8 <xQueueSemaphoreTake+0x98>
            {
                traceQUEUE_RECEIVE( pxQueue );

                /* Semaphores are queues with a data size of zero and where the
                 * messages waiting is the semaphore's count.  Reduce the count. */
                pxQueue->uxMessagesWaiting = uxSemaphoreCount - ( UBaseType_t ) 1;
    1c6c:	81 50       	subi	r24, 0x01	; 1
    1c6e:	5a 96       	adiw	r26, 0x1a	; 26
    1c70:	8c 93       	st	X, r24
    1c72:	5a 97       	sbiw	r26, 0x1a	; 26

                #if ( configUSE_MUTEXES == 1 )
                {
                    if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
    1c74:	8d 91       	ld	r24, X+
    1c76:	9c 91       	ld	r25, X
    1c78:	89 2b       	or	r24, r25
    1c7a:	29 f4       	brne	.+10     	; 0x1c86 <xQueueSemaphoreTake+0x76>
                    {
                        /* Record the information required to implement
                         * priority inheritance should it become necessary. */
                        pxQueue->u.xSemaphore.xMutexHolder = pvTaskIncrementMutexHeldCount();
    1c7c:	0e 94 c2 18 	call	0x3184	; 0x3184 <pvTaskIncrementMutexHeldCount>
    1c80:	f8 01       	movw	r30, r16
    1c82:	95 83       	std	Z+5, r25	; 0x05
    1c84:	84 83       	std	Z+4, r24	; 0x04
                }
                #endif /* configUSE_MUTEXES */

                /* Check to see if other tasks are blocked waiting to give the
                 * semaphore, and if so, unblock the highest priority such task. */
                if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    1c86:	d8 01       	movw	r26, r16
    1c88:	18 96       	adiw	r26, 0x08	; 8
    1c8a:	8c 91       	ld	r24, X
    1c8c:	88 23       	and	r24, r24
    1c8e:	41 f0       	breq	.+16     	; 0x1ca0 <xQueueSemaphoreTake+0x90>
                {
                    if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
    1c90:	c8 01       	movw	r24, r16
    1c92:	08 96       	adiw	r24, 0x08	; 8
    1c94:	0e 94 00 17 	call	0x2e00	; 0x2e00 <xTaskRemoveFromEventList>
    1c98:	88 23       	and	r24, r24
    1c9a:	11 f0       	breq	.+4      	; 0x1ca0 <xQueueSemaphoreTake+0x90>
                    {
                        queueYIELD_IF_USING_PREEMPTION();
    1c9c:	0e 94 64 09 	call	0x12c8	; 0x12c8 <vPortYield>
                else
                {
                    mtCOVERAGE_TEST_MARKER();
                }

                taskEXIT_CRITICAL();
    1ca0:	0f 90       	pop	r0
    1ca2:	0f be       	out	0x3f, r0	; 63
    1ca4:	81 e0       	ldi	r24, 0x01	; 1
    1ca6:	82 c0       	rjmp	.+260    	; 0x1dac <xQueueSemaphoreTake+0x19c>
                return pdPASS;
            }
            else
            {
                if( xTicksToWait == ( TickType_t ) 0 )
    1ca8:	8c 81       	ldd	r24, Y+4	; 0x04
    1caa:	9d 81       	ldd	r25, Y+5	; 0x05
    1cac:	89 2b       	or	r24, r25
    1cae:	19 f4       	brne	.+6      	; 0x1cb6 <xQueueSemaphoreTake+0xa6>
                {
                    /* The semaphore count was 0 and no block time is specified
                     * (or the block time has expired) so exit now. */
                    taskEXIT_CRITICAL();
    1cb0:	0f 90       	pop	r0
    1cb2:	0f be       	out	0x3f, r0	; 63
    1cb4:	7a c0       	rjmp	.+244    	; 0x1daa <xQueueSemaphoreTake+0x19a>
                    traceQUEUE_RECEIVE_FAILED( pxQueue );
                    return errQUEUE_EMPTY;
                }
                else if( xEntryTimeSet == pdFALSE )
    1cb6:	22 23       	and	r18, r18
    1cb8:	19 f4       	brne	.+6      	; 0x1cc0 <xQueueSemaphoreTake+0xb0>
                {
                    /* The semaphore count was 0 and a block time was specified
                     * so configure the timeout structure ready to block. */
                    vTaskInternalSetTimeOutState( &xTimeOut );
    1cba:	c5 01       	movw	r24, r10
    1cbc:	0e 94 5d 18 	call	0x30ba	; 0x30ba <vTaskInternalSetTimeOutState>
                    /* Entry time was already set. */
                    mtCOVERAGE_TEST_MARKER();
                }
            }
        }
        taskEXIT_CRITICAL();
    1cc0:	0f 90       	pop	r0
    1cc2:	0f be       	out	0x3f, r0	; 63

        /* Interrupts and other tasks can give to and take from the semaphore
         * now the critical section has been exited. */

        vTaskSuspendAll();
    1cc4:	0e 94 89 15 	call	0x2b12	; 0x2b12 <vTaskSuspendAll>
        prvLockQueue( pxQueue );
    1cc8:	0f b6       	in	r0, 0x3f	; 63
    1cca:	f8 94       	cli
    1ccc:	0f 92       	push	r0
    1cce:	f8 01       	movw	r30, r16
    1cd0:	85 8d       	ldd	r24, Z+29	; 0x1d
    1cd2:	8f 3f       	cpi	r24, 0xFF	; 255
    1cd4:	09 f4       	brne	.+2      	; 0x1cd8 <xQueueSemaphoreTake+0xc8>
    1cd6:	15 8e       	std	Z+29, r1	; 0x1d
    1cd8:	d8 01       	movw	r26, r16
    1cda:	5e 96       	adiw	r26, 0x1e	; 30
    1cdc:	8c 91       	ld	r24, X
    1cde:	5e 97       	sbiw	r26, 0x1e	; 30
    1ce0:	8f 3f       	cpi	r24, 0xFF	; 255
    1ce2:	11 f4       	brne	.+4      	; 0x1ce8 <xQueueSemaphoreTake+0xd8>
    1ce4:	5e 96       	adiw	r26, 0x1e	; 30
    1ce6:	1c 92       	st	X, r1
    1ce8:	0f 90       	pop	r0
    1cea:	0f be       	out	0x3f, r0	; 63

        /* Update the timeout state to see if it has expired yet. */
        if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
    1cec:	c5 01       	movw	r24, r10
    1cee:	b4 01       	movw	r22, r8
    1cf0:	0e 94 68 18 	call	0x30d0	; 0x30d0 <xTaskCheckForTimeOut>
    1cf4:	88 23       	and	r24, r24
    1cf6:	79 f5       	brne	.+94     	; 0x1d56 <xQueueSemaphoreTake+0x146>

static BaseType_t prvIsQueueEmpty( const Queue_t * pxQueue )
{
    BaseType_t xReturn;

    taskENTER_CRITICAL();
    1cf8:	0f b6       	in	r0, 0x3f	; 63
    1cfa:	f8 94       	cli
    1cfc:	0f 92       	push	r0
    {
        if( pxQueue->uxMessagesWaiting == ( UBaseType_t ) 0 )
    1cfe:	f8 01       	movw	r30, r16
    1d00:	82 8d       	ldd	r24, Z+26	; 0x1a
        else
        {
            xReturn = pdFALSE;
        }
    }
    taskEXIT_CRITICAL();
    1d02:	0f 90       	pop	r0
    1d04:	0f be       	out	0x3f, r0	; 63
        {
            /* A block time is specified and not expired.  If the semaphore
             * count is 0 then enter the Blocked state to wait for a semaphore to
             * become available.  As semaphores are implemented with queues the
             * queue being empty is equivalent to the semaphore count being 0. */
            if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
    1d06:	88 23       	and	r24, r24
    1d08:	01 f5       	brne	.+64     	; 0x1d4a <xQueueSemaphoreTake+0x13a>
            {
                traceBLOCKING_ON_QUEUE_RECEIVE( pxQueue );

                #if ( configUSE_MUTEXES == 1 )
                {
                    if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
    1d0a:	d8 01       	movw	r26, r16
    1d0c:	8d 91       	ld	r24, X+
    1d0e:	9c 91       	ld	r25, X
    1d10:	89 2b       	or	r24, r25
    1d12:	59 f4       	brne	.+22     	; 0x1d2a <xQueueSemaphoreTake+0x11a>
                    {
                        taskENTER_CRITICAL();
    1d14:	0f b6       	in	r0, 0x3f	; 63
    1d16:	f8 94       	cli
    1d18:	0f 92       	push	r0
                        {
                            xInheritanceOccurred = xTaskPriorityInherit( pxQueue->u.xSemaphore.xMutexHolder );
    1d1a:	f8 01       	movw	r30, r16
    1d1c:	84 81       	ldd	r24, Z+4	; 0x04
    1d1e:	95 81       	ldd	r25, Z+5	; 0x05
    1d20:	0e 94 53 1d 	call	0x3aa6	; 0x3aa6 <xTaskPriorityInherit>
    1d24:	d8 2e       	mov	r13, r24
                        }
                        taskEXIT_CRITICAL();
    1d26:	0f 90       	pop	r0
    1d28:	0f be       	out	0x3f, r0	; 63
                        mtCOVERAGE_TEST_MARKER();
                    }
                }
                #endif /* if ( configUSE_MUTEXES == 1 ) */

                vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
    1d2a:	6c 81       	ldd	r22, Y+4	; 0x04
    1d2c:	7d 81       	ldd	r23, Y+5	; 0x05
    1d2e:	c7 01       	movw	r24, r14
    1d30:	0e 94 34 20 	call	0x4068	; 0x4068 <vTaskPlaceOnEventList>
                prvUnlockQueue( pxQueue );
    1d34:	c8 01       	movw	r24, r16
    1d36:	0e 94 1d 0b 	call	0x163a	; 0x163a <prvUnlockQueue>

                if( xTaskResumeAll() == pdFALSE )
    1d3a:	0e 94 9b 1b 	call	0x3736	; 0x3736 <xTaskResumeAll>
    1d3e:	88 23       	and	r24, r24
    1d40:	09 f0       	breq	.+2      	; 0x1d44 <xQueueSemaphoreTake+0x134>
    1d42:	8a cf       	rjmp	.-236    	; 0x1c58 <xQueueSemaphoreTake+0x48>
                {
                    portYIELD_WITHIN_API();
    1d44:	0e 94 64 09 	call	0x12c8	; 0x12c8 <vPortYield>
    1d48:	87 cf       	rjmp	.-242    	; 0x1c58 <xQueueSemaphoreTake+0x48>
            }
            else
            {
                /* There was no timeout and the semaphore count was not 0, so
                 * attempt to take the semaphore again. */
                prvUnlockQueue( pxQueue );
    1d4a:	c8 01       	movw	r24, r16
    1d4c:	0e 94 1d 0b 	call	0x163a	; 0x163a <prvUnlockQueue>
                ( void ) xTaskResumeAll();
    1d50:	0e 94 9b 1b 	call	0x3736	; 0x3736 <xTaskResumeAll>
    1d54:	81 cf       	rjmp	.-254    	; 0x1c58 <xQueueSemaphoreTake+0x48>
            }
        }
        else
        {
            /* Timed out. */
            prvUnlockQueue( pxQueue );
    1d56:	c8 01       	movw	r24, r16
    1d58:	0e 94 1d 0b 	call	0x163a	; 0x163a <prvUnlockQueue>
            ( void ) xTaskResumeAll();
    1d5c:	0e 94 9b 1b 	call	0x3736	; 0x3736 <xTaskResumeAll>

static BaseType_t prvIsQueueEmpty( const Queue_t * pxQueue )
{
    BaseType_t xReturn;

    taskENTER_CRITICAL();
    1d60:	0f b6       	in	r0, 0x3f	; 63
    1d62:	f8 94       	cli
    1d64:	0f 92       	push	r0
    {
        if( pxQueue->uxMessagesWaiting == ( UBaseType_t ) 0 )
    1d66:	d8 01       	movw	r26, r16
    1d68:	5a 96       	adiw	r26, 0x1a	; 26
    1d6a:	8c 91       	ld	r24, X
        else
        {
            xReturn = pdFALSE;
        }
    }
    taskEXIT_CRITICAL();
    1d6c:	0f 90       	pop	r0
    1d6e:	0f be       	out	0x3f, r0	; 63

            /* If the semaphore count is 0 exit now as the timeout has
             * expired.  Otherwise return to attempt to take the semaphore that is
             * known to be available.  As semaphores are implemented by queues the
             * queue being empty is equivalent to the semaphore count being 0. */
            if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
    1d70:	88 23       	and	r24, r24
    1d72:	09 f0       	breq	.+2      	; 0x1d76 <xQueueSemaphoreTake+0x166>
    1d74:	71 cf       	rjmp	.-286    	; 0x1c58 <xQueueSemaphoreTake+0x48>
                #if ( configUSE_MUTEXES == 1 )
                {
                    /* xInheritanceOccurred could only have be set if
                     * pxQueue->uxQueueType == queueQUEUE_IS_MUTEX so no need to
                     * test the mutex type again to check it is actually a mutex. */
                    if( xInheritanceOccurred != pdFALSE )
    1d76:	dd 20       	and	r13, r13
    1d78:	c9 f0       	breq	.+50     	; 0x1dac <xQueueSemaphoreTake+0x19c>
                    {
                        taskENTER_CRITICAL();
    1d7a:	0f b6       	in	r0, 0x3f	; 63
    1d7c:	f8 94       	cli
    1d7e:	0f 92       	push	r0
         * priority, but the waiting task times out, then the holder should
         * disinherit the priority - but only down to the highest priority of any
         * other tasks that are waiting for the same mutex.  For this purpose,
         * return the priority of the highest priority task that is waiting for the
         * mutex. */
        if( listCURRENT_LIST_LENGTH( &( pxQueue->xTasksWaitingToReceive ) ) > 0U )
    1d80:	f8 01       	movw	r30, r16
    1d82:	81 89       	ldd	r24, Z+17	; 0x11
    1d84:	88 23       	and	r24, r24
    1d86:	11 f4       	brne	.+4      	; 0x1d8c <xQueueSemaphoreTake+0x17c>
    1d88:	60 e0       	ldi	r22, 0x00	; 0
    1d8a:	08 c0       	rjmp	.+16     	; 0x1d9c <xQueueSemaphoreTake+0x18c>
        {
            uxHighestPriorityOfWaitingTasks = ( UBaseType_t ) configMAX_PRIORITIES - ( UBaseType_t ) listGET_ITEM_VALUE_OF_HEAD_ENTRY( &( pxQueue->xTasksWaitingToReceive ) );
    1d8c:	d8 01       	movw	r26, r16
    1d8e:	56 96       	adiw	r26, 0x16	; 22
    1d90:	ed 91       	ld	r30, X+
    1d92:	fc 91       	ld	r31, X
    1d94:	57 97       	sbiw	r26, 0x17	; 23
    1d96:	64 e0       	ldi	r22, 0x04	; 4
    1d98:	80 81       	ld	r24, Z
    1d9a:	68 1b       	sub	r22, r24
                             * task to inherit this task's priority.  Now this task
                             * has timed out the priority should be disinherited
                             * again, but only as low as the next highest priority
                             * task that is waiting for the same mutex. */
                            uxHighestWaitingPriority = prvGetDisinheritPriorityAfterTimeout( pxQueue );
                            vTaskPriorityDisinheritAfterTimeout( pxQueue->u.xSemaphore.xMutexHolder, uxHighestWaitingPriority );
    1d9c:	f8 01       	movw	r30, r16
    1d9e:	84 81       	ldd	r24, Z+4	; 0x04
    1da0:	95 81       	ldd	r25, Z+5	; 0x05
    1da2:	0e 94 90 1c 	call	0x3920	; 0x3920 <vTaskPriorityDisinheritAfterTimeout>
                        }
                        taskEXIT_CRITICAL();
    1da6:	0f 90       	pop	r0
    1da8:	0f be       	out	0x3f, r0	; 63
    1daa:	80 e0       	ldi	r24, 0x00	; 0
            {
                mtCOVERAGE_TEST_MARKER();
            }
        }
    } /*lint -restore */
}
    1dac:	0f 90       	pop	r0
    1dae:	0f 90       	pop	r0
    1db0:	0f 90       	pop	r0
    1db2:	0f 90       	pop	r0
    1db4:	0f 90       	pop	r0
    1db6:	cf 91       	pop	r28
    1db8:	df 91       	pop	r29
    1dba:	1f 91       	pop	r17
    1dbc:	0f 91       	pop	r16
    1dbe:	ff 90       	pop	r15
    1dc0:	ef 90       	pop	r14
    1dc2:	df 90       	pop	r13
    1dc4:	bf 90       	pop	r11
    1dc6:	af 90       	pop	r10
    1dc8:	9f 90       	pop	r9
    1dca:	8f 90       	pop	r8
    1dcc:	08 95       	ret

00001dce <xQueueGenericReset>:
    }
/*-----------------------------------------------------------*/

BaseType_t xQueueGenericReset( QueueHandle_t xQueue,
                               BaseType_t xNewQueue )
{
    1dce:	cf 93       	push	r28
    1dd0:	df 93       	push	r29
    1dd2:	ec 01       	movw	r28, r24
    1dd4:	e6 2f       	mov	r30, r22
    BaseType_t xReturn = pdPASS;
    Queue_t * const pxQueue = xQueue;

    configASSERT( pxQueue );

    if( ( pxQueue != NULL ) &&
    1dd6:	00 97       	sbiw	r24, 0x00	; 0
    1dd8:	09 f4       	brne	.+2      	; 0x1ddc <xQueueGenericReset+0xe>
    1dda:	4f c0       	rjmp	.+158    	; 0x1e7a <xQueueGenericReset+0xac>
    1ddc:	2b 8d       	ldd	r18, Y+27	; 0x1b
    1dde:	22 23       	and	r18, r18
    1de0:	09 f4       	brne	.+2      	; 0x1de4 <xQueueGenericReset+0x16>
    1de2:	4b c0       	rjmp	.+150    	; 0x1e7a <xQueueGenericReset+0xac>
    1de4:	3c 8d       	ldd	r19, Y+28	; 0x1c
    1de6:	8f ef       	ldi	r24, 0xFF	; 255
    1de8:	9f e7       	ldi	r25, 0x7F	; 127
    1dea:	62 2f       	mov	r22, r18
    1dec:	70 e0       	ldi	r23, 0x00	; 0
    1dee:	0e 94 1f 26 	call	0x4c3e	; 0x4c3e <__udivmodhi4>
    1df2:	83 2f       	mov	r24, r19
    1df4:	90 e0       	ldi	r25, 0x00	; 0
    1df6:	68 17       	cp	r22, r24
    1df8:	79 07       	cpc	r23, r25
    1dfa:	08 f4       	brcc	.+2      	; 0x1dfe <xQueueGenericReset+0x30>
    1dfc:	3e c0       	rjmp	.+124    	; 0x1e7a <xQueueGenericReset+0xac>
        ( pxQueue->uxLength >= 1U ) &&
        /* Check for multiplication overflow. */
        ( ( SIZE_MAX / pxQueue->uxLength ) >= pxQueue->uxItemSize ) )
    {
        taskENTER_CRITICAL();
    1dfe:	0f b6       	in	r0, 0x3f	; 63
    1e00:	f8 94       	cli
    1e02:	0f 92       	push	r0
        {
            pxQueue->u.xQueue.pcTail = pxQueue->pcHead + ( pxQueue->uxLength * pxQueue->uxItemSize ); /*lint !e9016 Pointer arithmetic allowed on char types, especially when it assists conveying intent. */
    1e04:	32 9f       	mul	r19, r18
    1e06:	c0 01       	movw	r24, r0
    1e08:	11 24       	eor	r1, r1
    1e0a:	48 81       	ld	r20, Y
    1e0c:	59 81       	ldd	r21, Y+1	; 0x01
    1e0e:	84 0f       	add	r24, r20
    1e10:	95 1f       	adc	r25, r21
    1e12:	9d 83       	std	Y+5, r25	; 0x05
    1e14:	8c 83       	std	Y+4, r24	; 0x04
            pxQueue->uxMessagesWaiting = ( UBaseType_t ) 0U;
    1e16:	1a 8e       	std	Y+26, r1	; 0x1a
            pxQueue->pcWriteTo = pxQueue->pcHead;
    1e18:	5b 83       	std	Y+3, r21	; 0x03
    1e1a:	4a 83       	std	Y+2, r20	; 0x02
            pxQueue->u.xQueue.pcReadFrom = pxQueue->pcHead + ( ( pxQueue->uxLength - 1U ) * pxQueue->uxItemSize ); /*lint !e9016 Pointer arithmetic allowed on char types, especially when it assists conveying intent. */
    1e1c:	2b 8d       	ldd	r18, Y+27	; 0x1b
    1e1e:	30 e0       	ldi	r19, 0x00	; 0
    1e20:	21 50       	subi	r18, 0x01	; 1
    1e22:	30 40       	sbci	r19, 0x00	; 0
    1e24:	8c 8d       	ldd	r24, Y+28	; 0x1c
    1e26:	90 e0       	ldi	r25, 0x00	; 0
    1e28:	bc 01       	movw	r22, r24
    1e2a:	26 9f       	mul	r18, r22
    1e2c:	c0 01       	movw	r24, r0
    1e2e:	27 9f       	mul	r18, r23
    1e30:	90 0d       	add	r25, r0
    1e32:	36 9f       	mul	r19, r22
    1e34:	90 0d       	add	r25, r0
    1e36:	11 24       	eor	r1, r1
    1e38:	48 0f       	add	r20, r24
    1e3a:	59 1f       	adc	r21, r25
    1e3c:	5f 83       	std	Y+7, r21	; 0x07
    1e3e:	4e 83       	std	Y+6, r20	; 0x06
            pxQueue->cRxLock = queueUNLOCKED;
    1e40:	8f ef       	ldi	r24, 0xFF	; 255
    1e42:	8d 8f       	std	Y+29, r24	; 0x1d
            pxQueue->cTxLock = queueUNLOCKED;
    1e44:	8e 8f       	std	Y+30, r24	; 0x1e

            if( xNewQueue == pdFALSE )
    1e46:	ee 23       	and	r30, r30
    1e48:	61 f4       	brne	.+24     	; 0x1e62 <xQueueGenericReset+0x94>
                /* If there are tasks blocked waiting to read from the queue, then
                 * the tasks will remain blocked as after this function exits the queue
                 * will still be empty.  If there are tasks blocked waiting to write to
                 * the queue, then one should be unblocked as after this function exits
                 * it will be possible to write to it. */
                if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    1e4a:	88 85       	ldd	r24, Y+8	; 0x08
    1e4c:	88 23       	and	r24, r24
    1e4e:	89 f0       	breq	.+34     	; 0x1e72 <xQueueGenericReset+0xa4>
                {
                    if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
    1e50:	ce 01       	movw	r24, r28
    1e52:	08 96       	adiw	r24, 0x08	; 8
    1e54:	0e 94 00 17 	call	0x2e00	; 0x2e00 <xTaskRemoveFromEventList>
    1e58:	88 23       	and	r24, r24
    1e5a:	59 f0       	breq	.+22     	; 0x1e72 <xQueueGenericReset+0xa4>
                    {
                        queueYIELD_IF_USING_PREEMPTION();
    1e5c:	0e 94 64 09 	call	0x12c8	; 0x12c8 <vPortYield>
    1e60:	08 c0       	rjmp	.+16     	; 0x1e72 <xQueueGenericReset+0xa4>
                }
            }
            else
            {
                /* Ensure the event queues start in the correct state. */
                vListInitialise( &( pxQueue->xTasksWaitingToSend ) );
    1e62:	ce 01       	movw	r24, r28
    1e64:	08 96       	adiw	r24, 0x08	; 8
    1e66:	0e 94 f6 07 	call	0xfec	; 0xfec <vListInitialise>
                vListInitialise( &( pxQueue->xTasksWaitingToReceive ) );
    1e6a:	ce 01       	movw	r24, r28
    1e6c:	41 96       	adiw	r24, 0x11	; 17
    1e6e:	0e 94 f6 07 	call	0xfec	; 0xfec <vListInitialise>
            }
        }
        taskEXIT_CRITICAL();
    1e72:	0f 90       	pop	r0
    1e74:	0f be       	out	0x3f, r0	; 63
    1e76:	81 e0       	ldi	r24, 0x01	; 1
    1e78:	01 c0       	rjmp	.+2      	; 0x1e7c <xQueueGenericReset+0xae>
    BaseType_t xReturn = pdPASS;
    Queue_t * const pxQueue = xQueue;

    configASSERT( pxQueue );

    if( ( pxQueue != NULL ) &&
    1e7a:	80 e0       	ldi	r24, 0x00	; 0
    configASSERT( xReturn != pdFAIL );

    /* A value is returned for calling semantic consistency with previous
     * versions. */
    return xReturn;
}
    1e7c:	df 91       	pop	r29
    1e7e:	cf 91       	pop	r28
    1e80:	08 95       	ret

00001e82 <xQueueGenericCreate>:
#if ( configSUPPORT_DYNAMIC_ALLOCATION == 1 )

    QueueHandle_t xQueueGenericCreate( const UBaseType_t uxQueueLength,
                                       const UBaseType_t uxItemSize,
                                       const uint8_t ucQueueType )
    {
    1e82:	ef 92       	push	r14
    1e84:	ff 92       	push	r15
    1e86:	0f 93       	push	r16
    1e88:	1f 93       	push	r17
    1e8a:	cf 93       	push	r28
    1e8c:	df 93       	push	r29
    1e8e:	f8 2e       	mov	r15, r24
    1e90:	e6 2e       	mov	r14, r22
        Queue_t * pxNewQueue = NULL;
        size_t xQueueSizeInBytes;
        uint8_t * pucQueueStorage;

        if( ( uxQueueLength > ( UBaseType_t ) 0 ) &&
    1e92:	88 23       	and	r24, r24
    1e94:	51 f1       	breq	.+84     	; 0x1eea <xQueueGenericCreate+0x68>
    1e96:	8f ef       	ldi	r24, 0xFF	; 255
    1e98:	9f e7       	ldi	r25, 0x7F	; 127
    1e9a:	6f 2d       	mov	r22, r15
    1e9c:	70 e0       	ldi	r23, 0x00	; 0
    1e9e:	0e 94 1f 26 	call	0x4c3e	; 0x4c3e <__udivmodhi4>
    1ea2:	8e 2d       	mov	r24, r14
    1ea4:	90 e0       	ldi	r25, 0x00	; 0
    1ea6:	68 17       	cp	r22, r24
    1ea8:	79 07       	cpc	r23, r25
    1eaa:	f8 f0       	brcs	.+62     	; 0x1eea <xQueueGenericCreate+0x68>
    1eac:	ef 9c       	mul	r14, r15
    1eae:	c0 01       	movw	r24, r0
    1eb0:	11 24       	eor	r1, r1
    1eb2:	2f e7       	ldi	r18, 0x7F	; 127
    1eb4:	8f 3d       	cpi	r24, 0xDF	; 223
    1eb6:	92 07       	cpc	r25, r18
    1eb8:	c0 f4       	brcc	.+48     	; 0x1eea <xQueueGenericCreate+0x68>
             * alignment requirements of the Queue_t structure - which in this case
             * is an int8_t *.  Therefore, whenever the stack alignment requirements
             * are greater than or equal to the pointer to char requirements the cast
             * is safe.  In other cases alignment requirements are not strict (one or
             * two bytes). */
            pxNewQueue = ( Queue_t * ) pvPortMalloc( sizeof( Queue_t ) + xQueueSizeInBytes ); /*lint !e9087 !e9079 see comment above. */
    1eba:	81 96       	adiw	r24, 0x21	; 33
    1ebc:	0e 94 c2 07 	call	0xf84	; 0xf84 <pvPortMalloc>
    1ec0:	ec 01       	movw	r28, r24
    1ec2:	8c 01       	movw	r16, r24

            if( pxNewQueue != NULL )
    1ec4:	00 97       	sbiw	r24, 0x00	; 0
    1ec6:	99 f0       	breq	.+38     	; 0x1eee <xQueueGenericCreate+0x6c>
{
    /* Remove compiler warnings about unused parameters should
     * configUSE_TRACE_FACILITY not be set to 1. */
    ( void ) ucQueueType;

    if( uxItemSize == ( UBaseType_t ) 0 )
    1ec8:	ee 20       	and	r14, r14
    1eca:	19 f4       	brne	.+6      	; 0x1ed2 <xQueueGenericCreate+0x50>
    {
        /* No RAM was allocated for the queue storage area, but PC head cannot
         * be set to NULL because NULL is used as a key to say the queue is used as
         * a mutex.  Therefore just set pcHead to point to the queue as a benign
         * value that is known to be within the memory map. */
        pxNewQueue->pcHead = ( int8_t * ) pxNewQueue;
    1ecc:	99 83       	std	Y+1, r25	; 0x01
    1ece:	88 83       	st	Y, r24
    1ed0:	03 c0       	rjmp	.+6      	; 0x1ed8 <xQueueGenericCreate+0x56>
    }
    else
    {
        /* Set the head to the start of the queue storage area. */
        pxNewQueue->pcHead = ( int8_t * ) pucQueueStorage;
    1ed2:	81 96       	adiw	r24, 0x21	; 33
    1ed4:	99 83       	std	Y+1, r25	; 0x01
    1ed6:	88 83       	st	Y, r24
    }

    /* Initialise the queue members as described where the queue type is
     * defined. */
    pxNewQueue->uxLength = uxQueueLength;
    1ed8:	fb 8e       	std	Y+27, r15	; 0x1b
    pxNewQueue->uxItemSize = uxItemSize;
    1eda:	ec 8e       	std	Y+28, r14	; 0x1c
    ( void ) xQueueGenericReset( pxNewQueue, pdTRUE );
    1edc:	ce 01       	movw	r24, r28
    1ede:	61 e0       	ldi	r22, 0x01	; 1
    1ee0:	0e 94 e7 0e 	call	0x1dce	; 0x1dce <xQueueGenericReset>
    }
    #endif /* configUSE_TRACE_FACILITY */

    #if ( configUSE_QUEUE_SETS == 1 )
    {
        pxNewQueue->pxQueueSetContainer = NULL;
    1ee4:	18 a2       	std	Y+32, r1	; 0x20
    1ee6:	1f 8e       	std	Y+31, r1	; 0x1f
    1ee8:	02 c0       	rjmp	.+4      	; 0x1eee <xQueueGenericCreate+0x6c>
    1eea:	00 e0       	ldi	r16, 0x00	; 0
    1eec:	10 e0       	ldi	r17, 0x00	; 0
            configASSERT( pxNewQueue );
            mtCOVERAGE_TEST_MARKER();
        }

        return pxNewQueue;
    }
    1eee:	c8 01       	movw	r24, r16
    1ef0:	df 91       	pop	r29
    1ef2:	cf 91       	pop	r28
    1ef4:	1f 91       	pop	r17
    1ef6:	0f 91       	pop	r16
    1ef8:	ff 90       	pop	r15
    1efa:	ef 90       	pop	r14
    1efc:	08 95       	ret

00001efe <xQueueCreateSet>:

    QueueSetHandle_t xQueueCreateSet( const UBaseType_t uxEventQueueLength )
    {
        QueueSetHandle_t pxQueue;

        pxQueue = xQueueGenericCreate( uxEventQueueLength, ( UBaseType_t ) sizeof( Queue_t * ), queueQUEUE_TYPE_SET );
    1efe:	62 e0       	ldi	r22, 0x02	; 2
    1f00:	40 e0       	ldi	r20, 0x00	; 0
    1f02:	0e 94 41 0f 	call	0x1e82	; 0x1e82 <xQueueGenericCreate>

        return pxQueue;
    }
    1f06:	08 95       	ret

00001f08 <xQueueCreateMutex>:
/*-----------------------------------------------------------*/

#if ( ( configUSE_MUTEXES == 1 ) && ( configSUPPORT_DYNAMIC_ALLOCATION == 1 ) )

    QueueHandle_t xQueueCreateMutex( const uint8_t ucQueueType )
    {
    1f08:	cf 93       	push	r28
    1f0a:	df 93       	push	r29
    1f0c:	48 2f       	mov	r20, r24
        QueueHandle_t xNewQueue;
        const UBaseType_t uxMutexLength = ( UBaseType_t ) 1, uxMutexSize = ( UBaseType_t ) 0;

        xNewQueue = xQueueGenericCreate( uxMutexLength, uxMutexSize, ucQueueType );
    1f0e:	81 e0       	ldi	r24, 0x01	; 1
    1f10:	60 e0       	ldi	r22, 0x00	; 0
    1f12:	0e 94 41 0f 	call	0x1e82	; 0x1e82 <xQueueGenericCreate>
    1f16:	ec 01       	movw	r28, r24

#if ( configUSE_MUTEXES == 1 )

    static void prvInitialiseMutex( Queue_t * pxNewQueue )
    {
        if( pxNewQueue != NULL )
    1f18:	00 97       	sbiw	r24, 0x00	; 0
    1f1a:	61 f0       	breq	.+24     	; 0x1f34 <xQueueCreateMutex+0x2c>
        {
            /* The queue create function will set all the queue structure members
            * correctly for a generic queue, but this function is creating a
            * mutex.  Overwrite those members that need to be set differently -
            * in particular the information required for priority inheritance. */
            pxNewQueue->u.xSemaphore.xMutexHolder = NULL;
    1f1c:	1d 82       	std	Y+5, r1	; 0x05
    1f1e:	1c 82       	std	Y+4, r1	; 0x04
            pxNewQueue->uxQueueType = queueQUEUE_IS_MUTEX;
    1f20:	19 82       	std	Y+1, r1	; 0x01
    1f22:	18 82       	st	Y, r1

            /* In case this is a recursive mutex. */
            pxNewQueue->u.xSemaphore.uxRecursiveCallCount = 0;
    1f24:	1e 82       	std	Y+6, r1	; 0x06

            traceCREATE_MUTEX( pxNewQueue );

            /* Start with the semaphore in the expected state. */
            ( void ) xQueueGenericSend( pxNewQueue, NULL, ( TickType_t ) 0U, queueSEND_TO_BACK );
    1f26:	60 e0       	ldi	r22, 0x00	; 0
    1f28:	70 e0       	ldi	r23, 0x00	; 0
    1f2a:	40 e0       	ldi	r20, 0x00	; 0
    1f2c:	50 e0       	ldi	r21, 0x00	; 0
    1f2e:	20 e0       	ldi	r18, 0x00	; 0
    1f30:	0e 94 4b 0d 	call	0x1a96	; 0x1a96 <xQueueGenericSend>

        xNewQueue = xQueueGenericCreate( uxMutexLength, uxMutexSize, ucQueueType );
        prvInitialiseMutex( ( Queue_t * ) xNewQueue );

        return xNewQueue;
    }
    1f34:	ce 01       	movw	r24, r28
    1f36:	df 91       	pop	r29
    1f38:	cf 91       	pop	r28
    1f3a:	08 95       	ret

00001f3c <xAreRegTestTasksStillRunning>:
	xTaskCreate( prvRegisterCheck2, "Reg2", configMINIMAL_STACK_SIZE, NULL, tskIDLE_PRIORITY, NULL );
}
/*-----------------------------------------------------------*/

portBASE_TYPE xAreRegTestTasksStillRunning( void )
{
    1f3c:	90 e0       	ldi	r25, 0x00	; 0
    1f3e:	80 91 f6 06 	lds	r24, 0x06F6
    1f42:	88 23       	and	r24, r24
    1f44:	09 f4       	brne	.+2      	; 0x1f48 <xAreRegTestTasksStillRunning+0xc>
    1f46:	91 e0       	ldi	r25, 0x01	; 1
	{
		xReturn = pdFALSE;
	}

	return xReturn;
}
    1f48:	89 2f       	mov	r24, r25
    1f4a:	08 95       	ret

00001f4c <prvRegisterCheck1>:
{
	( void ) pvParameters;

	for( ;; )
	{
		asm(	"LDI	r31,	5"		);
    1f4c:	f5 e0       	ldi	r31, 0x05	; 5
		asm( 	"MOV	r0,		r31"	);
    1f4e:	0f 2e       	mov	r0, r31
		asm(	"LDI	r31,	6"		);
    1f50:	f6 e0       	ldi	r31, 0x06	; 6
		asm( 	"MOV	r1,		r31"	);
    1f52:	1f 2e       	mov	r1, r31
		asm(	"LDI	r31,	7"		);
    1f54:	f7 e0       	ldi	r31, 0x07	; 7
		asm( 	"MOV	r2,		r31"	);
    1f56:	2f 2e       	mov	r2, r31
		asm(	"LDI	r31,	8"		);
    1f58:	f8 e0       	ldi	r31, 0x08	; 8
		asm( 	"MOV	r3,		r31"	);
    1f5a:	3f 2e       	mov	r3, r31
		asm(	"LDI	r31,	9"		);
    1f5c:	f9 e0       	ldi	r31, 0x09	; 9
		asm( 	"MOV	r4,		r31"	);
    1f5e:	4f 2e       	mov	r4, r31
		asm(	"LDI	r31,	10"		);
    1f60:	fa e0       	ldi	r31, 0x0A	; 10
		asm( 	"MOV	r5,		r31"	);
    1f62:	5f 2e       	mov	r5, r31
		asm(	"LDI	r31,	11"		);
    1f64:	fb e0       	ldi	r31, 0x0B	; 11
		asm( 	"MOV	r6,		r31"	);
    1f66:	6f 2e       	mov	r6, r31
		asm(	"LDI	r31,	12"		);
    1f68:	fc e0       	ldi	r31, 0x0C	; 12
		asm( 	"MOV	r7,		r31"	);
    1f6a:	7f 2e       	mov	r7, r31
		asm(	"LDI	r31,	13"		);
    1f6c:	fd e0       	ldi	r31, 0x0D	; 13
		asm( 	"MOV	r8,		r31"	);
    1f6e:	8f 2e       	mov	r8, r31
		asm(	"LDI	r31,	14"		);
    1f70:	fe e0       	ldi	r31, 0x0E	; 14
		asm( 	"MOV	r9,		r31"	);
    1f72:	9f 2e       	mov	r9, r31
		asm(	"LDI	r31,	15"		);
    1f74:	ff e0       	ldi	r31, 0x0F	; 15
		asm( 	"MOV	r10,	r31"	);
    1f76:	af 2e       	mov	r10, r31
		asm(	"LDI	r31,	16"		);
    1f78:	f0 e1       	ldi	r31, 0x10	; 16
		asm( 	"MOV	r11,	r31"	);
    1f7a:	bf 2e       	mov	r11, r31
		asm(	"LDI	r31,	17"		);
    1f7c:	f1 e1       	ldi	r31, 0x11	; 17
		asm( 	"MOV	r12,	r31"	);
    1f7e:	cf 2e       	mov	r12, r31
		asm(	"LDI	r31,	18"		);
    1f80:	f2 e1       	ldi	r31, 0x12	; 18
		asm( 	"MOV	r13,	r31"	);
    1f82:	df 2e       	mov	r13, r31
		asm(	"LDI	r31,	19"		);
    1f84:	f3 e1       	ldi	r31, 0x13	; 19
		asm( 	"MOV	r14,	r31"	);
    1f86:	ef 2e       	mov	r14, r31
		asm(	"LDI	r31,	20"		);
    1f88:	f4 e1       	ldi	r31, 0x14	; 20
		asm( 	"MOV	r15,	r31"	);
    1f8a:	ff 2e       	mov	r15, r31
		asm(	"LDI	r16,	21"		);
    1f8c:	05 e1       	ldi	r16, 0x15	; 21
		asm(	"LDI	r17,	22"		);
    1f8e:	16 e1       	ldi	r17, 0x16	; 22
		asm(	"LDI	r18,	23"		);
    1f90:	27 e1       	ldi	r18, 0x17	; 23
		asm(	"LDI	r19,	24"		);
    1f92:	38 e1       	ldi	r19, 0x18	; 24
		asm(	"LDI	r20,	25"		);
    1f94:	49 e1       	ldi	r20, 0x19	; 25
		asm(	"LDI	r21,	26"		);
    1f96:	5a e1       	ldi	r21, 0x1A	; 26
		asm(	"LDI	r22,	27"		);
    1f98:	6b e1       	ldi	r22, 0x1B	; 27
		asm(	"LDI	r23,	28"		);
    1f9a:	7c e1       	ldi	r23, 0x1C	; 28
		asm(	"LDI	r24,	29"		);
    1f9c:	8d e1       	ldi	r24, 0x1D	; 29
		asm(	"LDI	r25,	30"		);
    1f9e:	9e e1       	ldi	r25, 0x1E	; 30
		asm(	"LDI	r26,	31"		);
    1fa0:	af e1       	ldi	r26, 0x1F	; 31
		asm(	"LDI	r27,	32"		);
    1fa2:	b0 e2       	ldi	r27, 0x20	; 32
		asm(	"LDI	r30,	33"		);
    1fa4:	e1 e2       	ldi	r30, 0x21	; 33

		asm(	"LDI	r31,	5"			);
    1fa6:	f5 e0       	ldi	r31, 0x05	; 5
		asm(	"CPSE	r31,	r0"			);
    1fa8:	f0 11       	cpse	r31, r0
		asm(	"STS	xRegTestError, r0"	);
    1faa:	00 92 f6 06 	sts	0x06F6, r0
		asm(	"LDI	r31,	6"			);
    1fae:	f6 e0       	ldi	r31, 0x06	; 6
		asm(	"CPSE	r31,	r1"			);
    1fb0:	f1 11       	cpse	r31, r1
		asm(	"STS	xRegTestError, r0"	);
    1fb2:	00 92 f6 06 	sts	0x06F6, r0
		asm(	"LDI	r31,	7"			);
    1fb6:	f7 e0       	ldi	r31, 0x07	; 7
		asm(	"CPSE	r31,	r2"			);
    1fb8:	f2 11       	cpse	r31, r2
		asm(	"STS	xRegTestError, r0"	);
    1fba:	00 92 f6 06 	sts	0x06F6, r0
		asm(	"LDI	r31,	8"			);
    1fbe:	f8 e0       	ldi	r31, 0x08	; 8
		asm(	"CPSE	r31,	r3"			);
    1fc0:	f3 11       	cpse	r31, r3
		asm(	"STS	xRegTestError, r0"	);
    1fc2:	00 92 f6 06 	sts	0x06F6, r0
		asm(	"LDI	r31,	9"			);
    1fc6:	f9 e0       	ldi	r31, 0x09	; 9
		asm(	"CPSE	r31,	r4"			);
    1fc8:	f4 11       	cpse	r31, r4
		asm(	"STS	xRegTestError, r0"	);
    1fca:	00 92 f6 06 	sts	0x06F6, r0
		asm(	"LDI	r31,	10"			);
    1fce:	fa e0       	ldi	r31, 0x0A	; 10
		asm(	"CPSE	r31,	r5"			);
    1fd0:	f5 11       	cpse	r31, r5
		asm(	"STS	xRegTestError, r0"	);
    1fd2:	00 92 f6 06 	sts	0x06F6, r0
		asm(	"LDI	r31,	11"			);
    1fd6:	fb e0       	ldi	r31, 0x0B	; 11
		asm(	"CPSE	r31,	r6"			);
    1fd8:	f6 11       	cpse	r31, r6
		asm(	"STS	xRegTestError, r0"	);
    1fda:	00 92 f6 06 	sts	0x06F6, r0
		asm(	"LDI	r31,	12"			);
    1fde:	fc e0       	ldi	r31, 0x0C	; 12
		asm(	"CPSE	r31,	r7"			);
    1fe0:	f7 11       	cpse	r31, r7
		asm(	"STS	xRegTestError, r0"	);
    1fe2:	00 92 f6 06 	sts	0x06F6, r0
		asm(	"LDI	r31,	13"			);
    1fe6:	fd e0       	ldi	r31, 0x0D	; 13
		asm(	"CPSE	r31,	r8"			);
    1fe8:	f8 11       	cpse	r31, r8
		asm(	"STS	xRegTestError, r0"	);
    1fea:	00 92 f6 06 	sts	0x06F6, r0
		asm(	"LDI	r31,	14"			);
    1fee:	fe e0       	ldi	r31, 0x0E	; 14
		asm(	"CPSE	r31,	r9"			);
    1ff0:	f9 11       	cpse	r31, r9
		asm(	"STS	xRegTestError, r0"	);
    1ff2:	00 92 f6 06 	sts	0x06F6, r0
		asm(	"LDI	r31,	15"			);
    1ff6:	ff e0       	ldi	r31, 0x0F	; 15
		asm(	"CPSE	r31,	r10"		);
    1ff8:	fa 11       	cpse	r31, r10
		asm(	"STS	xRegTestError, r0"	);
    1ffa:	00 92 f6 06 	sts	0x06F6, r0
		asm(	"LDI	r31,	16"			);
    1ffe:	f0 e1       	ldi	r31, 0x10	; 16
		asm(	"CPSE	r31,	r11"		);
    2000:	fb 11       	cpse	r31, r11
		asm(	"STS	xRegTestError, r0"	);
    2002:	00 92 f6 06 	sts	0x06F6, r0
		asm(	"LDI	r31,	17"			);
    2006:	f1 e1       	ldi	r31, 0x11	; 17
		asm(	"CPSE	r31,	r12"		);
    2008:	fc 11       	cpse	r31, r12
		asm(	"STS	xRegTestError, r0"	);
    200a:	00 92 f6 06 	sts	0x06F6, r0
		asm(	"LDI	r31,	18"			);
    200e:	f2 e1       	ldi	r31, 0x12	; 18
		asm(	"CPSE	r31,	r13"		);
    2010:	fd 11       	cpse	r31, r13
		asm(	"STS	xRegTestError, r0"	);
    2012:	00 92 f6 06 	sts	0x06F6, r0
		asm(	"LDI	r31,	19"			);
    2016:	f3 e1       	ldi	r31, 0x13	; 19
		asm(	"CPSE	r31,	r14"		);
    2018:	fe 11       	cpse	r31, r14
		asm(	"STS	xRegTestError, r0"	);
    201a:	00 92 f6 06 	sts	0x06F6, r0
		asm(	"LDI	r31,	20"			);
    201e:	f4 e1       	ldi	r31, 0x14	; 20
		asm(	"CPSE	r31,	r15"		);
    2020:	ff 11       	cpse	r31, r15
		asm(	"STS	xRegTestError, r0"	);
    2022:	00 92 f6 06 	sts	0x06F6, r0
		asm(	"LDI	r31,	21"			);
    2026:	f5 e1       	ldi	r31, 0x15	; 21
		asm(	"CPSE	r31,	r16"		);
    2028:	f0 13       	cpse	r31, r16
		asm(	"STS	xRegTestError, r0"	);
    202a:	00 92 f6 06 	sts	0x06F6, r0
		asm(	"LDI	r31,	22"			);
    202e:	f6 e1       	ldi	r31, 0x16	; 22
		asm(	"CPSE	r31,	r17"		);
    2030:	f1 13       	cpse	r31, r17
		asm(	"STS	xRegTestError, r0"	);
    2032:	00 92 f6 06 	sts	0x06F6, r0
		asm(	"LDI	r31,	23"			);
    2036:	f7 e1       	ldi	r31, 0x17	; 23
		asm(	"CPSE	r31,	r18"		);
    2038:	f2 13       	cpse	r31, r18
		asm(	"STS	xRegTestError, r0"	);
    203a:	00 92 f6 06 	sts	0x06F6, r0
		asm(	"LDI	r31,	24"			);
    203e:	f8 e1       	ldi	r31, 0x18	; 24
		asm(	"CPSE	r31,	r19"		);
    2040:	f3 13       	cpse	r31, r19
		asm(	"STS	xRegTestError, r0"	);
    2042:	00 92 f6 06 	sts	0x06F6, r0
		asm(	"LDI	r31,	25"			);
    2046:	f9 e1       	ldi	r31, 0x19	; 25
		asm(	"CPSE	r31,	r20"		);
    2048:	f4 13       	cpse	r31, r20
		asm(	"STS	xRegTestError, r0"	);
    204a:	00 92 f6 06 	sts	0x06F6, r0
		asm(	"LDI	r31,	26"			);
    204e:	fa e1       	ldi	r31, 0x1A	; 26
		asm(	"CPSE	r31,	r21"		);
    2050:	f5 13       	cpse	r31, r21
		asm(	"STS	xRegTestError, r0"	);
    2052:	00 92 f6 06 	sts	0x06F6, r0
		asm(	"LDI	r31,	27"			);
    2056:	fb e1       	ldi	r31, 0x1B	; 27
		asm(	"CPSE	r31,	r22"		);
    2058:	f6 13       	cpse	r31, r22
		asm(	"STS	xRegTestError, r0"	);
    205a:	00 92 f6 06 	sts	0x06F6, r0
		asm(	"LDI	r31,	28"			);
    205e:	fc e1       	ldi	r31, 0x1C	; 28
		asm(	"CPSE	r31,	r23"		);
    2060:	f7 13       	cpse	r31, r23
		asm(	"STS	xRegTestError, r0"	);
    2062:	00 92 f6 06 	sts	0x06F6, r0
		asm(	"LDI	r31,	29"			);
    2066:	fd e1       	ldi	r31, 0x1D	; 29
		asm(	"CPSE	r31,	r24"		);
    2068:	f8 13       	cpse	r31, r24
		asm(	"STS	xRegTestError, r0"	);
    206a:	00 92 f6 06 	sts	0x06F6, r0
		asm(	"LDI	r31,	30"			);
    206e:	fe e1       	ldi	r31, 0x1E	; 30
		asm(	"CPSE	r31,	r25"		);
    2070:	f9 13       	cpse	r31, r25
		asm(	"STS	xRegTestError, r0"	);
    2072:	00 92 f6 06 	sts	0x06F6, r0
		asm(	"LDI	r31,	31"			);
    2076:	ff e1       	ldi	r31, 0x1F	; 31
		asm(	"CPSE	r31,	r26"		);
    2078:	fa 13       	cpse	r31, r26
		asm(	"STS	xRegTestError, r0"	);
    207a:	00 92 f6 06 	sts	0x06F6, r0
		asm(	"LDI	r31,	32"			);
    207e:	f0 e2       	ldi	r31, 0x20	; 32
		asm(	"CPSE	r31,	r27"		);
    2080:	fb 13       	cpse	r31, r27
		asm(	"STS	xRegTestError, r0"	);
    2082:	00 92 f6 06 	sts	0x06F6, r0
		asm(	"LDI	r31,	33"			);
    2086:	f1 e2       	ldi	r31, 0x21	; 33
		asm(	"CPSE	r31,	r30"		);
    2088:	fe 13       	cpse	r31, r30
		asm(	"STS	xRegTestError, r0"	);
    208a:	00 92 f6 06 	sts	0x06F6, r0
    208e:	5e cf       	rjmp	.-324    	; 0x1f4c <prvRegisterCheck1>

00002090 <prvRegisterCheck2>:
{
	( void ) pvParameters;

	for( ;; )
	{
		asm(	"LDI	r31,	1"		);
    2090:	f1 e0       	ldi	r31, 0x01	; 1
		asm( 	"MOV	r0,		r31"	);
    2092:	0f 2e       	mov	r0, r31
		asm(	"LDI	r31,	2"		);
    2094:	f2 e0       	ldi	r31, 0x02	; 2
		asm( 	"MOV	r1,		r31"	);
    2096:	1f 2e       	mov	r1, r31
		asm(	"LDI	r31,	3"		);
    2098:	f3 e0       	ldi	r31, 0x03	; 3
		asm( 	"MOV	r2,		r31"	);
    209a:	2f 2e       	mov	r2, r31
		asm(	"LDI	r31,	4"		);
    209c:	f4 e0       	ldi	r31, 0x04	; 4
		asm( 	"MOV	r3,		r31"	);
    209e:	3f 2e       	mov	r3, r31
		asm(	"LDI	r31,	5"		);
    20a0:	f5 e0       	ldi	r31, 0x05	; 5
		asm( 	"MOV	r4,		r31"	);
    20a2:	4f 2e       	mov	r4, r31
		asm(	"LDI	r31,	6"		);
    20a4:	f6 e0       	ldi	r31, 0x06	; 6
		asm( 	"MOV	r5,		r31"	);
    20a6:	5f 2e       	mov	r5, r31
		asm(	"LDI	r31,	7"		);
    20a8:	f7 e0       	ldi	r31, 0x07	; 7
		asm( 	"MOV	r6,		r31"	);
    20aa:	6f 2e       	mov	r6, r31
		asm(	"LDI	r31,	8"		);
    20ac:	f8 e0       	ldi	r31, 0x08	; 8
		asm( 	"MOV	r7,		r31"	);
    20ae:	7f 2e       	mov	r7, r31
		asm(	"LDI	r31,	9"		);
    20b0:	f9 e0       	ldi	r31, 0x09	; 9
		asm( 	"MOV	r8,		r31"	);
    20b2:	8f 2e       	mov	r8, r31
		asm(	"LDI	r31,	10"		);
    20b4:	fa e0       	ldi	r31, 0x0A	; 10
		asm( 	"MOV	r9,		r31"	);
    20b6:	9f 2e       	mov	r9, r31
		asm(	"LDI	r31,	11"		);
    20b8:	fb e0       	ldi	r31, 0x0B	; 11
		asm( 	"MOV	r10,	r31"	);
    20ba:	af 2e       	mov	r10, r31
		asm(	"LDI	r31,	12"		);
    20bc:	fc e0       	ldi	r31, 0x0C	; 12
		asm( 	"MOV	r11,	r31"	);
    20be:	bf 2e       	mov	r11, r31
		asm(	"LDI	r31,	13"		);
    20c0:	fd e0       	ldi	r31, 0x0D	; 13
		asm( 	"MOV	r12,	r31"	);
    20c2:	cf 2e       	mov	r12, r31
		asm(	"LDI	r31,	14"		);
    20c4:	fe e0       	ldi	r31, 0x0E	; 14
		asm( 	"MOV	r13,	r31"	);
    20c6:	df 2e       	mov	r13, r31
		asm(	"LDI	r31,	15"		);
    20c8:	ff e0       	ldi	r31, 0x0F	; 15
		asm( 	"MOV	r14,	r31"	);
    20ca:	ef 2e       	mov	r14, r31
		asm(	"LDI	r31,	16"		);
    20cc:	f0 e1       	ldi	r31, 0x10	; 16
		asm( 	"MOV	r15,	r31"	);
    20ce:	ff 2e       	mov	r15, r31
		asm(	"LDI	r16,	17"		);
    20d0:	01 e1       	ldi	r16, 0x11	; 17
		asm(	"LDI	r17,	18"		);
    20d2:	12 e1       	ldi	r17, 0x12	; 18
		asm(	"LDI	r18,	19"		);
    20d4:	23 e1       	ldi	r18, 0x13	; 19
		asm(	"LDI	r19,	20"		);
    20d6:	34 e1       	ldi	r19, 0x14	; 20
		asm(	"LDI	r20,	21"		);
    20d8:	45 e1       	ldi	r20, 0x15	; 21
		asm(	"LDI	r21,	22"		);
    20da:	56 e1       	ldi	r21, 0x16	; 22
		asm(	"LDI	r22,	23"		);
    20dc:	67 e1       	ldi	r22, 0x17	; 23
		asm(	"LDI	r23,	24"		);
    20de:	78 e1       	ldi	r23, 0x18	; 24
		asm(	"LDI	r24,	25"		);
    20e0:	89 e1       	ldi	r24, 0x19	; 25
		asm(	"LDI	r25,	26"		);
    20e2:	9a e1       	ldi	r25, 0x1A	; 26
		asm(	"LDI	r26,	27"		);
    20e4:	ab e1       	ldi	r26, 0x1B	; 27
		asm(	"LDI	r27,	28"		);
    20e6:	bc e1       	ldi	r27, 0x1C	; 28
		asm(	"LDI	r30,	29"		);
    20e8:	ed e1       	ldi	r30, 0x1D	; 29

		asm(	"LDI	r31,	1"			);
    20ea:	f1 e0       	ldi	r31, 0x01	; 1
		asm(	"CPSE	r31,	r0"			);
    20ec:	f0 11       	cpse	r31, r0
		asm(	"STS	xRegTestError, r0"	);
    20ee:	00 92 f6 06 	sts	0x06F6, r0
		asm(	"LDI	r31,	2"			);
    20f2:	f2 e0       	ldi	r31, 0x02	; 2
		asm(	"CPSE	r31,	r1"			);
    20f4:	f1 11       	cpse	r31, r1
		asm(	"STS	xRegTestError, r0"	);
    20f6:	00 92 f6 06 	sts	0x06F6, r0
		asm(	"LDI	r31,	3"			);
    20fa:	f3 e0       	ldi	r31, 0x03	; 3
		asm(	"CPSE	r31,	r2"			);
    20fc:	f2 11       	cpse	r31, r2
		asm(	"STS	xRegTestError, r0"	);
    20fe:	00 92 f6 06 	sts	0x06F6, r0
		asm(	"LDI	r31,	4"			);
    2102:	f4 e0       	ldi	r31, 0x04	; 4
		asm(	"CPSE	r31,	r3"			);
    2104:	f3 11       	cpse	r31, r3
		asm(	"STS	xRegTestError, r0"	);
    2106:	00 92 f6 06 	sts	0x06F6, r0
		asm(	"LDI	r31,	5"			);
    210a:	f5 e0       	ldi	r31, 0x05	; 5
		asm(	"CPSE	r31,	r4"			);
    210c:	f4 11       	cpse	r31, r4
		asm(	"STS	xRegTestError, r0"	);
    210e:	00 92 f6 06 	sts	0x06F6, r0
		asm(	"LDI	r31,	6"			);
    2112:	f6 e0       	ldi	r31, 0x06	; 6
		asm(	"CPSE	r31,	r5"			);
    2114:	f5 11       	cpse	r31, r5
		asm(	"STS	xRegTestError, r0"	);
    2116:	00 92 f6 06 	sts	0x06F6, r0
		asm(	"LDI	r31,	7"			);
    211a:	f7 e0       	ldi	r31, 0x07	; 7
		asm(	"CPSE	r31,	r6"			);
    211c:	f6 11       	cpse	r31, r6
		asm(	"STS	xRegTestError, r0"	);
    211e:	00 92 f6 06 	sts	0x06F6, r0
		asm(	"LDI	r31,	8"			);
    2122:	f8 e0       	ldi	r31, 0x08	; 8
		asm(	"CPSE	r31,	r7"			);
    2124:	f7 11       	cpse	r31, r7
		asm(	"STS	xRegTestError, r0"	);
    2126:	00 92 f6 06 	sts	0x06F6, r0
		asm(	"LDI	r31,	9"			);
    212a:	f9 e0       	ldi	r31, 0x09	; 9
		asm(	"CPSE	r31,	r8"			);
    212c:	f8 11       	cpse	r31, r8
		asm(	"STS	xRegTestError, r0"	);
    212e:	00 92 f6 06 	sts	0x06F6, r0
		asm(	"LDI	r31,	10"			);
    2132:	fa e0       	ldi	r31, 0x0A	; 10
		asm(	"CPSE	r31,	r9"			);
    2134:	f9 11       	cpse	r31, r9
		asm(	"STS	xRegTestError, r0"	);
    2136:	00 92 f6 06 	sts	0x06F6, r0
		asm(	"LDI	r31,	11"			);
    213a:	fb e0       	ldi	r31, 0x0B	; 11
		asm(	"CPSE	r31,	r10"		);
    213c:	fa 11       	cpse	r31, r10
		asm(	"STS	xRegTestError, r0"	);
    213e:	00 92 f6 06 	sts	0x06F6, r0
		asm(	"LDI	r31,	12"			);
    2142:	fc e0       	ldi	r31, 0x0C	; 12
		asm(	"CPSE	r31,	r11"		);
    2144:	fb 11       	cpse	r31, r11
		asm(	"STS	xRegTestError, r0"	);
    2146:	00 92 f6 06 	sts	0x06F6, r0
		asm(	"LDI	r31,	13"			);
    214a:	fd e0       	ldi	r31, 0x0D	; 13
		asm(	"CPSE	r31,	r12"		);
    214c:	fc 11       	cpse	r31, r12
		asm(	"STS	xRegTestError, r0"	);
    214e:	00 92 f6 06 	sts	0x06F6, r0
		asm(	"LDI	r31,	14"			);
    2152:	fe e0       	ldi	r31, 0x0E	; 14
		asm(	"CPSE	r31,	r13"		);
    2154:	fd 11       	cpse	r31, r13
		asm(	"STS	xRegTestError, r0"	);
    2156:	00 92 f6 06 	sts	0x06F6, r0
		asm(	"LDI	r31,	15"			);
    215a:	ff e0       	ldi	r31, 0x0F	; 15
		asm(	"CPSE	r31,	r14"		);
    215c:	fe 11       	cpse	r31, r14
		asm(	"STS	xRegTestError, r0"	);
    215e:	00 92 f6 06 	sts	0x06F6, r0
		asm(	"LDI	r31,	16"			);
    2162:	f0 e1       	ldi	r31, 0x10	; 16
		asm(	"CPSE	r31,	r15"		);
    2164:	ff 11       	cpse	r31, r15
		asm(	"STS	xRegTestError, r0"	);
    2166:	00 92 f6 06 	sts	0x06F6, r0
		asm(	"LDI	r31,	17"			);
    216a:	f1 e1       	ldi	r31, 0x11	; 17
		asm(	"CPSE	r31,	r16"		);
    216c:	f0 13       	cpse	r31, r16
		asm(	"STS	xRegTestError, r0"	);
    216e:	00 92 f6 06 	sts	0x06F6, r0
		asm(	"LDI	r31,	18"			);
    2172:	f2 e1       	ldi	r31, 0x12	; 18
		asm(	"CPSE	r31,	r17"		);
    2174:	f1 13       	cpse	r31, r17
		asm(	"STS	xRegTestError, r0"	);
    2176:	00 92 f6 06 	sts	0x06F6, r0
		asm(	"LDI	r31,	19"			);
    217a:	f3 e1       	ldi	r31, 0x13	; 19
		asm(	"CPSE	r31,	r18"		);
    217c:	f2 13       	cpse	r31, r18
		asm(	"STS	xRegTestError, r0"	);
    217e:	00 92 f6 06 	sts	0x06F6, r0
		asm(	"LDI	r31,	20"			);
    2182:	f4 e1       	ldi	r31, 0x14	; 20
		asm(	"CPSE	r31,	r19"		);
    2184:	f3 13       	cpse	r31, r19
		asm(	"STS	xRegTestError, r0"	);
    2186:	00 92 f6 06 	sts	0x06F6, r0
		asm(	"LDI	r31,	21"			);
    218a:	f5 e1       	ldi	r31, 0x15	; 21
		asm(	"CPSE	r31,	r20"		);
    218c:	f4 13       	cpse	r31, r20
		asm(	"STS	xRegTestError, r0"	);
    218e:	00 92 f6 06 	sts	0x06F6, r0
		asm(	"LDI	r31,	22"			);
    2192:	f6 e1       	ldi	r31, 0x16	; 22
		asm(	"CPSE	r31,	r21"		);
    2194:	f5 13       	cpse	r31, r21
		asm(	"STS	xRegTestError, r0"	);
    2196:	00 92 f6 06 	sts	0x06F6, r0
		asm(	"LDI	r31,	23"			);
    219a:	f7 e1       	ldi	r31, 0x17	; 23
		asm(	"CPSE	r31,	r22"		);
    219c:	f6 13       	cpse	r31, r22
		asm(	"STS	xRegTestError, r0"	);
    219e:	00 92 f6 06 	sts	0x06F6, r0
		asm(	"LDI	r31,	24"			);
    21a2:	f8 e1       	ldi	r31, 0x18	; 24
		asm(	"CPSE	r31,	r23"		);
    21a4:	f7 13       	cpse	r31, r23
		asm(	"STS	xRegTestError, r0"	);
    21a6:	00 92 f6 06 	sts	0x06F6, r0
		asm(	"LDI	r31,	25"			);
    21aa:	f9 e1       	ldi	r31, 0x19	; 25
		asm(	"CPSE	r31,	r24"		);
    21ac:	f8 13       	cpse	r31, r24
		asm(	"STS	xRegTestError, r0"	);
    21ae:	00 92 f6 06 	sts	0x06F6, r0
		asm(	"LDI	r31,	26"			);
    21b2:	fa e1       	ldi	r31, 0x1A	; 26
		asm(	"CPSE	r31,	r25"		);
    21b4:	f9 13       	cpse	r31, r25
		asm(	"STS	xRegTestError, r0"	);
    21b6:	00 92 f6 06 	sts	0x06F6, r0
		asm(	"LDI	r31,	27"			);
    21ba:	fb e1       	ldi	r31, 0x1B	; 27
		asm(	"CPSE	r31,	r26"		);
    21bc:	fa 13       	cpse	r31, r26
		asm(	"STS	xRegTestError, r0"	);
    21be:	00 92 f6 06 	sts	0x06F6, r0
		asm(	"LDI	r31,	28"			);
    21c2:	fc e1       	ldi	r31, 0x1C	; 28
		asm(	"CPSE	r31,	r27"		);
    21c4:	fb 13       	cpse	r31, r27
		asm(	"STS	xRegTestError, r0"	);
    21c6:	00 92 f6 06 	sts	0x06F6, r0
		asm(	"LDI	r31,	29"			);
    21ca:	fd e1       	ldi	r31, 0x1D	; 29
		asm(	"CPSE	r31,	r30"		);
    21cc:	fe 13       	cpse	r31, r30
		asm(	"STS	xRegTestError, r0"	);
    21ce:	00 92 f6 06 	sts	0x06F6, r0
    21d2:	5e cf       	rjmp	.-324    	; 0x2090 <prvRegisterCheck2>

000021d4 <vStartRegTestTasks>:
portBASE_TYPE xRegTestError = pdFALSE;

/*-----------------------------------------------------------*/

void vStartRegTestTasks( void )
{
    21d4:	ef 92       	push	r14
    21d6:	ff 92       	push	r15
    21d8:	0f 93       	push	r16
	xTaskCreate( prvRegisterCheck1, "Reg1", configMINIMAL_STACK_SIZE, NULL, tskIDLE_PRIORITY, NULL );
    21da:	86 ea       	ldi	r24, 0xA6	; 166
    21dc:	9f e0       	ldi	r25, 0x0F	; 15
    21de:	60 e6       	ldi	r22, 0x60	; 96
    21e0:	70 e0       	ldi	r23, 0x00	; 0
    21e2:	45 e5       	ldi	r20, 0x55	; 85
    21e4:	50 e0       	ldi	r21, 0x00	; 0
    21e6:	20 e0       	ldi	r18, 0x00	; 0
    21e8:	30 e0       	ldi	r19, 0x00	; 0
    21ea:	00 e0       	ldi	r16, 0x00	; 0
    21ec:	ee 24       	eor	r14, r14
    21ee:	ff 24       	eor	r15, r15
    21f0:	0e 94 c9 21 	call	0x4392	; 0x4392 <xTaskCreate>
	xTaskCreate( prvRegisterCheck2, "Reg2", configMINIMAL_STACK_SIZE, NULL, tskIDLE_PRIORITY, NULL );
    21f4:	88 e4       	ldi	r24, 0x48	; 72
    21f6:	90 e1       	ldi	r25, 0x10	; 16
    21f8:	65 e6       	ldi	r22, 0x65	; 101
    21fa:	70 e0       	ldi	r23, 0x00	; 0
    21fc:	45 e5       	ldi	r20, 0x55	; 85
    21fe:	50 e0       	ldi	r21, 0x00	; 0
    2200:	20 e0       	ldi	r18, 0x00	; 0
    2202:	30 e0       	ldi	r19, 0x00	; 0
    2204:	0e 94 c9 21 	call	0x4392	; 0x4392 <xTaskCreate>
}
    2208:	0f 91       	pop	r16
    220a:	ff 90       	pop	r15
    220c:	ef 90       	pop	r14
    220e:	08 95       	ret

00002210 <xStreamBufferSetTriggerLevel>:
}
/*-----------------------------------------------------------*/

BaseType_t xStreamBufferSetTriggerLevel( StreamBufferHandle_t xStreamBuffer,
                                         size_t xTriggerLevel )
{
    2210:	fc 01       	movw	r30, r24
    BaseType_t xReturn;

    configASSERT( pxStreamBuffer );

    /* It is not valid for the trigger level to be 0. */
    if( xTriggerLevel == ( size_t ) 0 )
    2212:	61 15       	cp	r22, r1
    2214:	71 05       	cpc	r23, r1
    2216:	11 f4       	brne	.+4      	; 0x221c <xStreamBufferSetTriggerLevel+0xc>
    2218:	61 e0       	ldi	r22, 0x01	; 1
    221a:	70 e0       	ldi	r23, 0x00	; 0
        xTriggerLevel = ( size_t ) 1;
    }

    /* The trigger level is the number of bytes that must be in the stream
     * buffer before a task that is waiting for data is unblocked. */
    if( xTriggerLevel < pxStreamBuffer->xLength )
    221c:	84 81       	ldd	r24, Z+4	; 0x04
    221e:	95 81       	ldd	r25, Z+5	; 0x05
    2220:	68 17       	cp	r22, r24
    2222:	79 07       	cpc	r23, r25
    2224:	10 f0       	brcs	.+4      	; 0x222a <xStreamBufferSetTriggerLevel+0x1a>
    2226:	80 e0       	ldi	r24, 0x00	; 0
    2228:	08 95       	ret
    {
        pxStreamBuffer->xTriggerLevelBytes = xTriggerLevel;
    222a:	77 83       	std	Z+7, r23	; 0x07
    222c:	66 83       	std	Z+6, r22	; 0x06
    222e:	81 e0       	ldi	r24, 0x01	; 1
    {
        xReturn = pdFALSE;
    }

    return xReturn;
}
    2230:	08 95       	ret

00002232 <xStreamBufferSpacesAvailable>:
/*-----------------------------------------------------------*/

size_t xStreamBufferSpacesAvailable( StreamBufferHandle_t xStreamBuffer )
{
    2232:	fc 01       	movw	r30, r24
     * buffer is updated once between the two reads - but not if the stream buffer
     * is updated more than once between the two reads - hence the loop. */
    do
    {
        xOriginalTail = pxStreamBuffer->xTail;
        xSpace = pxStreamBuffer->xLength + pxStreamBuffer->xTail;
    2234:	64 81       	ldd	r22, Z+4	; 0x04
    2236:	75 81       	ldd	r23, Z+5	; 0x05
    /* The code below reads xTail and then xHead.  This is safe if the stream
     * buffer is updated once between the two reads - but not if the stream buffer
     * is updated more than once between the two reads - hence the loop. */
    do
    {
        xOriginalTail = pxStreamBuffer->xTail;
    2238:	20 81       	ld	r18, Z
    223a:	31 81       	ldd	r19, Z+1	; 0x01
        xSpace = pxStreamBuffer->xLength + pxStreamBuffer->xTail;
    223c:	40 81       	ld	r20, Z
    223e:	51 81       	ldd	r21, Z+1	; 0x01
        xSpace -= pxStreamBuffer->xHead;
    2240:	82 81       	ldd	r24, Z+2	; 0x02
    2242:	93 81       	ldd	r25, Z+3	; 0x03
     * buffer is updated once between the two reads - but not if the stream buffer
     * is updated more than once between the two reads - hence the loop. */
    do
    {
        xOriginalTail = pxStreamBuffer->xTail;
        xSpace = pxStreamBuffer->xLength + pxStreamBuffer->xTail;
    2244:	46 0f       	add	r20, r22
    2246:	57 1f       	adc	r21, r23
        xSpace -= pxStreamBuffer->xHead;
    2248:	48 1b       	sub	r20, r24
    224a:	59 0b       	sbc	r21, r25
    } while( xOriginalTail != pxStreamBuffer->xTail );
    224c:	80 81       	ld	r24, Z
    224e:	91 81       	ldd	r25, Z+1	; 0x01
    2250:	28 17       	cp	r18, r24
    2252:	39 07       	cpc	r19, r25
    2254:	89 f7       	brne	.-30     	; 0x2238 <xStreamBufferSpacesAvailable+0x6>

    xSpace -= ( size_t ) 1;
    2256:	9a 01       	movw	r18, r20
    2258:	21 50       	subi	r18, 0x01	; 1
    225a:	30 40       	sbci	r19, 0x00	; 0

    if( xSpace >= pxStreamBuffer->xLength )
    225c:	26 17       	cp	r18, r22
    225e:	37 07       	cpc	r19, r23
    2260:	10 f0       	brcs	.+4      	; 0x2266 <xStreamBufferSpacesAvailable+0x34>
    {
        xSpace -= pxStreamBuffer->xLength;
    2262:	26 1b       	sub	r18, r22
    2264:	37 0b       	sbc	r19, r23
    {
        mtCOVERAGE_TEST_MARKER();
    }

    return xSpace;
}
    2266:	c9 01       	movw	r24, r18
    2268:	08 95       	ret

0000226a <xStreamBufferBytesAvailable>:
/*-----------------------------------------------------------*/

size_t xStreamBufferBytesAvailable( StreamBufferHandle_t xStreamBuffer )
{
    226a:	fc 01       	movw	r30, r24
static size_t prvBytesInBuffer( const StreamBuffer_t * const pxStreamBuffer )
{
/* Returns the distance between xTail and xHead. */
    size_t xCount;

    xCount = pxStreamBuffer->xLength + pxStreamBuffer->xHead;
    226c:	44 81       	ldd	r20, Z+4	; 0x04
    226e:	55 81       	ldd	r21, Z+5	; 0x05
    2270:	22 81       	ldd	r18, Z+2	; 0x02
    2272:	33 81       	ldd	r19, Z+3	; 0x03
    xCount -= pxStreamBuffer->xTail;
    2274:	80 81       	ld	r24, Z
    2276:	91 81       	ldd	r25, Z+1	; 0x01
    2278:	24 0f       	add	r18, r20
    227a:	35 1f       	adc	r19, r21
    227c:	28 1b       	sub	r18, r24
    227e:	39 0b       	sbc	r19, r25

    if( xCount >= pxStreamBuffer->xLength )
    2280:	24 17       	cp	r18, r20
    2282:	35 07       	cpc	r19, r21
    2284:	10 f0       	brcs	.+4      	; 0x228a <xStreamBufferBytesAvailable+0x20>
    {
        xCount -= pxStreamBuffer->xLength;
    2286:	24 1b       	sub	r18, r20
    2288:	35 0b       	sbc	r19, r21

    configASSERT( pxStreamBuffer );

    xReturn = prvBytesInBuffer( pxStreamBuffer );
    return xReturn;
}
    228a:	c9 01       	movw	r24, r18
    228c:	08 95       	ret

0000228e <xStreamBufferIsEmpty>:
    return xCount;
}
/*-----------------------------------------------------------*/

BaseType_t xStreamBufferIsEmpty( StreamBufferHandle_t xStreamBuffer )
{
    228e:	fc 01       	movw	r30, r24
    size_t xTail;

    configASSERT( pxStreamBuffer );

    /* True if no bytes are available. */
    xTail = pxStreamBuffer->xTail;
    2290:	20 81       	ld	r18, Z
    2292:	31 81       	ldd	r19, Z+1	; 0x01

    if( pxStreamBuffer->xHead == xTail )
    2294:	82 81       	ldd	r24, Z+2	; 0x02
    2296:	93 81       	ldd	r25, Z+3	; 0x03
    2298:	40 e0       	ldi	r20, 0x00	; 0
    229a:	82 17       	cp	r24, r18
    229c:	93 07       	cpc	r25, r19
    229e:	09 f4       	brne	.+2      	; 0x22a2 <xStreamBufferIsEmpty+0x14>
    22a0:	41 e0       	ldi	r20, 0x01	; 1
    {
        xReturn = pdFALSE;
    }

    return xReturn;
}
    22a2:	84 2f       	mov	r24, r20
    22a4:	08 95       	ret

000022a6 <xStreamBufferIsFull>:
/*-----------------------------------------------------------*/

BaseType_t xStreamBufferIsFull( StreamBufferHandle_t xStreamBuffer )
{
    22a6:	cf 93       	push	r28
    22a8:	df 93       	push	r29
    22aa:	fc 01       	movw	r30, r24

    /* This generic version of the receive function is used by both message
     * buffers, which store discrete messages, and stream buffers, which store a
     * continuous stream of bytes.  Discrete messages include an additional
     * sbBYTES_TO_STORE_MESSAGE_LENGTH bytes that hold the length of the message. */
    if( ( pxStreamBuffer->ucFlags & sbFLAGS_IS_MESSAGE_BUFFER ) != ( uint8_t ) 0 )
    22ac:	86 85       	ldd	r24, Z+14	; 0x0e
    22ae:	80 fd       	sbrc	r24, 0
    22b0:	03 c0       	rjmp	.+6      	; 0x22b8 <xStreamBufferIsFull+0x12>
    22b2:	c0 e0       	ldi	r28, 0x00	; 0
    22b4:	d0 e0       	ldi	r29, 0x00	; 0
    22b6:	02 c0       	rjmp	.+4      	; 0x22bc <xStreamBufferIsFull+0x16>
    22b8:	c2 e0       	ldi	r28, 0x02	; 2
    22ba:	d0 e0       	ldi	r29, 0x00	; 0
    {
        xBytesToStoreMessageLength = 0;
    }

    /* True if the available space equals zero. */
    if( xStreamBufferSpacesAvailable( xStreamBuffer ) <= xBytesToStoreMessageLength )
    22bc:	cf 01       	movw	r24, r30
    22be:	0e 94 19 11 	call	0x2232	; 0x2232 <xStreamBufferSpacesAvailable>
    22c2:	20 e0       	ldi	r18, 0x00	; 0
    22c4:	c8 17       	cp	r28, r24
    22c6:	d9 07       	cpc	r29, r25
    22c8:	08 f0       	brcs	.+2      	; 0x22cc <xStreamBufferIsFull+0x26>
    22ca:	21 e0       	ldi	r18, 0x01	; 1
    {
        xReturn = pdFALSE;
    }

    return xReturn;
}
    22cc:	82 2f       	mov	r24, r18
    22ce:	df 91       	pop	r29
    22d0:	cf 91       	pop	r28
    22d2:	08 95       	ret

000022d4 <xStreamBufferReceiveCompletedFromISR>:
}
/*-----------------------------------------------------------*/

BaseType_t xStreamBufferReceiveCompletedFromISR( StreamBufferHandle_t xStreamBuffer,
                                                 BaseType_t * pxHigherPriorityTaskWoken )
{
    22d4:	cf 92       	push	r12
    22d6:	df 92       	push	r13
    22d8:	ef 92       	push	r14
    22da:	ff 92       	push	r15
    22dc:	0f 93       	push	r16
    22de:	cf 93       	push	r28
    22e0:	df 93       	push	r29
    22e2:	ec 01       	movw	r28, r24
    22e4:	6b 01       	movw	r12, r22

    configASSERT( pxStreamBuffer );

    uxSavedInterruptStatus = ( UBaseType_t ) portSET_INTERRUPT_MASK_FROM_ISR();
    {
        if( ( pxStreamBuffer )->xTaskWaitingToSend != NULL )
    22e6:	8a 85       	ldd	r24, Y+10	; 0x0a
    22e8:	9b 85       	ldd	r25, Y+11	; 0x0b
    22ea:	89 2b       	or	r24, r25
    22ec:	11 f4       	brne	.+4      	; 0x22f2 <xStreamBufferReceiveCompletedFromISR+0x1e>
    22ee:	80 e0       	ldi	r24, 0x00	; 0
    22f0:	0f c0       	rjmp	.+30     	; 0x2310 <xStreamBufferReceiveCompletedFromISR+0x3c>
        {
            ( void ) xTaskNotifyFromISR( ( pxStreamBuffer )->xTaskWaitingToSend,
    22f2:	8a 85       	ldd	r24, Y+10	; 0x0a
    22f4:	9b 85       	ldd	r25, Y+11	; 0x0b
    22f6:	60 e0       	ldi	r22, 0x00	; 0
    22f8:	20 e0       	ldi	r18, 0x00	; 0
    22fa:	30 e0       	ldi	r19, 0x00	; 0
    22fc:	40 e0       	ldi	r20, 0x00	; 0
    22fe:	50 e0       	ldi	r21, 0x00	; 0
    2300:	00 e0       	ldi	r16, 0x00	; 0
    2302:	ee 24       	eor	r14, r14
    2304:	ff 24       	eor	r15, r15
    2306:	0e 94 d5 18 	call	0x31aa	; 0x31aa <xTaskGenericNotifyFromISR>
                                         ( uint32_t ) 0,
                                         eNoAction,
                                         pxHigherPriorityTaskWoken );
            ( pxStreamBuffer )->xTaskWaitingToSend = NULL;
    230a:	1b 86       	std	Y+11, r1	; 0x0b
    230c:	1a 86       	std	Y+10, r1	; 0x0a
    230e:	81 e0       	ldi	r24, 0x01	; 1
        }
    }
    portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

    return xReturn;
}
    2310:	df 91       	pop	r29
    2312:	cf 91       	pop	r28
    2314:	0f 91       	pop	r16
    2316:	ff 90       	pop	r15
    2318:	ef 90       	pop	r14
    231a:	df 90       	pop	r13
    231c:	cf 90       	pop	r12
    231e:	08 95       	ret

00002320 <xStreamBufferSendCompletedFromISR>:
}
/*-----------------------------------------------------------*/

BaseType_t xStreamBufferSendCompletedFromISR( StreamBufferHandle_t xStreamBuffer,
                                              BaseType_t * pxHigherPriorityTaskWoken )
{
    2320:	cf 92       	push	r12
    2322:	df 92       	push	r13
    2324:	ef 92       	push	r14
    2326:	ff 92       	push	r15
    2328:	0f 93       	push	r16
    232a:	cf 93       	push	r28
    232c:	df 93       	push	r29
    232e:	ec 01       	movw	r28, r24
    2330:	6b 01       	movw	r12, r22

    configASSERT( pxStreamBuffer );

    uxSavedInterruptStatus = ( UBaseType_t ) portSET_INTERRUPT_MASK_FROM_ISR();
    {
        if( ( pxStreamBuffer )->xTaskWaitingToReceive != NULL )
    2332:	88 85       	ldd	r24, Y+8	; 0x08
    2334:	99 85       	ldd	r25, Y+9	; 0x09
    2336:	89 2b       	or	r24, r25
    2338:	11 f4       	brne	.+4      	; 0x233e <xStreamBufferSendCompletedFromISR+0x1e>
    233a:	80 e0       	ldi	r24, 0x00	; 0
    233c:	0f c0       	rjmp	.+30     	; 0x235c <xStreamBufferSendCompletedFromISR+0x3c>
        {
            ( void ) xTaskNotifyFromISR( ( pxStreamBuffer )->xTaskWaitingToReceive,
    233e:	88 85       	ldd	r24, Y+8	; 0x08
    2340:	99 85       	ldd	r25, Y+9	; 0x09
    2342:	60 e0       	ldi	r22, 0x00	; 0
    2344:	20 e0       	ldi	r18, 0x00	; 0
    2346:	30 e0       	ldi	r19, 0x00	; 0
    2348:	40 e0       	ldi	r20, 0x00	; 0
    234a:	50 e0       	ldi	r21, 0x00	; 0
    234c:	00 e0       	ldi	r16, 0x00	; 0
    234e:	ee 24       	eor	r14, r14
    2350:	ff 24       	eor	r15, r15
    2352:	0e 94 d5 18 	call	0x31aa	; 0x31aa <xTaskGenericNotifyFromISR>
                                         ( uint32_t ) 0,
                                         eNoAction,
                                         pxHigherPriorityTaskWoken );
            ( pxStreamBuffer )->xTaskWaitingToReceive = NULL;
    2356:	19 86       	std	Y+9, r1	; 0x09
    2358:	18 86       	std	Y+8, r1	; 0x08
    235a:	81 e0       	ldi	r24, 0x01	; 1
        }
    }
    portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

    return xReturn;
}
    235c:	df 91       	pop	r29
    235e:	cf 91       	pop	r28
    2360:	0f 91       	pop	r16
    2362:	ff 90       	pop	r15
    2364:	ef 90       	pop	r14
    2366:	df 90       	pop	r13
    2368:	cf 90       	pop	r12
    236a:	08 95       	ret

0000236c <prvReadBytesFromBuffer>:

static size_t prvReadBytesFromBuffer( StreamBuffer_t * pxStreamBuffer,
                                      uint8_t * pucData,
                                      size_t xCount,
                                      size_t xTail )
{
    236c:	af 92       	push	r10
    236e:	bf 92       	push	r11
    2370:	cf 92       	push	r12
    2372:	df 92       	push	r13
    2374:	ef 92       	push	r14
    2376:	ff 92       	push	r15
    2378:	0f 93       	push	r16
    237a:	1f 93       	push	r17
    237c:	cf 93       	push	r28
    237e:	df 93       	push	r29
    2380:	6c 01       	movw	r12, r24
    2382:	8b 01       	movw	r16, r22
    2384:	7a 01       	movw	r14, r20
    2386:	59 01       	movw	r10, r18
    configASSERT( xCount != ( size_t ) 0 );

    /* Calculate the number of bytes that can be read - which may be
     * less than the number wanted if the data wraps around to the start of
     * the buffer. */
    xFirstLength = configMIN( pxStreamBuffer->xLength - xTail, xCount );
    2388:	dc 01       	movw	r26, r24
    238a:	14 96       	adiw	r26, 0x04	; 4
    238c:	cd 91       	ld	r28, X+
    238e:	dc 91       	ld	r29, X
    2390:	15 97       	sbiw	r26, 0x05	; 5
    2392:	c2 1b       	sub	r28, r18
    2394:	d3 0b       	sbc	r29, r19
    2396:	4c 17       	cp	r20, r28
    2398:	5d 07       	cpc	r21, r29
    239a:	08 f4       	brcc	.+2      	; 0x239e <prvReadBytesFromBuffer+0x32>
    239c:	ea 01       	movw	r28, r20

    /* Obtain the number of bytes it is possible to obtain in the first
     * read.  Asserts check bounds of read and write. */
    configASSERT( xFirstLength <= xCount );
    configASSERT( ( xTail + xFirstLength ) <= pxStreamBuffer->xLength );
    ( void ) memcpy( ( void * ) pucData, ( const void * ) &( pxStreamBuffer->pucBuffer[ xTail ] ), xFirstLength ); /*lint !e9087 memcpy() requires void *. */
    239e:	f6 01       	movw	r30, r12
    23a0:	24 85       	ldd	r18, Z+12	; 0x0c
    23a2:	35 85       	ldd	r19, Z+13	; 0x0d
    23a4:	2a 0d       	add	r18, r10
    23a6:	3b 1d       	adc	r19, r11
    23a8:	c8 01       	movw	r24, r16
    23aa:	b9 01       	movw	r22, r18
    23ac:	ae 01       	movw	r20, r28
    23ae:	0e 94 55 26 	call	0x4caa	; 0x4caa <memcpy>

    /* If the total number of wanted bytes is greater than the number
     * that could be read in the first read... */
    if( xCount > xFirstLength )
    23b2:	ce 15       	cp	r28, r14
    23b4:	df 05       	cpc	r29, r15
    23b6:	80 f4       	brcc	.+32     	; 0x23d8 <prvReadBytesFromBuffer+0x6c>
    {
        /* ...then read the remaining bytes from the start of the buffer. */
        ( void ) memcpy( ( void * ) &( pucData[ xFirstLength ] ), ( void * ) ( pxStreamBuffer->pucBuffer ), xCount - xFirstLength ); /*lint !e9087 memcpy() requires void *. */
    23b8:	98 01       	movw	r18, r16
    23ba:	2c 0f       	add	r18, r28
    23bc:	3d 1f       	adc	r19, r29
    23be:	f7 01       	movw	r30, r14
    23c0:	ec 1b       	sub	r30, r28
    23c2:	fd 0b       	sbc	r31, r29
    23c4:	d6 01       	movw	r26, r12
    23c6:	1c 96       	adiw	r26, 0x0c	; 12
    23c8:	6c 91       	ld	r22, X
    23ca:	1c 97       	sbiw	r26, 0x0c	; 12
    23cc:	1d 96       	adiw	r26, 0x0d	; 13
    23ce:	7c 91       	ld	r23, X
    23d0:	c9 01       	movw	r24, r18
    23d2:	af 01       	movw	r20, r30
    23d4:	0e 94 55 26 	call	0x4caa	; 0x4caa <memcpy>
    {
        mtCOVERAGE_TEST_MARKER();
    }

    /* Move the tail pointer to effectively remove the data read from the buffer. */
    xTail += xCount;
    23d8:	95 01       	movw	r18, r10
    23da:	2e 0d       	add	r18, r14
    23dc:	3f 1d       	adc	r19, r15

    if( xTail >= pxStreamBuffer->xLength )
    23de:	f6 01       	movw	r30, r12
    23e0:	84 81       	ldd	r24, Z+4	; 0x04
    23e2:	95 81       	ldd	r25, Z+5	; 0x05
    23e4:	28 17       	cp	r18, r24
    23e6:	39 07       	cpc	r19, r25
    23e8:	10 f0       	brcs	.+4      	; 0x23ee <prvReadBytesFromBuffer+0x82>
    {
        xTail -= pxStreamBuffer->xLength;
    23ea:	28 1b       	sub	r18, r24
    23ec:	39 0b       	sbc	r19, r25
    }

    return xTail;
}
    23ee:	c9 01       	movw	r24, r18
    23f0:	df 91       	pop	r29
    23f2:	cf 91       	pop	r28
    23f4:	1f 91       	pop	r17
    23f6:	0f 91       	pop	r16
    23f8:	ff 90       	pop	r15
    23fa:	ef 90       	pop	r14
    23fc:	df 90       	pop	r13
    23fe:	cf 90       	pop	r12
    2400:	bf 90       	pop	r11
    2402:	af 90       	pop	r10
    2404:	08 95       	ret

00002406 <prvReadMessageFromBuffer>:

static size_t prvReadMessageFromBuffer( StreamBuffer_t * pxStreamBuffer,
                                        void * pvRxData,
                                        size_t xBufferLengthBytes,
                                        size_t xBytesAvailable )
{
    2406:	af 92       	push	r10
    2408:	bf 92       	push	r11
    240a:	cf 92       	push	r12
    240c:	df 92       	push	r13
    240e:	ef 92       	push	r14
    2410:	ff 92       	push	r15
    2412:	0f 93       	push	r16
    2414:	1f 93       	push	r17
    2416:	df 93       	push	r29
    2418:	cf 93       	push	r28
    241a:	00 d0       	rcall	.+0      	; 0x241c <prvReadMessageFromBuffer+0x16>
    241c:	cd b7       	in	r28, 0x3d	; 61
    241e:	de b7       	in	r29, 0x3e	; 62
    2420:	7c 01       	movw	r14, r24
    2422:	5b 01       	movw	r10, r22
    2424:	6a 01       	movw	r12, r20
    2426:	89 01       	movw	r16, r18
    size_t xCount, xNextMessageLength;
    configMESSAGE_BUFFER_LENGTH_TYPE xTempNextMessageLength;
    size_t xNextTail = pxStreamBuffer->xTail;
    2428:	fc 01       	movw	r30, r24
    242a:	20 81       	ld	r18, Z
    242c:	31 81       	ldd	r19, Z+1	; 0x01

    if( ( pxStreamBuffer->ucFlags & sbFLAGS_IS_MESSAGE_BUFFER ) != ( uint8_t ) 0 )
    242e:	86 85       	ldd	r24, Z+14	; 0x0e
    2430:	80 fd       	sbrc	r24, 0
    2432:	02 c0       	rjmp	.+4      	; 0x2438 <prvReadMessageFromBuffer+0x32>
    2434:	ca 01       	movw	r24, r20
    2436:	12 c0       	rjmp	.+36     	; 0x245c <prvReadMessageFromBuffer+0x56>
    {
        /* A discrete message is being received.  First receive the length
         * of the message. */
        xNextTail = prvReadBytesFromBuffer( pxStreamBuffer, ( uint8_t * ) &xTempNextMessageLength, sbBYTES_TO_STORE_MESSAGE_LENGTH, xNextTail );
    2438:	c7 01       	movw	r24, r14
    243a:	be 01       	movw	r22, r28
    243c:	6f 5f       	subi	r22, 0xFF	; 255
    243e:	7f 4f       	sbci	r23, 0xFF	; 255
    2440:	42 e0       	ldi	r20, 0x02	; 2
    2442:	50 e0       	ldi	r21, 0x00	; 0
    2444:	0e 94 b6 11 	call	0x236c	; 0x236c <prvReadBytesFromBuffer>
    2448:	9c 01       	movw	r18, r24
        xNextMessageLength = ( size_t ) xTempNextMessageLength;
    244a:	89 81       	ldd	r24, Y+1	; 0x01
    244c:	9a 81       	ldd	r25, Y+2	; 0x02

        /* Reduce the number of bytes available by the number of bytes just
         * read out. */
        xBytesAvailable -= sbBYTES_TO_STORE_MESSAGE_LENGTH;
    244e:	02 50       	subi	r16, 0x02	; 2
    2450:	10 40       	sbci	r17, 0x00	; 0

        /* Check there is enough space in the buffer provided by the
         * user. */
        if( xNextMessageLength > xBufferLengthBytes )
    2452:	c8 16       	cp	r12, r24
    2454:	d9 06       	cpc	r13, r25
    2456:	10 f4       	brcc	.+4      	; 0x245c <prvReadMessageFromBuffer+0x56>
    2458:	80 e0       	ldi	r24, 0x00	; 0
    245a:	90 e0       	ldi	r25, 0x00	; 0
         * message), so read as many bytes as possible. */
        xNextMessageLength = xBufferLengthBytes;
    }

    /* Use the minimum of the wanted bytes and the available bytes. */
    xCount = configMIN( xNextMessageLength, xBytesAvailable );
    245c:	80 17       	cp	r24, r16
    245e:	91 07       	cpc	r25, r17
    2460:	08 f4       	brcc	.+2      	; 0x2464 <prvReadMessageFromBuffer+0x5e>
    2462:	8c 01       	movw	r16, r24

    if( xCount != ( size_t ) 0 )
    2464:	01 15       	cp	r16, r1
    2466:	11 05       	cpc	r17, r1
    2468:	41 f0       	breq	.+16     	; 0x247a <prvReadMessageFromBuffer+0x74>
    {
        /* Read the actual data and update the tail to mark the data as officially consumed. */
        pxStreamBuffer->xTail = prvReadBytesFromBuffer( pxStreamBuffer, ( uint8_t * ) pvRxData, xCount, xNextTail ); /*lint !e9079 Data storage area is implemented as uint8_t array for ease of sizing, indexing and alignment. */
    246a:	c7 01       	movw	r24, r14
    246c:	b5 01       	movw	r22, r10
    246e:	a8 01       	movw	r20, r16
    2470:	0e 94 b6 11 	call	0x236c	; 0x236c <prvReadBytesFromBuffer>
    2474:	f7 01       	movw	r30, r14
    2476:	91 83       	std	Z+1, r25	; 0x01
    2478:	80 83       	st	Z, r24
    }

    return xCount;
}
    247a:	c8 01       	movw	r24, r16
    247c:	0f 90       	pop	r0
    247e:	0f 90       	pop	r0
    2480:	cf 91       	pop	r28
    2482:	df 91       	pop	r29
    2484:	1f 91       	pop	r17
    2486:	0f 91       	pop	r16
    2488:	ff 90       	pop	r15
    248a:	ef 90       	pop	r14
    248c:	df 90       	pop	r13
    248e:	cf 90       	pop	r12
    2490:	bf 90       	pop	r11
    2492:	af 90       	pop	r10
    2494:	08 95       	ret

00002496 <xStreamBufferReceiveFromISR>:

size_t xStreamBufferReceiveFromISR( StreamBufferHandle_t xStreamBuffer,
                                    void * pvRxData,
                                    size_t xBufferLengthBytes,
                                    BaseType_t * const pxHigherPriorityTaskWoken )
{
    2496:	af 92       	push	r10
    2498:	bf 92       	push	r11
    249a:	cf 92       	push	r12
    249c:	df 92       	push	r13
    249e:	ef 92       	push	r14
    24a0:	ff 92       	push	r15
    24a2:	0f 93       	push	r16
    24a4:	cf 93       	push	r28
    24a6:	df 93       	push	r29
    24a8:	ec 01       	movw	r28, r24
    24aa:	69 01       	movw	r12, r18
    /* This receive function is used by both message buffers, which store
     * discrete messages, and stream buffers, which store a continuous stream of
     * bytes.  Discrete messages include an additional
     * sbBYTES_TO_STORE_MESSAGE_LENGTH bytes that hold the length of the
     * message. */
    if( ( pxStreamBuffer->ucFlags & sbFLAGS_IS_MESSAGE_BUFFER ) != ( uint8_t ) 0 )
    24ac:	8e 85       	ldd	r24, Y+14	; 0x0e
    24ae:	80 fd       	sbrc	r24, 0
    24b0:	03 c0       	rjmp	.+6      	; 0x24b8 <xStreamBufferReceiveFromISR+0x22>
    24b2:	a0 e0       	ldi	r26, 0x00	; 0
    24b4:	b0 e0       	ldi	r27, 0x00	; 0
    24b6:	02 c0       	rjmp	.+4      	; 0x24bc <xStreamBufferReceiveFromISR+0x26>
    24b8:	a2 e0       	ldi	r26, 0x02	; 2
    24ba:	b0 e0       	ldi	r27, 0x00	; 0
static size_t prvBytesInBuffer( const StreamBuffer_t * const pxStreamBuffer )
{
/* Returns the distance between xTail and xHead. */
    size_t xCount;

    xCount = pxStreamBuffer->xLength + pxStreamBuffer->xHead;
    24bc:	ec 81       	ldd	r30, Y+4	; 0x04
    24be:	fd 81       	ldd	r31, Y+5	; 0x05
    24c0:	2a 81       	ldd	r18, Y+2	; 0x02
    24c2:	3b 81       	ldd	r19, Y+3	; 0x03
    xCount -= pxStreamBuffer->xTail;
    24c4:	88 81       	ld	r24, Y
    24c6:	99 81       	ldd	r25, Y+1	; 0x01
    24c8:	2e 0f       	add	r18, r30
    24ca:	3f 1f       	adc	r19, r31
    24cc:	28 1b       	sub	r18, r24
    24ce:	39 0b       	sbc	r19, r25

    if( xCount >= pxStreamBuffer->xLength )
    24d0:	2e 17       	cp	r18, r30
    24d2:	3f 07       	cpc	r19, r31
    24d4:	10 f0       	brcs	.+4      	; 0x24da <xStreamBufferReceiveFromISR+0x44>
    {
        xCount -= pxStreamBuffer->xLength;
    24d6:	2e 1b       	sub	r18, r30
    24d8:	3f 0b       	sbc	r19, r31
    /* Whether receiving a discrete message (where xBytesToStoreMessageLength
     * holds the number of bytes used to store the message length) or a stream of
     * bytes (where xBytesToStoreMessageLength is zero), the number of bytes
     * available must be greater than xBytesToStoreMessageLength to be able to
     * read bytes from the buffer. */
    if( xBytesAvailable > xBytesToStoreMessageLength )
    24da:	a2 17       	cp	r26, r18
    24dc:	b3 07       	cpc	r27, r19
    24de:	18 f0       	brcs	.+6      	; 0x24e6 <xStreamBufferReceiveFromISR+0x50>
    24e0:	aa 24       	eor	r10, r10
    24e2:	bb 24       	eor	r11, r11
    24e4:	18 c0       	rjmp	.+48     	; 0x2516 <xStreamBufferReceiveFromISR+0x80>
    {
        xReceivedLength = prvReadMessageFromBuffer( pxStreamBuffer, pvRxData, xBufferLengthBytes, xBytesAvailable );
    24e6:	ce 01       	movw	r24, r28
    24e8:	0e 94 03 12 	call	0x2406	; 0x2406 <prvReadMessageFromBuffer>
    24ec:	5c 01       	movw	r10, r24

        /* Was a task waiting for space in the buffer? */
        if( xReceivedLength != ( size_t ) 0 )
    24ee:	00 97       	sbiw	r24, 0x00	; 0
    24f0:	91 f0       	breq	.+36     	; 0x2516 <xStreamBufferReceiveFromISR+0x80>
        {
            prvRECEIVE_COMPLETED_FROM_ISR( pxStreamBuffer, pxHigherPriorityTaskWoken );
    24f2:	8a 85       	ldd	r24, Y+10	; 0x0a
    24f4:	9b 85       	ldd	r25, Y+11	; 0x0b
    24f6:	89 2b       	or	r24, r25
    24f8:	71 f0       	breq	.+28     	; 0x2516 <xStreamBufferReceiveFromISR+0x80>
    24fa:	8a 85       	ldd	r24, Y+10	; 0x0a
    24fc:	9b 85       	ldd	r25, Y+11	; 0x0b
    24fe:	60 e0       	ldi	r22, 0x00	; 0
    2500:	20 e0       	ldi	r18, 0x00	; 0
    2502:	30 e0       	ldi	r19, 0x00	; 0
    2504:	40 e0       	ldi	r20, 0x00	; 0
    2506:	50 e0       	ldi	r21, 0x00	; 0
    2508:	00 e0       	ldi	r16, 0x00	; 0
    250a:	ee 24       	eor	r14, r14
    250c:	ff 24       	eor	r15, r15
    250e:	0e 94 d5 18 	call	0x31aa	; 0x31aa <xTaskGenericNotifyFromISR>
    2512:	1b 86       	std	Y+11, r1	; 0x0b
    2514:	1a 86       	std	Y+10, r1	; 0x0a
    }

    traceSTREAM_BUFFER_RECEIVE_FROM_ISR( xStreamBuffer, xReceivedLength );

    return xReceivedLength;
}
    2516:	c5 01       	movw	r24, r10
    2518:	df 91       	pop	r29
    251a:	cf 91       	pop	r28
    251c:	0f 91       	pop	r16
    251e:	ff 90       	pop	r15
    2520:	ef 90       	pop	r14
    2522:	df 90       	pop	r13
    2524:	cf 90       	pop	r12
    2526:	bf 90       	pop	r11
    2528:	af 90       	pop	r10
    252a:	08 95       	ret

0000252c <xStreamBufferNextMessageLengthBytes>:
    return xReceivedLength;
}
/*-----------------------------------------------------------*/

size_t xStreamBufferNextMessageLengthBytes( StreamBufferHandle_t xStreamBuffer )
{
    252c:	df 93       	push	r29
    252e:	cf 93       	push	r28
    2530:	00 d0       	rcall	.+0      	; 0x2532 <xStreamBufferNextMessageLengthBytes+0x6>
    2532:	cd b7       	in	r28, 0x3d	; 61
    2534:	de b7       	in	r29, 0x3e	; 62
    2536:	fc 01       	movw	r30, r24
    configMESSAGE_BUFFER_LENGTH_TYPE xTempReturn;

    configASSERT( pxStreamBuffer );

    /* Ensure the stream buffer is being used as a message buffer. */
    if( ( pxStreamBuffer->ucFlags & sbFLAGS_IS_MESSAGE_BUFFER ) != ( uint8_t ) 0 )
    2538:	86 85       	ldd	r24, Z+14	; 0x0e
    253a:	80 ff       	sbrs	r24, 0
    253c:	1f c0       	rjmp	.+62     	; 0x257c <xStreamBufferNextMessageLengthBytes+0x50>
static size_t prvBytesInBuffer( const StreamBuffer_t * const pxStreamBuffer )
{
/* Returns the distance between xTail and xHead. */
    size_t xCount;

    xCount = pxStreamBuffer->xLength + pxStreamBuffer->xHead;
    253e:	44 81       	ldd	r20, Z+4	; 0x04
    2540:	55 81       	ldd	r21, Z+5	; 0x05
    2542:	22 81       	ldd	r18, Z+2	; 0x02
    2544:	33 81       	ldd	r19, Z+3	; 0x03
    xCount -= pxStreamBuffer->xTail;
    2546:	80 81       	ld	r24, Z
    2548:	91 81       	ldd	r25, Z+1	; 0x01
    254a:	24 0f       	add	r18, r20
    254c:	35 1f       	adc	r19, r21
    254e:	28 1b       	sub	r18, r24
    2550:	39 0b       	sbc	r19, r25

    if( xCount >= pxStreamBuffer->xLength )
    2552:	24 17       	cp	r18, r20
    2554:	35 07       	cpc	r19, r21
    2556:	10 f0       	brcs	.+4      	; 0x255c <xStreamBufferNextMessageLengthBytes+0x30>
    {
        xCount -= pxStreamBuffer->xLength;
    2558:	24 1b       	sub	r18, r20
    255a:	35 0b       	sbc	r19, r21
    /* Ensure the stream buffer is being used as a message buffer. */
    if( ( pxStreamBuffer->ucFlags & sbFLAGS_IS_MESSAGE_BUFFER ) != ( uint8_t ) 0 )
    {
        xBytesAvailable = prvBytesInBuffer( pxStreamBuffer );

        if( xBytesAvailable > sbBYTES_TO_STORE_MESSAGE_LENGTH )
    255c:	23 30       	cpi	r18, 0x03	; 3
    255e:	31 05       	cpc	r19, r1
    2560:	68 f0       	brcs	.+26     	; 0x257c <xStreamBufferNextMessageLengthBytes+0x50>
        {
            /* The number of bytes available is greater than the number of bytes
             * required to hold the length of the next message, so another message
             * is available. */
            ( void ) prvReadBytesFromBuffer( pxStreamBuffer, ( uint8_t * ) &xTempReturn, sbBYTES_TO_STORE_MESSAGE_LENGTH, pxStreamBuffer->xTail );
    2562:	20 81       	ld	r18, Z
    2564:	31 81       	ldd	r19, Z+1	; 0x01
    2566:	cf 01       	movw	r24, r30
    2568:	be 01       	movw	r22, r28
    256a:	6f 5f       	subi	r22, 0xFF	; 255
    256c:	7f 4f       	sbci	r23, 0xFF	; 255
    256e:	42 e0       	ldi	r20, 0x02	; 2
    2570:	50 e0       	ldi	r21, 0x00	; 0
    2572:	0e 94 b6 11 	call	0x236c	; 0x236c <prvReadBytesFromBuffer>
            xReturn = ( size_t ) xTempReturn;
    2576:	29 81       	ldd	r18, Y+1	; 0x01
    2578:	3a 81       	ldd	r19, Y+2	; 0x02
    257a:	02 c0       	rjmp	.+4      	; 0x2580 <xStreamBufferNextMessageLengthBytes+0x54>
    257c:	20 e0       	ldi	r18, 0x00	; 0
    257e:	30 e0       	ldi	r19, 0x00	; 0
    {
        xReturn = 0;
    }

    return xReturn;
}
    2580:	c9 01       	movw	r24, r18
    2582:	0f 90       	pop	r0
    2584:	0f 90       	pop	r0
    2586:	cf 91       	pop	r28
    2588:	df 91       	pop	r29
    258a:	08 95       	ret

0000258c <prvWriteBytesToBuffer>:

static size_t prvWriteBytesToBuffer( StreamBuffer_t * const pxStreamBuffer,
                                     const uint8_t * pucData,
                                     size_t xCount,
                                     size_t xHead )
{
    258c:	af 92       	push	r10
    258e:	bf 92       	push	r11
    2590:	cf 92       	push	r12
    2592:	df 92       	push	r13
    2594:	ef 92       	push	r14
    2596:	ff 92       	push	r15
    2598:	0f 93       	push	r16
    259a:	1f 93       	push	r17
    259c:	cf 93       	push	r28
    259e:	df 93       	push	r29
    25a0:	7c 01       	movw	r14, r24
    25a2:	6b 01       	movw	r12, r22
    25a4:	8a 01       	movw	r16, r20
    25a6:	59 01       	movw	r10, r18
    configASSERT( xCount > ( size_t ) 0 );

    /* Calculate the number of bytes that can be added in the first write -
     * which may be less than the total number of bytes that need to be added if
     * the buffer will wrap back to the beginning. */
    xFirstLength = configMIN( pxStreamBuffer->xLength - xHead, xCount );
    25a8:	dc 01       	movw	r26, r24
    25aa:	14 96       	adiw	r26, 0x04	; 4
    25ac:	cd 91       	ld	r28, X+
    25ae:	dc 91       	ld	r29, X
    25b0:	15 97       	sbiw	r26, 0x05	; 5
    25b2:	c2 1b       	sub	r28, r18
    25b4:	d3 0b       	sbc	r29, r19
    25b6:	4c 17       	cp	r20, r28
    25b8:	5d 07       	cpc	r21, r29
    25ba:	08 f4       	brcc	.+2      	; 0x25be <prvWriteBytesToBuffer+0x32>
    25bc:	ea 01       	movw	r28, r20

    /* Write as many bytes as can be written in the first write. */
    configASSERT( ( xHead + xFirstLength ) <= pxStreamBuffer->xLength );
    ( void ) memcpy( ( void * ) ( &( pxStreamBuffer->pucBuffer[ xHead ] ) ), ( const void * ) pucData, xFirstLength ); /*lint !e9087 memcpy() requires void *. */
    25be:	f7 01       	movw	r30, r14
    25c0:	24 85       	ldd	r18, Z+12	; 0x0c
    25c2:	35 85       	ldd	r19, Z+13	; 0x0d
    25c4:	2a 0d       	add	r18, r10
    25c6:	3b 1d       	adc	r19, r11
    25c8:	c9 01       	movw	r24, r18
    25ca:	b6 01       	movw	r22, r12
    25cc:	ae 01       	movw	r20, r28
    25ce:	0e 94 55 26 	call	0x4caa	; 0x4caa <memcpy>

    /* If the number of bytes written was less than the number that could be
     * written in the first write... */
    if( xCount > xFirstLength )
    25d2:	c0 17       	cp	r28, r16
    25d4:	d1 07       	cpc	r29, r17
    25d6:	80 f4       	brcc	.+32     	; 0x25f8 <prvWriteBytesToBuffer+0x6c>
    {
        /* ...then write the remaining bytes to the start of the buffer. */
        configASSERT( ( xCount - xFirstLength ) <= pxStreamBuffer->xLength );
        ( void ) memcpy( ( void * ) pxStreamBuffer->pucBuffer, ( const void * ) &( pucData[ xFirstLength ] ), xCount - xFirstLength ); /*lint !e9087 memcpy() requires void *. */
    25d8:	f8 01       	movw	r30, r16
    25da:	ec 1b       	sub	r30, r28
    25dc:	fd 0b       	sbc	r31, r29
    25de:	96 01       	movw	r18, r12
    25e0:	2c 0f       	add	r18, r28
    25e2:	3d 1f       	adc	r19, r29
    25e4:	d7 01       	movw	r26, r14
    25e6:	1c 96       	adiw	r26, 0x0c	; 12
    25e8:	8c 91       	ld	r24, X
    25ea:	1c 97       	sbiw	r26, 0x0c	; 12
    25ec:	1d 96       	adiw	r26, 0x0d	; 13
    25ee:	9c 91       	ld	r25, X
    25f0:	b9 01       	movw	r22, r18
    25f2:	af 01       	movw	r20, r30
    25f4:	0e 94 55 26 	call	0x4caa	; 0x4caa <memcpy>
    else
    {
        mtCOVERAGE_TEST_MARKER();
    }

    xHead += xCount;
    25f8:	95 01       	movw	r18, r10
    25fa:	20 0f       	add	r18, r16
    25fc:	31 1f       	adc	r19, r17

    if( xHead >= pxStreamBuffer->xLength )
    25fe:	f7 01       	movw	r30, r14
    2600:	84 81       	ldd	r24, Z+4	; 0x04
    2602:	95 81       	ldd	r25, Z+5	; 0x05
    2604:	28 17       	cp	r18, r24
    2606:	39 07       	cpc	r19, r25
    2608:	10 f0       	brcs	.+4      	; 0x260e <prvWriteBytesToBuffer+0x82>
    {
        xHead -= pxStreamBuffer->xLength;
    260a:	28 1b       	sub	r18, r24
    260c:	39 0b       	sbc	r19, r25
    {
        mtCOVERAGE_TEST_MARKER();
    }

    return xHead;
}
    260e:	c9 01       	movw	r24, r18
    2610:	df 91       	pop	r29
    2612:	cf 91       	pop	r28
    2614:	1f 91       	pop	r17
    2616:	0f 91       	pop	r16
    2618:	ff 90       	pop	r15
    261a:	ef 90       	pop	r14
    261c:	df 90       	pop	r13
    261e:	cf 90       	pop	r12
    2620:	bf 90       	pop	r11
    2622:	af 90       	pop	r10
    2624:	08 95       	ret

00002626 <prvWriteMessageToBuffer>:
static size_t prvWriteMessageToBuffer( StreamBuffer_t * const pxStreamBuffer,
                                       const void * pvTxData,
                                       size_t xDataLengthBytes,
                                       size_t xSpace,
                                       size_t xRequiredSpace )
{
    2626:	af 92       	push	r10
    2628:	bf 92       	push	r11
    262a:	cf 92       	push	r12
    262c:	df 92       	push	r13
    262e:	ef 92       	push	r14
    2630:	ff 92       	push	r15
    2632:	0f 93       	push	r16
    2634:	1f 93       	push	r17
    2636:	df 93       	push	r29
    2638:	cf 93       	push	r28
    263a:	00 d0       	rcall	.+0      	; 0x263c <prvWriteMessageToBuffer+0x16>
    263c:	cd b7       	in	r28, 0x3d	; 61
    263e:	de b7       	in	r29, 0x3e	; 62
    2640:	6c 01       	movw	r12, r24
    2642:	5b 01       	movw	r10, r22
    2644:	7a 01       	movw	r14, r20
    size_t xNextHead = pxStreamBuffer->xHead;
    2646:	dc 01       	movw	r26, r24
    2648:	12 96       	adiw	r26, 0x02	; 2
    264a:	ed 91       	ld	r30, X+
    264c:	fc 91       	ld	r31, X
    264e:	13 97       	sbiw	r26, 0x03	; 3
    configMESSAGE_BUFFER_LENGTH_TYPE xMessageLength;

    if( ( pxStreamBuffer->ucFlags & sbFLAGS_IS_MESSAGE_BUFFER ) != ( uint8_t ) 0 )
    2650:	1e 96       	adiw	r26, 0x0e	; 14
    2652:	8c 91       	ld	r24, X
    2654:	80 ff       	sbrs	r24, 0
    2656:	13 c0       	rjmp	.+38     	; 0x267e <prvWriteMessageToBuffer+0x58>
        xMessageLength = ( configMESSAGE_BUFFER_LENGTH_TYPE ) xDataLengthBytes;

        /* Ensure the data length given fits within configMESSAGE_BUFFER_LENGTH_TYPE. */
        configASSERT( ( size_t ) xMessageLength == xDataLengthBytes );

        if( xSpace >= xRequiredSpace )
    2658:	20 17       	cp	r18, r16
    265a:	31 07       	cpc	r19, r17
    265c:	18 f4       	brcc	.+6      	; 0x2664 <prvWriteMessageToBuffer+0x3e>
    265e:	ee 24       	eor	r14, r14
    2660:	ff 24       	eor	r15, r15
    2662:	1d c0       	rjmp	.+58     	; 0x269e <prvWriteMessageToBuffer+0x78>
    if( ( pxStreamBuffer->ucFlags & sbFLAGS_IS_MESSAGE_BUFFER ) != ( uint8_t ) 0 )
    {
        /* This is a message buffer, as opposed to a stream buffer. */

        /* Convert xDataLengthBytes to the message length type. */
        xMessageLength = ( configMESSAGE_BUFFER_LENGTH_TYPE ) xDataLengthBytes;
    2664:	5a 83       	std	Y+2, r21	; 0x02
    2666:	49 83       	std	Y+1, r20	; 0x01
        if( xSpace >= xRequiredSpace )
        {
            /* There is enough space to write both the message length and the message
             * itself into the buffer.  Start by writing the length of the data, the data
             * itself will be written later in this function. */
            xNextHead = prvWriteBytesToBuffer( pxStreamBuffer, ( const uint8_t * ) &( xMessageLength ), sbBYTES_TO_STORE_MESSAGE_LENGTH, xNextHead );
    2668:	c6 01       	movw	r24, r12
    266a:	be 01       	movw	r22, r28
    266c:	6f 5f       	subi	r22, 0xFF	; 255
    266e:	7f 4f       	sbci	r23, 0xFF	; 255
    2670:	42 e0       	ldi	r20, 0x02	; 2
    2672:	50 e0       	ldi	r21, 0x00	; 0
    2674:	9f 01       	movw	r18, r30
    2676:	0e 94 c6 12 	call	0x258c	; 0x258c <prvWriteBytesToBuffer>
    267a:	fc 01       	movw	r30, r24
    267c:	04 c0       	rjmp	.+8      	; 0x2686 <prvWriteMessageToBuffer+0x60>
    else
    {
        /* This is a stream buffer, as opposed to a message buffer, so writing a
         * stream of bytes rather than discrete messages.  Plan to write as many
         * bytes as possible. */
        xDataLengthBytes = configMIN( xDataLengthBytes, xSpace );
    267e:	24 17       	cp	r18, r20
    2680:	35 07       	cpc	r19, r21
    2682:	08 f4       	brcc	.+2      	; 0x2686 <prvWriteMessageToBuffer+0x60>
    2684:	79 01       	movw	r14, r18
    }

    if( xDataLengthBytes != ( size_t ) 0 )
    2686:	e1 14       	cp	r14, r1
    2688:	f1 04       	cpc	r15, r1
    268a:	49 f0       	breq	.+18     	; 0x269e <prvWriteMessageToBuffer+0x78>
    {
        /* Write the data to the buffer. */
        pxStreamBuffer->xHead = prvWriteBytesToBuffer( pxStreamBuffer, ( const uint8_t * ) pvTxData, xDataLengthBytes, xNextHead ); /*lint !e9079 Storage buffer is implemented as uint8_t for ease of sizing, alignment and access. */
    268c:	c6 01       	movw	r24, r12
    268e:	b5 01       	movw	r22, r10
    2690:	a7 01       	movw	r20, r14
    2692:	9f 01       	movw	r18, r30
    2694:	0e 94 c6 12 	call	0x258c	; 0x258c <prvWriteBytesToBuffer>
    2698:	f6 01       	movw	r30, r12
    269a:	93 83       	std	Z+3, r25	; 0x03
    269c:	82 83       	std	Z+2, r24	; 0x02
    }

    return xDataLengthBytes;
}
    269e:	c7 01       	movw	r24, r14
    26a0:	0f 90       	pop	r0
    26a2:	0f 90       	pop	r0
    26a4:	cf 91       	pop	r28
    26a6:	df 91       	pop	r29
    26a8:	1f 91       	pop	r17
    26aa:	0f 91       	pop	r16
    26ac:	ff 90       	pop	r15
    26ae:	ef 90       	pop	r14
    26b0:	df 90       	pop	r13
    26b2:	cf 90       	pop	r12
    26b4:	bf 90       	pop	r11
    26b6:	af 90       	pop	r10
    26b8:	08 95       	ret

000026ba <xStreamBufferSendFromISR>:

size_t xStreamBufferSendFromISR( StreamBufferHandle_t xStreamBuffer,
                                 const void * pvTxData,
                                 size_t xDataLengthBytes,
                                 BaseType_t * const pxHigherPriorityTaskWoken )
{
    26ba:	af 92       	push	r10
    26bc:	bf 92       	push	r11
    26be:	cf 92       	push	r12
    26c0:	df 92       	push	r13
    26c2:	ef 92       	push	r14
    26c4:	ff 92       	push	r15
    26c6:	0f 93       	push	r16
    26c8:	1f 93       	push	r17
    26ca:	cf 93       	push	r28
    26cc:	df 93       	push	r29
    26ce:	ec 01       	movw	r28, r24
    26d0:	5b 01       	movw	r10, r22
    26d2:	8a 01       	movw	r16, r20
    26d4:	69 01       	movw	r12, r18

    /* This send function is used to write to both message buffers and stream
     * buffers.  If this is a message buffer then the space needed must be
     * increased by the amount of bytes needed to store the length of the
     * message. */
    if( ( pxStreamBuffer->ucFlags & sbFLAGS_IS_MESSAGE_BUFFER ) != ( uint8_t ) 0 )
    26d6:	8e 85       	ldd	r24, Y+14	; 0x0e
    26d8:	80 fd       	sbrc	r24, 0
    26da:	02 c0       	rjmp	.+4      	; 0x26e0 <xStreamBufferSendFromISR+0x26>
    26dc:	7a 01       	movw	r14, r20
    26de:	05 c0       	rjmp	.+10     	; 0x26ea <xStreamBufferSendFromISR+0x30>
    {
        xRequiredSpace += sbBYTES_TO_STORE_MESSAGE_LENGTH;
    26e0:	82 e0       	ldi	r24, 0x02	; 2
    26e2:	e8 2e       	mov	r14, r24
    26e4:	f1 2c       	mov	r15, r1
    26e6:	e4 0e       	add	r14, r20
    26e8:	f5 1e       	adc	r15, r21
    else
    {
        mtCOVERAGE_TEST_MARKER();
    }

    xSpace = xStreamBufferSpacesAvailable( pxStreamBuffer );
    26ea:	ce 01       	movw	r24, r28
    26ec:	0e 94 19 11 	call	0x2232	; 0x2232 <xStreamBufferSpacesAvailable>
    26f0:	9c 01       	movw	r18, r24
    xReturn = prvWriteMessageToBuffer( pxStreamBuffer, pvTxData, xDataLengthBytes, xSpace, xRequiredSpace );
    26f2:	ce 01       	movw	r24, r28
    26f4:	b5 01       	movw	r22, r10
    26f6:	a8 01       	movw	r20, r16
    26f8:	87 01       	movw	r16, r14
    26fa:	0e 94 13 13 	call	0x2626	; 0x2626 <prvWriteMessageToBuffer>
    26fe:	5c 01       	movw	r10, r24

    if( xReturn > ( size_t ) 0 )
    2700:	00 97       	sbiw	r24, 0x00	; 0
    2702:	31 f1       	breq	.+76     	; 0x2750 <xStreamBufferSendFromISR+0x96>
static size_t prvBytesInBuffer( const StreamBuffer_t * const pxStreamBuffer )
{
/* Returns the distance between xTail and xHead. */
    size_t xCount;

    xCount = pxStreamBuffer->xLength + pxStreamBuffer->xHead;
    2704:	4c 81       	ldd	r20, Y+4	; 0x04
    2706:	5d 81       	ldd	r21, Y+5	; 0x05
    2708:	2a 81       	ldd	r18, Y+2	; 0x02
    270a:	3b 81       	ldd	r19, Y+3	; 0x03
    xCount -= pxStreamBuffer->xTail;
    270c:	88 81       	ld	r24, Y
    270e:	99 81       	ldd	r25, Y+1	; 0x01
static size_t prvBytesInBuffer( const StreamBuffer_t * const pxStreamBuffer )
{
/* Returns the distance between xTail and xHead. */
    size_t xCount;

    xCount = pxStreamBuffer->xLength + pxStreamBuffer->xHead;
    2710:	24 0f       	add	r18, r20
    2712:	35 1f       	adc	r19, r21
    xCount -= pxStreamBuffer->xTail;
    2714:	28 1b       	sub	r18, r24
    2716:	39 0b       	sbc	r19, r25

    if( xCount >= pxStreamBuffer->xLength )
    2718:	24 17       	cp	r18, r20
    271a:	35 07       	cpc	r19, r21
    271c:	10 f0       	brcs	.+4      	; 0x2722 <xStreamBufferSendFromISR+0x68>
    {
        xCount -= pxStreamBuffer->xLength;
    271e:	24 1b       	sub	r18, r20
    2720:	35 0b       	sbc	r19, r21
    xReturn = prvWriteMessageToBuffer( pxStreamBuffer, pvTxData, xDataLengthBytes, xSpace, xRequiredSpace );

    if( xReturn > ( size_t ) 0 )
    {
        /* Was a task waiting for the data? */
        if( prvBytesInBuffer( pxStreamBuffer ) >= pxStreamBuffer->xTriggerLevelBytes )
    2722:	8e 81       	ldd	r24, Y+6	; 0x06
    2724:	9f 81       	ldd	r25, Y+7	; 0x07
    2726:	28 17       	cp	r18, r24
    2728:	39 07       	cpc	r19, r25
    272a:	90 f0       	brcs	.+36     	; 0x2750 <xStreamBufferSendFromISR+0x96>
        {
            prvSEND_COMPLETE_FROM_ISR( pxStreamBuffer, pxHigherPriorityTaskWoken );
    272c:	88 85       	ldd	r24, Y+8	; 0x08
    272e:	99 85       	ldd	r25, Y+9	; 0x09
    2730:	89 2b       	or	r24, r25
    2732:	71 f0       	breq	.+28     	; 0x2750 <xStreamBufferSendFromISR+0x96>
    2734:	88 85       	ldd	r24, Y+8	; 0x08
    2736:	99 85       	ldd	r25, Y+9	; 0x09
    2738:	60 e0       	ldi	r22, 0x00	; 0
    273a:	20 e0       	ldi	r18, 0x00	; 0
    273c:	30 e0       	ldi	r19, 0x00	; 0
    273e:	40 e0       	ldi	r20, 0x00	; 0
    2740:	50 e0       	ldi	r21, 0x00	; 0
    2742:	00 e0       	ldi	r16, 0x00	; 0
    2744:	ee 24       	eor	r14, r14
    2746:	ff 24       	eor	r15, r15
    2748:	0e 94 d5 18 	call	0x31aa	; 0x31aa <xTaskGenericNotifyFromISR>
    274c:	19 86       	std	Y+9, r1	; 0x09
    274e:	18 86       	std	Y+8, r1	; 0x08
    }

    traceSTREAM_BUFFER_SEND_FROM_ISR( xStreamBuffer, xReturn );

    return xReturn;
}
    2750:	c5 01       	movw	r24, r10
    2752:	df 91       	pop	r29
    2754:	cf 91       	pop	r28
    2756:	1f 91       	pop	r17
    2758:	0f 91       	pop	r16
    275a:	ff 90       	pop	r15
    275c:	ef 90       	pop	r14
    275e:	df 90       	pop	r13
    2760:	cf 90       	pop	r12
    2762:	bf 90       	pop	r11
    2764:	af 90       	pop	r10
    2766:	08 95       	ret

00002768 <xStreamBufferReceive>:

size_t xStreamBufferReceive( StreamBufferHandle_t xStreamBuffer,
                             void * pvRxData,
                             size_t xBufferLengthBytes,
                             TickType_t xTicksToWait )
{
    2768:	6f 92       	push	r6
    276a:	7f 92       	push	r7
    276c:	8f 92       	push	r8
    276e:	9f 92       	push	r9
    2770:	af 92       	push	r10
    2772:	bf 92       	push	r11
    2774:	cf 92       	push	r12
    2776:	df 92       	push	r13
    2778:	ef 92       	push	r14
    277a:	ff 92       	push	r15
    277c:	0f 93       	push	r16
    277e:	1f 93       	push	r17
    2780:	cf 93       	push	r28
    2782:	df 93       	push	r29
    2784:	ec 01       	movw	r28, r24
    2786:	4b 01       	movw	r8, r22
    2788:	3a 01       	movw	r6, r20
    278a:	69 01       	movw	r12, r18
    /* This receive function is used by both message buffers, which store
     * discrete messages, and stream buffers, which store a continuous stream of
     * bytes.  Discrete messages include an additional
     * sbBYTES_TO_STORE_MESSAGE_LENGTH bytes that hold the length of the
     * message. */
    if( ( pxStreamBuffer->ucFlags & sbFLAGS_IS_MESSAGE_BUFFER ) != ( uint8_t ) 0 )
    278c:	8e 85       	ldd	r24, Y+14	; 0x0e
    278e:	80 fd       	sbrc	r24, 0
    2790:	03 c0       	rjmp	.+6      	; 0x2798 <xStreamBufferReceive+0x30>
    2792:	aa 24       	eor	r10, r10
    2794:	bb 24       	eor	r11, r11
    2796:	03 c0       	rjmp	.+6      	; 0x279e <xStreamBufferReceive+0x36>
    2798:	92 e0       	ldi	r25, 0x02	; 2
    279a:	a9 2e       	mov	r10, r25
    279c:	b1 2c       	mov	r11, r1
    279e:	2c 81       	ldd	r18, Y+4	; 0x04
    27a0:	3d 81       	ldd	r19, Y+5	; 0x05
    else
    {
        xBytesToStoreMessageLength = 0;
    }

    if( xTicksToWait != ( TickType_t ) 0 )
    27a2:	c1 14       	cp	r12, r1
    27a4:	d1 04       	cpc	r13, r1
    27a6:	91 f1       	breq	.+100    	; 0x280c <xStreamBufferReceive+0xa4>
    {
        /* Checking if there is data and clearing the notification state must be
         * performed atomically. */
        taskENTER_CRITICAL();
    27a8:	0f b6       	in	r0, 0x3f	; 63
    27aa:	f8 94       	cli
    27ac:	0f 92       	push	r0
static size_t prvBytesInBuffer( const StreamBuffer_t * const pxStreamBuffer )
{
/* Returns the distance between xTail and xHead. */
    size_t xCount;

    xCount = pxStreamBuffer->xLength + pxStreamBuffer->xHead;
    27ae:	0a 81       	ldd	r16, Y+2	; 0x02
    27b0:	1b 81       	ldd	r17, Y+3	; 0x03
    xCount -= pxStreamBuffer->xTail;
    27b2:	88 81       	ld	r24, Y
    27b4:	99 81       	ldd	r25, Y+1	; 0x01
    27b6:	02 0f       	add	r16, r18
    27b8:	13 1f       	adc	r17, r19
    27ba:	08 1b       	sub	r16, r24
    27bc:	19 0b       	sbc	r17, r25

    if( xCount >= pxStreamBuffer->xLength )
    27be:	02 17       	cp	r16, r18
    27c0:	13 07       	cpc	r17, r19
    27c2:	10 f0       	brcs	.+4      	; 0x27c8 <xStreamBufferReceive+0x60>
    {
        xCount -= pxStreamBuffer->xLength;
    27c4:	02 1b       	sub	r16, r18
    27c6:	13 0b       	sbc	r17, r19
            /* If this function was invoked by a message buffer read then
             * xBytesToStoreMessageLength holds the number of bytes used to hold
             * the length of the next discrete message.  If this function was
             * invoked by a stream buffer read then xBytesToStoreMessageLength will
             * be 0. */
            if( xBytesAvailable <= xBytesToStoreMessageLength )
    27c8:	a0 16       	cp	r10, r16
    27ca:	b1 06       	cpc	r11, r17
    27cc:	48 f0       	brcs	.+18     	; 0x27e0 <xStreamBufferReceive+0x78>
            {
                /* Clear notification state as going to wait for data. */
                ( void ) xTaskNotifyStateClear( NULL );
    27ce:	80 e0       	ldi	r24, 0x00	; 0
    27d0:	90 e0       	ldi	r25, 0x00	; 0
    27d2:	60 e0       	ldi	r22, 0x00	; 0
    27d4:	0e 94 83 1a 	call	0x3506	; 0x3506 <xTaskGenericNotifyStateClear>

                /* Should only be one reader. */
                configASSERT( pxStreamBuffer->xTaskWaitingToReceive == NULL );
                pxStreamBuffer->xTaskWaitingToReceive = xTaskGetCurrentTaskHandle();
    27d8:	0e 94 a4 18 	call	0x3148	; 0x3148 <xTaskGetCurrentTaskHandle>
    27dc:	99 87       	std	Y+9, r25	; 0x09
    27de:	88 87       	std	Y+8, r24	; 0x08
            else
            {
                mtCOVERAGE_TEST_MARKER();
            }
        }
        taskEXIT_CRITICAL();
    27e0:	0f 90       	pop	r0
    27e2:	0f be       	out	0x3f, r0	; 63

        if( xBytesAvailable <= xBytesToStoreMessageLength )
    27e4:	a0 16       	cp	r10, r16
    27e6:	b1 06       	cpc	r11, r17
    27e8:	20 f1       	brcs	.+72     	; 0x2832 <xStreamBufferReceive+0xca>
        {
            /* Wait for data to be available. */
            traceBLOCKING_ON_STREAM_BUFFER_RECEIVE( xStreamBuffer );
            ( void ) xTaskNotifyWait( ( uint32_t ) 0, ( uint32_t ) 0, NULL, xTicksToWait );
    27ea:	80 e0       	ldi	r24, 0x00	; 0
    27ec:	40 e0       	ldi	r20, 0x00	; 0
    27ee:	50 e0       	ldi	r21, 0x00	; 0
    27f0:	60 e0       	ldi	r22, 0x00	; 0
    27f2:	70 e0       	ldi	r23, 0x00	; 0
    27f4:	00 e0       	ldi	r16, 0x00	; 0
    27f6:	10 e0       	ldi	r17, 0x00	; 0
    27f8:	20 e0       	ldi	r18, 0x00	; 0
    27fa:	30 e0       	ldi	r19, 0x00	; 0
    27fc:	ee 24       	eor	r14, r14
    27fe:	ff 24       	eor	r15, r15
    2800:	0e 94 c9 1e 	call	0x3d92	; 0x3d92 <xTaskGenericNotifyWait>
            pxStreamBuffer->xTaskWaitingToReceive = NULL;
    2804:	19 86       	std	Y+9, r1	; 0x09
    2806:	18 86       	std	Y+8, r1	; 0x08
static size_t prvBytesInBuffer( const StreamBuffer_t * const pxStreamBuffer )
{
/* Returns the distance between xTail and xHead. */
    size_t xCount;

    xCount = pxStreamBuffer->xLength + pxStreamBuffer->xHead;
    2808:	2c 81       	ldd	r18, Y+4	; 0x04
    280a:	3d 81       	ldd	r19, Y+5	; 0x05
    280c:	0a 81       	ldd	r16, Y+2	; 0x02
    280e:	1b 81       	ldd	r17, Y+3	; 0x03
    xCount -= pxStreamBuffer->xTail;
    2810:	88 81       	ld	r24, Y
    2812:	99 81       	ldd	r25, Y+1	; 0x01
    2814:	02 0f       	add	r16, r18
    2816:	13 1f       	adc	r17, r19
    2818:	08 1b       	sub	r16, r24
    281a:	19 0b       	sbc	r17, r25

    if( xCount >= pxStreamBuffer->xLength )
    281c:	02 17       	cp	r16, r18
    281e:	13 07       	cpc	r17, r19
    2820:	10 f0       	brcs	.+4      	; 0x2826 <xStreamBufferReceive+0xbe>
    {
        xCount -= pxStreamBuffer->xLength;
    2822:	02 1b       	sub	r16, r18
    2824:	13 0b       	sbc	r17, r19
    /* Whether receiving a discrete message (where xBytesToStoreMessageLength
     * holds the number of bytes used to store the message length) or a stream of
     * bytes (where xBytesToStoreMessageLength is zero), the number of bytes
     * available must be greater than xBytesToStoreMessageLength to be able to
     * read bytes from the buffer. */
    if( xBytesAvailable > xBytesToStoreMessageLength )
    2826:	a0 16       	cp	r10, r16
    2828:	b1 06       	cpc	r11, r17
    282a:	18 f0       	brcs	.+6      	; 0x2832 <xStreamBufferReceive+0xca>
    282c:	cc 24       	eor	r12, r12
    282e:	dd 24       	eor	r13, r13
    2830:	1f c0       	rjmp	.+62     	; 0x2870 <xStreamBufferReceive+0x108>
    {
        xReceivedLength = prvReadMessageFromBuffer( pxStreamBuffer, pvRxData, xBufferLengthBytes, xBytesAvailable );
    2832:	ce 01       	movw	r24, r28
    2834:	b4 01       	movw	r22, r8
    2836:	a3 01       	movw	r20, r6
    2838:	98 01       	movw	r18, r16
    283a:	0e 94 03 12 	call	0x2406	; 0x2406 <prvReadMessageFromBuffer>
    283e:	6c 01       	movw	r12, r24

        /* Was a task waiting for space in the buffer? */
        if( xReceivedLength != ( size_t ) 0 )
    2840:	00 97       	sbiw	r24, 0x00	; 0
    2842:	b1 f0       	breq	.+44     	; 0x2870 <xStreamBufferReceive+0x108>
        {
            traceSTREAM_BUFFER_RECEIVE( xStreamBuffer, xReceivedLength );
            prvRECEIVE_COMPLETED( xStreamBuffer );
    2844:	0e 94 89 15 	call	0x2b12	; 0x2b12 <vTaskSuspendAll>
    2848:	8a 85       	ldd	r24, Y+10	; 0x0a
    284a:	9b 85       	ldd	r25, Y+11	; 0x0b
    284c:	89 2b       	or	r24, r25
    284e:	71 f0       	breq	.+28     	; 0x286c <xStreamBufferReceive+0x104>
    2850:	8a 85       	ldd	r24, Y+10	; 0x0a
    2852:	9b 85       	ldd	r25, Y+11	; 0x0b
    2854:	60 e0       	ldi	r22, 0x00	; 0
    2856:	20 e0       	ldi	r18, 0x00	; 0
    2858:	30 e0       	ldi	r19, 0x00	; 0
    285a:	40 e0       	ldi	r20, 0x00	; 0
    285c:	50 e0       	ldi	r21, 0x00	; 0
    285e:	00 e0       	ldi	r16, 0x00	; 0
    2860:	ee 24       	eor	r14, r14
    2862:	ff 24       	eor	r15, r15
    2864:	0e 94 cd 1a 	call	0x359a	; 0x359a <xTaskGenericNotify>
    2868:	1b 86       	std	Y+11, r1	; 0x0b
    286a:	1a 86       	std	Y+10, r1	; 0x0a
    286c:	0e 94 9b 1b 	call	0x3736	; 0x3736 <xTaskResumeAll>
        traceSTREAM_BUFFER_RECEIVE_FAILED( xStreamBuffer );
        mtCOVERAGE_TEST_MARKER();
    }

    return xReceivedLength;
}
    2870:	c6 01       	movw	r24, r12
    2872:	df 91       	pop	r29
    2874:	cf 91       	pop	r28
    2876:	1f 91       	pop	r17
    2878:	0f 91       	pop	r16
    287a:	ff 90       	pop	r15
    287c:	ef 90       	pop	r14
    287e:	df 90       	pop	r13
    2880:	cf 90       	pop	r12
    2882:	bf 90       	pop	r11
    2884:	af 90       	pop	r10
    2886:	9f 90       	pop	r9
    2888:	8f 90       	pop	r8
    288a:	7f 90       	pop	r7
    288c:	6f 90       	pop	r6
    288e:	08 95       	ret

00002890 <xStreamBufferSend>:

size_t xStreamBufferSend( StreamBufferHandle_t xStreamBuffer,
                          const void * pvTxData,
                          size_t xDataLengthBytes,
                          TickType_t xTicksToWait )
{
    2890:	2f 92       	push	r2
    2892:	3f 92       	push	r3
    2894:	4f 92       	push	r4
    2896:	5f 92       	push	r5
    2898:	6f 92       	push	r6
    289a:	7f 92       	push	r7
    289c:	8f 92       	push	r8
    289e:	9f 92       	push	r9
    28a0:	af 92       	push	r10
    28a2:	bf 92       	push	r11
    28a4:	cf 92       	push	r12
    28a6:	df 92       	push	r13
    28a8:	ef 92       	push	r14
    28aa:	ff 92       	push	r15
    28ac:	0f 93       	push	r16
    28ae:	1f 93       	push	r17
    28b0:	df 93       	push	r29
    28b2:	cf 93       	push	r28
    28b4:	cd b7       	in	r28, 0x3d	; 61
    28b6:	de b7       	in	r29, 0x3e	; 62
    28b8:	27 97       	sbiw	r28, 0x07	; 7
    28ba:	0f b6       	in	r0, 0x3f	; 63
    28bc:	f8 94       	cli
    28be:	de bf       	out	0x3e, r29	; 62
    28c0:	0f be       	out	0x3f, r0	; 63
    28c2:	cd bf       	out	0x3d, r28	; 61
    28c4:	5c 01       	movw	r10, r24
    28c6:	7f 83       	std	Y+7, r23	; 0x07
    28c8:	6e 83       	std	Y+6, r22	; 0x06
    28ca:	2a 01       	movw	r4, r20
    28cc:	3d 83       	std	Y+5, r19	; 0x05
    28ce:	2c 83       	std	Y+4, r18	; 0x04
    configASSERT( pvTxData );
    configASSERT( pxStreamBuffer );

    /* The maximum amount of space a stream buffer will ever report is its length
     * minus 1. */
    xMaxReportedSpace = pxStreamBuffer->xLength - ( size_t ) 1;
    28d0:	fc 01       	movw	r30, r24
    28d2:	24 81       	ldd	r18, Z+4	; 0x04
    28d4:	35 81       	ldd	r19, Z+5	; 0x05
    28d6:	21 50       	subi	r18, 0x01	; 1
    28d8:	30 40       	sbci	r19, 0x00	; 0

    /* This send function is used to write to both message buffers and stream
     * buffers.  If this is a message buffer then the space needed must be
     * increased by the amount of bytes needed to store the length of the
     * message. */
    if( ( pxStreamBuffer->ucFlags & sbFLAGS_IS_MESSAGE_BUFFER ) != ( uint8_t ) 0 )
    28da:	86 85       	ldd	r24, Z+14	; 0x0e
    28dc:	80 ff       	sbrs	r24, 0
    28de:	0b c0       	rjmp	.+22     	; 0x28f6 <xStreamBufferSend+0x66>
    {
        xRequiredSpace += sbBYTES_TO_STORE_MESSAGE_LENGTH;
    28e0:	42 e0       	ldi	r20, 0x02	; 2
    28e2:	64 2e       	mov	r6, r20
    28e4:	71 2c       	mov	r7, r1
    28e6:	64 0c       	add	r6, r4
    28e8:	75 1c       	adc	r7, r5
        /* Overflow? */
        configASSERT( xRequiredSpace > xDataLengthBytes );

        /* If this is a message buffer then it must be possible to write the
         * whole message. */
        if( xRequiredSpace > xMaxReportedSpace )
    28ea:	26 15       	cp	r18, r6
    28ec:	37 05       	cpc	r19, r7
    28ee:	48 f4       	brcc	.+18     	; 0x2902 <xStreamBufferSend+0x72>
        {
            /* The message would not fit even if the entire buffer was empty,
             * so don't wait for space. */
            xTicksToWait = ( TickType_t ) 0;
    28f0:	1d 82       	std	Y+5, r1	; 0x05
    28f2:	1c 82       	std	Y+4, r1	; 0x04
    28f4:	06 c0       	rjmp	.+12     	; 0x2902 <xStreamBufferSend+0x72>
    else
    {
        /* If this is a stream buffer then it is acceptable to write only part
         * of the message to the buffer.  Cap the length to the total length of
         * the buffer. */
        if( xRequiredSpace > xMaxReportedSpace )
    28f6:	24 17       	cp	r18, r20
    28f8:	35 07       	cpc	r19, r21
    28fa:	10 f4       	brcc	.+4      	; 0x2900 <xStreamBufferSend+0x70>
    28fc:	39 01       	movw	r6, r18
    28fe:	01 c0       	rjmp	.+2      	; 0x2902 <xStreamBufferSend+0x72>
    2900:	3a 01       	movw	r6, r20
        {
            mtCOVERAGE_TEST_MARKER();
        }
    }

    if( xTicksToWait != ( TickType_t ) 0 )
    2902:	8c 81       	ldd	r24, Y+4	; 0x04
    2904:	9d 81       	ldd	r25, Y+5	; 0x05
    2906:	89 2b       	or	r24, r25
    2908:	09 f4       	brne	.+2      	; 0x290c <xStreamBufferSend+0x7c>
    290a:	3d c0       	rjmp	.+122    	; 0x2986 <xStreamBufferSend+0xf6>
    {
        vTaskSetTimeOutState( &xTimeOut );
    290c:	8e 01       	movw	r16, r28
    290e:	0f 5f       	subi	r16, 0xFF	; 255
    2910:	1f 4f       	sbci	r17, 0xFF	; 255
    2912:	c8 01       	movw	r24, r16
    2914:	0e 94 4d 18 	call	0x309a	; 0x309a <vTaskSetTimeOutState>
            taskEXIT_CRITICAL();

            traceBLOCKING_ON_STREAM_BUFFER_SEND( xStreamBuffer );
            ( void ) xTaskNotifyWait( ( uint32_t ) 0, ( uint32_t ) 0, NULL, xTicksToWait );
            pxStreamBuffer->xTaskWaitingToSend = NULL;
        } while( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE );
    2918:	18 01       	movw	r2, r16

        do
        {
            /* Wait until the required number of bytes are free in the message
             * buffer. */
            taskENTER_CRITICAL();
    291a:	0f b6       	in	r0, 0x3f	; 63
    291c:	f8 94       	cli
    291e:	0f 92       	push	r0
            {
                xSpace = xStreamBufferSpacesAvailable( pxStreamBuffer );
    2920:	c5 01       	movw	r24, r10
    2922:	0e 94 19 11 	call	0x2232	; 0x2232 <xStreamBufferSpacesAvailable>
    2926:	4c 01       	movw	r8, r24

                if( xSpace < xRequiredSpace )
    2928:	86 15       	cp	r24, r6
    292a:	97 05       	cpc	r25, r7
    292c:	38 f5       	brcc	.+78     	; 0x297c <xStreamBufferSend+0xec>
                {
                    /* Clear notification state as going to wait for space. */
                    ( void ) xTaskNotifyStateClear( NULL );
    292e:	80 e0       	ldi	r24, 0x00	; 0
    2930:	90 e0       	ldi	r25, 0x00	; 0
    2932:	60 e0       	ldi	r22, 0x00	; 0
    2934:	0e 94 83 1a 	call	0x3506	; 0x3506 <xTaskGenericNotifyStateClear>

                    /* Should only be one writer. */
                    configASSERT( pxStreamBuffer->xTaskWaitingToSend == NULL );
                    pxStreamBuffer->xTaskWaitingToSend = xTaskGetCurrentTaskHandle();
    2938:	0e 94 a4 18 	call	0x3148	; 0x3148 <xTaskGetCurrentTaskHandle>
    293c:	f5 01       	movw	r30, r10
    293e:	93 87       	std	Z+11, r25	; 0x0b
    2940:	82 87       	std	Z+10, r24	; 0x0a
                {
                    taskEXIT_CRITICAL();
                    break;
                }
            }
            taskEXIT_CRITICAL();
    2942:	0f 90       	pop	r0
    2944:	0f be       	out	0x3f, r0	; 63

            traceBLOCKING_ON_STREAM_BUFFER_SEND( xStreamBuffer );
            ( void ) xTaskNotifyWait( ( uint32_t ) 0, ( uint32_t ) 0, NULL, xTicksToWait );
    2946:	cc 80       	ldd	r12, Y+4	; 0x04
    2948:	dd 80       	ldd	r13, Y+5	; 0x05
    294a:	80 e0       	ldi	r24, 0x00	; 0
    294c:	40 e0       	ldi	r20, 0x00	; 0
    294e:	50 e0       	ldi	r21, 0x00	; 0
    2950:	60 e0       	ldi	r22, 0x00	; 0
    2952:	70 e0       	ldi	r23, 0x00	; 0
    2954:	00 e0       	ldi	r16, 0x00	; 0
    2956:	10 e0       	ldi	r17, 0x00	; 0
    2958:	20 e0       	ldi	r18, 0x00	; 0
    295a:	30 e0       	ldi	r19, 0x00	; 0
    295c:	ee 24       	eor	r14, r14
    295e:	ff 24       	eor	r15, r15
    2960:	0e 94 c9 1e 	call	0x3d92	; 0x3d92 <xTaskGenericNotifyWait>
            pxStreamBuffer->xTaskWaitingToSend = NULL;
    2964:	f5 01       	movw	r30, r10
    2966:	13 86       	std	Z+11, r1	; 0x0b
    2968:	12 86       	std	Z+10, r1	; 0x0a
        } while( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE );
    296a:	c1 01       	movw	r24, r2
    296c:	be 01       	movw	r22, r28
    296e:	6c 5f       	subi	r22, 0xFC	; 252
    2970:	7f 4f       	sbci	r23, 0xFF	; 255
    2972:	0e 94 68 18 	call	0x30d0	; 0x30d0 <xTaskCheckForTimeOut>
    2976:	88 23       	and	r24, r24
    2978:	81 f2       	breq	.-96     	; 0x291a <xStreamBufferSend+0x8a>
    297a:	02 c0       	rjmp	.+4      	; 0x2980 <xStreamBufferSend+0xf0>
                    configASSERT( pxStreamBuffer->xTaskWaitingToSend == NULL );
                    pxStreamBuffer->xTaskWaitingToSend = xTaskGetCurrentTaskHandle();
                }
                else
                {
                    taskEXIT_CRITICAL();
    297c:	0f 90       	pop	r0
    297e:	0f be       	out	0x3f, r0	; 63
    2980:	94 01       	movw	r18, r8
    else
    {
        mtCOVERAGE_TEST_MARKER();
    }

    if( xSpace == ( size_t ) 0 )
    2982:	89 28       	or	r8, r9
    2984:	21 f4       	brne	.+8      	; 0x298e <xStreamBufferSend+0xfe>
    {
        xSpace = xStreamBufferSpacesAvailable( pxStreamBuffer );
    2986:	c5 01       	movw	r24, r10
    2988:	0e 94 19 11 	call	0x2232	; 0x2232 <xStreamBufferSpacesAvailable>
    298c:	9c 01       	movw	r18, r24
    else
    {
        mtCOVERAGE_TEST_MARKER();
    }

    xReturn = prvWriteMessageToBuffer( pxStreamBuffer, pvTxData, xDataLengthBytes, xSpace, xRequiredSpace );
    298e:	c5 01       	movw	r24, r10
    2990:	6e 81       	ldd	r22, Y+6	; 0x06
    2992:	7f 81       	ldd	r23, Y+7	; 0x07
    2994:	a2 01       	movw	r20, r4
    2996:	83 01       	movw	r16, r6
    2998:	0e 94 13 13 	call	0x2626	; 0x2626 <prvWriteMessageToBuffer>
    299c:	6c 01       	movw	r12, r24

    if( xReturn > ( size_t ) 0 )
    299e:	00 97       	sbiw	r24, 0x00	; 0
    29a0:	71 f1       	breq	.+92     	; 0x29fe <xStreamBufferSend+0x16e>
static size_t prvBytesInBuffer( const StreamBuffer_t * const pxStreamBuffer )
{
/* Returns the distance between xTail and xHead. */
    size_t xCount;

    xCount = pxStreamBuffer->xLength + pxStreamBuffer->xHead;
    29a2:	f5 01       	movw	r30, r10
    29a4:	44 81       	ldd	r20, Z+4	; 0x04
    29a6:	55 81       	ldd	r21, Z+5	; 0x05
    29a8:	22 81       	ldd	r18, Z+2	; 0x02
    29aa:	33 81       	ldd	r19, Z+3	; 0x03
    xCount -= pxStreamBuffer->xTail;
    29ac:	80 81       	ld	r24, Z
    29ae:	91 81       	ldd	r25, Z+1	; 0x01
static size_t prvBytesInBuffer( const StreamBuffer_t * const pxStreamBuffer )
{
/* Returns the distance between xTail and xHead. */
    size_t xCount;

    xCount = pxStreamBuffer->xLength + pxStreamBuffer->xHead;
    29b0:	24 0f       	add	r18, r20
    29b2:	35 1f       	adc	r19, r21
    xCount -= pxStreamBuffer->xTail;
    29b4:	28 1b       	sub	r18, r24
    29b6:	39 0b       	sbc	r19, r25

    if( xCount >= pxStreamBuffer->xLength )
    29b8:	24 17       	cp	r18, r20
    29ba:	35 07       	cpc	r19, r21
    29bc:	10 f0       	brcs	.+4      	; 0x29c2 <xStreamBufferSend+0x132>
    {
        xCount -= pxStreamBuffer->xLength;
    29be:	24 1b       	sub	r18, r20
    29c0:	35 0b       	sbc	r19, r21
    if( xReturn > ( size_t ) 0 )
    {
        traceSTREAM_BUFFER_SEND( xStreamBuffer, xReturn );

        /* Was a task waiting for the data? */
        if( prvBytesInBuffer( pxStreamBuffer ) >= pxStreamBuffer->xTriggerLevelBytes )
    29c2:	f5 01       	movw	r30, r10
    29c4:	86 81       	ldd	r24, Z+6	; 0x06
    29c6:	97 81       	ldd	r25, Z+7	; 0x07
    29c8:	28 17       	cp	r18, r24
    29ca:	39 07       	cpc	r19, r25
    29cc:	c0 f0       	brcs	.+48     	; 0x29fe <xStreamBufferSend+0x16e>
        {
            prvSEND_COMPLETED( pxStreamBuffer );
    29ce:	0e 94 89 15 	call	0x2b12	; 0x2b12 <vTaskSuspendAll>
    29d2:	f5 01       	movw	r30, r10
    29d4:	80 85       	ldd	r24, Z+8	; 0x08
    29d6:	91 85       	ldd	r25, Z+9	; 0x09
    29d8:	89 2b       	or	r24, r25
    29da:	79 f0       	breq	.+30     	; 0x29fa <xStreamBufferSend+0x16a>
    29dc:	80 85       	ldd	r24, Z+8	; 0x08
    29de:	91 85       	ldd	r25, Z+9	; 0x09
    29e0:	60 e0       	ldi	r22, 0x00	; 0
    29e2:	20 e0       	ldi	r18, 0x00	; 0
    29e4:	30 e0       	ldi	r19, 0x00	; 0
    29e6:	40 e0       	ldi	r20, 0x00	; 0
    29e8:	50 e0       	ldi	r21, 0x00	; 0
    29ea:	00 e0       	ldi	r16, 0x00	; 0
    29ec:	ee 24       	eor	r14, r14
    29ee:	ff 24       	eor	r15, r15
    29f0:	0e 94 cd 1a 	call	0x359a	; 0x359a <xTaskGenericNotify>
    29f4:	f5 01       	movw	r30, r10
    29f6:	11 86       	std	Z+9, r1	; 0x09
    29f8:	10 86       	std	Z+8, r1	; 0x08
    29fa:	0e 94 9b 1b 	call	0x3736	; 0x3736 <xTaskResumeAll>
        mtCOVERAGE_TEST_MARKER();
        traceSTREAM_BUFFER_SEND_FAILED( xStreamBuffer );
    }

    return xReturn;
}
    29fe:	c6 01       	movw	r24, r12
    2a00:	27 96       	adiw	r28, 0x07	; 7
    2a02:	0f b6       	in	r0, 0x3f	; 63
    2a04:	f8 94       	cli
    2a06:	de bf       	out	0x3e, r29	; 62
    2a08:	0f be       	out	0x3f, r0	; 63
    2a0a:	cd bf       	out	0x3d, r28	; 61
    2a0c:	cf 91       	pop	r28
    2a0e:	df 91       	pop	r29
    2a10:	1f 91       	pop	r17
    2a12:	0f 91       	pop	r16
    2a14:	ff 90       	pop	r15
    2a16:	ef 90       	pop	r14
    2a18:	df 90       	pop	r13
    2a1a:	cf 90       	pop	r12
    2a1c:	bf 90       	pop	r11
    2a1e:	af 90       	pop	r10
    2a20:	9f 90       	pop	r9
    2a22:	8f 90       	pop	r8
    2a24:	7f 90       	pop	r7
    2a26:	6f 90       	pop	r6
    2a28:	5f 90       	pop	r5
    2a2a:	4f 90       	pop	r4
    2a2c:	3f 90       	pop	r3
    2a2e:	2f 90       	pop	r2
    2a30:	08 95       	ret

00002a32 <xStreamBufferReset>:
    }
}
/*-----------------------------------------------------------*/

BaseType_t xStreamBufferReset( StreamBufferHandle_t xStreamBuffer )
{
    2a32:	fc 01       	movw	r30, r24
        uxStreamBufferNumber = pxStreamBuffer->uxStreamBufferNumber;
    }
    #endif

    /* Can only reset a message buffer if there are no tasks blocked on it. */
    taskENTER_CRITICAL();
    2a34:	0f b6       	in	r0, 0x3f	; 63
    2a36:	f8 94       	cli
    2a38:	0f 92       	push	r0
    {
        if( ( pxStreamBuffer->xTaskWaitingToReceive == NULL ) && ( pxStreamBuffer->xTaskWaitingToSend == NULL ) )
    2a3a:	80 85       	ldd	r24, Z+8	; 0x08
    2a3c:	91 85       	ldd	r25, Z+9	; 0x09
    2a3e:	89 2b       	or	r24, r25
    2a40:	c9 f4       	brne	.+50     	; 0x2a74 <xStreamBufferReset+0x42>
    2a42:	82 85       	ldd	r24, Z+10	; 0x0a
    2a44:	93 85       	ldd	r25, Z+11	; 0x0b
    2a46:	89 2b       	or	r24, r25
    2a48:	a9 f4       	brne	.+42     	; 0x2a74 <xStreamBufferReset+0x42>
                pxSendCallback = pxStreamBuffer->pxSendCompletedCallback;
                pxReceiveCallback = pxStreamBuffer->pxReceiveCompletedCallback;
            }
            #endif

            prvInitialiseNewStreamBuffer( pxStreamBuffer,
    2a4a:	24 85       	ldd	r18, Z+12	; 0x0c
    2a4c:	35 85       	ldd	r19, Z+13	; 0x0d
    2a4e:	44 81       	ldd	r20, Z+4	; 0x04
    2a50:	55 81       	ldd	r21, Z+5	; 0x05
    2a52:	66 81       	ldd	r22, Z+6	; 0x06
    2a54:	77 81       	ldd	r23, Z+7	; 0x07
    2a56:	96 85       	ldd	r25, Z+14	; 0x0e
        const BaseType_t xWriteValue = 0x55;
        configASSERT( memset( pucBuffer, ( int ) xWriteValue, xBufferSizeBytes ) == pucBuffer );
    } /*lint !e529 !e438 xWriteValue is only used if configASSERT() is defined. */
    #endif

    ( void ) memset( ( void * ) pxStreamBuffer, 0x00, sizeof( StreamBuffer_t ) ); /*lint !e9087 memset() requires void *. */
    2a58:	8f e0       	ldi	r24, 0x0F	; 15
    2a5a:	df 01       	movw	r26, r30
    2a5c:	1d 92       	st	X+, r1
    2a5e:	8a 95       	dec	r24
    2a60:	e9 f7       	brne	.-6      	; 0x2a5c <xStreamBufferReset+0x2a>
    pxStreamBuffer->pucBuffer = pucBuffer;
    2a62:	35 87       	std	Z+13, r19	; 0x0d
    2a64:	24 87       	std	Z+12, r18	; 0x0c
    pxStreamBuffer->xLength = xBufferSizeBytes;
    2a66:	55 83       	std	Z+5, r21	; 0x05
    2a68:	44 83       	std	Z+4, r20	; 0x04
    pxStreamBuffer->xTriggerLevelBytes = xTriggerLevelBytes;
    2a6a:	77 83       	std	Z+7, r23	; 0x07
    2a6c:	66 83       	std	Z+6, r22	; 0x06
    pxStreamBuffer->ucFlags = ucFlags;
    2a6e:	96 87       	std	Z+14, r25	; 0x0e
    2a70:	81 e0       	ldi	r24, 0x01	; 1
    2a72:	01 c0       	rjmp	.+2      	; 0x2a76 <xStreamBufferReset+0x44>
    2a74:	80 e0       	ldi	r24, 0x00	; 0
            traceSTREAM_BUFFER_RESET( xStreamBuffer );

            xReturn = pdPASS;
        }
    }
    taskEXIT_CRITICAL();
    2a76:	0f 90       	pop	r0
    2a78:	0f be       	out	0x3f, r0	; 63

    return xReturn;
}
    2a7a:	08 95       	ret

00002a7c <vStreamBufferDelete>:
    }
#endif /* ( configSUPPORT_STATIC_ALLOCATION == 1 ) */
/*-----------------------------------------------------------*/

void vStreamBufferDelete( StreamBufferHandle_t xStreamBuffer )
{
    2a7c:	fc 01       	movw	r30, r24

    configASSERT( pxStreamBuffer );

    traceSTREAM_BUFFER_DELETE( xStreamBuffer );

    if( ( pxStreamBuffer->ucFlags & sbFLAGS_IS_STATICALLY_ALLOCATED ) == ( uint8_t ) pdFALSE )
    2a7e:	86 85       	ldd	r24, Z+14	; 0x0e
    2a80:	81 fd       	sbrc	r24, 1
    2a82:	04 c0       	rjmp	.+8      	; 0x2a8c <vStreamBufferDelete+0x10>
    {
        #if ( configSUPPORT_DYNAMIC_ALLOCATION == 1 )
        {
            /* Both the structure and the buffer were allocated using a single call
            * to pvPortMalloc(), hence only one call to vPortFree() is required. */
            vPortFree( ( void * ) pxStreamBuffer ); /*lint !e9087 Standard free() semantics require void *, plus pxStreamBuffer was allocated by pvPortMalloc(). */
    2a84:	cf 01       	movw	r24, r30
    2a86:	0e 94 b2 07 	call	0xf64	; 0xf64 <vPortFree>
    2a8a:	08 95       	ret
    }
    else
    {
        /* The structure and buffer were not allocated dynamically and cannot be
         * freed - just scrub the structure so future use will assert. */
        ( void ) memset( pxStreamBuffer, 0x00, sizeof( StreamBuffer_t ) );
    2a8c:	8f e0       	ldi	r24, 0x0F	; 15
    2a8e:	df 01       	movw	r26, r30
    2a90:	1d 92       	st	X+, r1
    2a92:	8a 95       	dec	r24
    2a94:	e9 f7       	brne	.-6      	; 0x2a90 <vStreamBufferDelete+0x14>
    2a96:	08 95       	ret

00002a98 <xStreamBufferGenericCreate>:
    StreamBufferHandle_t xStreamBufferGenericCreate( size_t xBufferSizeBytes,
                                                     size_t xTriggerLevelBytes,
                                                     BaseType_t xIsMessageBuffer,
                                                     StreamBufferCallbackFunction_t pxSendCompletedCallback,
                                                     StreamBufferCallbackFunction_t pxReceiveCompletedCallback )
    {
    2a98:	cf 92       	push	r12
    2a9a:	df 92       	push	r13
    2a9c:	ff 92       	push	r15
    2a9e:	0f 93       	push	r16
    2aa0:	1f 93       	push	r17
    2aa2:	cf 93       	push	r28
    2aa4:	df 93       	push	r29
    2aa6:	6c 01       	movw	r12, r24
    2aa8:	8b 01       	movw	r16, r22
    2aaa:	f4 2e       	mov	r15, r20

        configASSERT( xTriggerLevelBytes <= xBufferSizeBytes );

        /* A trigger level of 0 would cause a waiting task to unblock even when
         * the buffer was empty. */
        if( xTriggerLevelBytes == ( size_t ) 0 )
    2aac:	61 15       	cp	r22, r1
    2aae:	71 05       	cpc	r23, r1
    2ab0:	11 f4       	brne	.+4      	; 0x2ab6 <xStreamBufferGenericCreate+0x1e>
    2ab2:	01 e0       	ldi	r16, 0x01	; 1
    2ab4:	10 e0       	ldi	r17, 0x00	; 0
         * and the buffer follows immediately after.  The requested size is
         * incremented so the free space is returned as the user would expect -
         * this is a quirk of the implementation that means otherwise the free
         * space would be reported as one byte smaller than would be logically
         * expected. */
        if( xBufferSizeBytes < ( xBufferSizeBytes + 1 + sizeof( StreamBuffer_t ) ) )
    2ab6:	c6 01       	movw	r24, r12
    2ab8:	40 96       	adiw	r24, 0x10	; 16
    2aba:	c8 16       	cp	r12, r24
    2abc:	d9 06       	cpc	r13, r25
    2abe:	18 f0       	brcs	.+6      	; 0x2ac6 <xStreamBufferGenericCreate+0x2e>
    2ac0:	a0 e0       	ldi	r26, 0x00	; 0
    2ac2:	b0 e0       	ldi	r27, 0x00	; 0
    2ac4:	1d c0       	rjmp	.+58     	; 0x2b00 <xStreamBufferGenericCreate+0x68>
        {
            xBufferSizeBytes++;
            pucAllocatedMemory = ( uint8_t * ) pvPortMalloc( xBufferSizeBytes + sizeof( StreamBuffer_t ) ); /*lint !e9079 malloc() only returns void*. */
    2ac6:	0e 94 c2 07 	call	0xf84	; 0xf84 <pvPortMalloc>
    2aca:	fc 01       	movw	r30, r24
    2acc:	dc 01       	movw	r26, r24
        else
        {
            pucAllocatedMemory = NULL;
        }

        if( pucAllocatedMemory != NULL )
    2ace:	00 97       	sbiw	r24, 0x00	; 0
    2ad0:	b9 f0       	breq	.+46     	; 0x2b00 <xStreamBufferGenericCreate+0x68>
        const BaseType_t xWriteValue = 0x55;
        configASSERT( memset( pucBuffer, ( int ) xWriteValue, xBufferSizeBytes ) == pucBuffer );
    } /*lint !e529 !e438 xWriteValue is only used if configASSERT() is defined. */
    #endif

    ( void ) memset( ( void * ) pxStreamBuffer, 0x00, sizeof( StreamBuffer_t ) ); /*lint !e9087 memset() requires void *. */
    2ad2:	8f e0       	ldi	r24, 0x0F	; 15
    2ad4:	ef 01       	movw	r28, r30
    2ad6:	19 92       	st	Y+, r1
    2ad8:	8a 95       	dec	r24
    2ada:	e9 f7       	brne	.-6      	; 0x2ad6 <xStreamBufferGenericCreate+0x3e>
    pxStreamBuffer->pucBuffer = pucBuffer;
    2adc:	1f 96       	adiw	r26, 0x0f	; 15
    2ade:	b5 87       	std	Z+13, r27	; 0x0d
    2ae0:	a4 87       	std	Z+12, r26	; 0x0c
    2ae2:	1f 97       	sbiw	r26, 0x0f	; 15
    pxStreamBuffer->xLength = xBufferSizeBytes;
    2ae4:	08 94       	sec
    2ae6:	c1 1c       	adc	r12, r1
    2ae8:	d1 1c       	adc	r13, r1
    2aea:	d5 82       	std	Z+5, r13	; 0x05
    2aec:	c4 82       	std	Z+4, r12	; 0x04
    pxStreamBuffer->xTriggerLevelBytes = xTriggerLevelBytes;
    2aee:	17 83       	std	Z+7, r17	; 0x07
    2af0:	06 83       	std	Z+6, r16	; 0x06
    pxStreamBuffer->ucFlags = ucFlags;
    2af2:	16 86       	std	Z+14, r1	; 0x0e
    2af4:	81 e0       	ldi	r24, 0x01	; 1
    2af6:	f8 16       	cp	r15, r24
    2af8:	19 f4       	brne	.+6      	; 0x2b00 <xStreamBufferGenericCreate+0x68>
    2afa:	1e 96       	adiw	r26, 0x0e	; 14
    2afc:	fc 92       	st	X, r15
    2afe:	1e 97       	sbiw	r26, 0x0e	; 14
        {
            traceSTREAM_BUFFER_CREATE_FAILED( xIsMessageBuffer );
        }

        return ( StreamBufferHandle_t ) pucAllocatedMemory; /*lint !e9087 !e826 Safe cast as allocated memory is aligned. */
    }
    2b00:	cd 01       	movw	r24, r26
    2b02:	df 91       	pop	r29
    2b04:	cf 91       	pop	r28
    2b06:	1f 91       	pop	r17
    2b08:	0f 91       	pop	r16
    2b0a:	ff 90       	pop	r15
    2b0c:	df 90       	pop	r13
    2b0e:	cf 90       	pop	r12
    2b10:	08 95       	ret

00002b12 <vTaskSuspendAll>:
     * do not otherwise exhibit real time behaviour. */
    portSOFTWARE_BARRIER();

    /* The scheduler is suspended if uxSchedulerSuspended is non-zero.  An increment
     * is used to allow calls to vTaskSuspendAll() to nest. */
    ++uxSchedulerSuspended;
    2b12:	80 91 f9 06 	lds	r24, 0x06F9
    2b16:	8f 5f       	subi	r24, 0xFF	; 255
    2b18:	80 93 f9 06 	sts	0x06F9, r24

    /* Enforces ordering for ports and optimised compilers that may otherwise place
     * the above increment elsewhere. */
    portMEMORY_BARRIER();
}
    2b1c:	08 95       	ret

00002b1e <xTaskGetTickCount>:
TickType_t xTaskGetTickCount( void )
{
    TickType_t xTicks;

    /* Critical section required if running on a 16 bit processor. */
    portTICK_TYPE_ENTER_CRITICAL();
    2b1e:	0f b6       	in	r0, 0x3f	; 63
    2b20:	f8 94       	cli
    2b22:	0f 92       	push	r0
    {
        xTicks = xTickCount;
    2b24:	20 91 fc 06 	lds	r18, 0x06FC
    2b28:	30 91 fd 06 	lds	r19, 0x06FD
    }
    portTICK_TYPE_EXIT_CRITICAL();
    2b2c:	0f 90       	pop	r0
    2b2e:	0f be       	out	0x3f, r0	; 63

    return xTicks;
}
    2b30:	c9 01       	movw	r24, r18
    2b32:	08 95       	ret

00002b34 <xTaskGetTickCountFromISR>:
     * link: https://www.FreeRTOS.org/RTOS-Cortex-M3-M4.html */
    portASSERT_IF_INTERRUPT_PRIORITY_INVALID();

    uxSavedInterruptStatus = portTICK_TYPE_SET_INTERRUPT_MASK_FROM_ISR();
    {
        xReturn = xTickCount;
    2b34:	20 91 fc 06 	lds	r18, 0x06FC
    2b38:	30 91 fd 06 	lds	r19, 0x06FD
    }
    portTICK_TYPE_CLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

    return xReturn;
}
    2b3c:	c9 01       	movw	r24, r18
    2b3e:	08 95       	ret

00002b40 <uxTaskGetNumberOfTasks>:

UBaseType_t uxTaskGetNumberOfTasks( void )
{
    /* A critical section is not required because the variables are of type
     * BaseType_t. */
    return uxCurrentNumberOfTasks;
    2b40:	80 91 03 07 	lds	r24, 0x0703
}
    2b44:	08 95       	ret

00002b46 <pcTaskGetName>:
{
    TCB_t * pxTCB;

    /* If null is passed in here then the name of the calling task is being
     * queried. */
    pxTCB = prvGetTCBFromHandle( xTaskToQuery );
    2b46:	00 97       	sbiw	r24, 0x00	; 0
    2b48:	21 f4       	brne	.+8      	; 0x2b52 <pcTaskGetName+0xc>
    2b4a:	80 91 f7 06 	lds	r24, 0x06F7
    2b4e:	90 91 f8 06 	lds	r25, 0x06F8
    2b52:	9c 01       	movw	r18, r24
    2b54:	27 5e       	subi	r18, 0xE7	; 231
    2b56:	3f 4f       	sbci	r19, 0xFF	; 255
    configASSERT( pxTCB );
    return &( pxTCB->pcTaskName[ 0 ] );
}
    2b58:	c9 01       	movw	r24, r18
    2b5a:	08 95       	ret

00002b5c <xTaskIncrementTick>:

#endif /* INCLUDE_xTaskAbortDelay */
/*----------------------------------------------------------*/

BaseType_t xTaskIncrementTick( void )
{
    2b5c:	ef 92       	push	r14
    2b5e:	ff 92       	push	r15
    2b60:	0f 93       	push	r16
    2b62:	1f 93       	push	r17
    2b64:	cf 93       	push	r28
    2b66:	df 93       	push	r29
    /* Called by the portable layer each time a tick interrupt occurs.
     * Increments the tick then checks to see if the new tick value will cause any
     * tasks to be unblocked. */
    traceTASK_INCREMENT_TICK( xTickCount );

    if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
    2b68:	80 91 f9 06 	lds	r24, 0x06F9
    2b6c:	88 23       	and	r24, r24
    2b6e:	09 f0       	breq	.+2      	; 0x2b72 <xTaskIncrementTick+0x16>
    2b70:	fb c0       	rjmp	.+502    	; 0x2d68 <xTaskIncrementTick+0x20c>
    {
        /* Minor optimisation.  The tick count cannot change in this
         * block. */
        const TickType_t xConstTickCount = xTickCount + ( TickType_t ) 1;
    2b72:	00 91 fc 06 	lds	r16, 0x06FC
    2b76:	10 91 fd 06 	lds	r17, 0x06FD
    2b7a:	0f 5f       	subi	r16, 0xFF	; 255
    2b7c:	1f 4f       	sbci	r17, 0xFF	; 255

        /* Increment the RTOS tick, switching the delayed and overflowed
         * delayed lists if it wraps to 0. */
        xTickCount = xConstTickCount;
    2b7e:	10 93 fd 06 	sts	0x06FD, r17
    2b82:	00 93 fc 06 	sts	0x06FC, r16

        if( xConstTickCount == ( TickType_t ) 0U ) /*lint !e774 'if' does not always evaluate to false as it is looking for an overflow. */
    2b86:	01 15       	cp	r16, r1
    2b88:	11 05       	cpc	r17, r1
    2b8a:	61 f5       	brne	.+88     	; 0x2be4 <xTaskIncrementTick+0x88>
        {
            taskSWITCH_DELAYED_LISTS();
    2b8c:	20 91 3f 07 	lds	r18, 0x073F
    2b90:	30 91 40 07 	lds	r19, 0x0740
    2b94:	80 91 41 07 	lds	r24, 0x0741
    2b98:	90 91 42 07 	lds	r25, 0x0742
    2b9c:	90 93 40 07 	sts	0x0740, r25
    2ba0:	80 93 3f 07 	sts	0x073F, r24
    2ba4:	30 93 42 07 	sts	0x0742, r19
    2ba8:	20 93 41 07 	sts	0x0741, r18
    2bac:	80 91 00 07 	lds	r24, 0x0700
    2bb0:	8f 5f       	subi	r24, 0xFF	; 255
    2bb2:	80 93 00 07 	sts	0x0700, r24
#endif /* INCLUDE_vTaskDelete */
/*-----------------------------------------------------------*/

static void prvResetNextTaskUnblockTime( void )
{
    if( listLIST_IS_EMPTY( pxDelayedTaskList ) != pdFALSE )
    2bb6:	e0 91 3f 07 	lds	r30, 0x073F
    2bba:	f0 91 40 07 	lds	r31, 0x0740
    2bbe:	80 81       	ld	r24, Z
    2bc0:	88 23       	and	r24, r24
    2bc2:	19 f4       	brne	.+6      	; 0x2bca <xTaskIncrementTick+0x6e>
    {
        /* The new current delayed list is empty.  Set xNextTaskUnblockTime to
         * the maximum possible value so it is  extremely unlikely that the
         * if( xTickCount >= xNextTaskUnblockTime ) test will pass until
         * there is an item in the delayed list. */
        xNextTaskUnblockTime = portMAX_DELAY;
    2bc4:	8f ef       	ldi	r24, 0xFF	; 255
    2bc6:	9f ef       	ldi	r25, 0xFF	; 255
    2bc8:	09 c0       	rjmp	.+18     	; 0x2bdc <xTaskIncrementTick+0x80>
    {
        /* The new current delayed list is not empty, get the value of
         * the item at the head of the delayed list.  This is the time at
         * which the task at the head of the delayed list should be removed
         * from the Blocked state. */
        xNextTaskUnblockTime = listGET_ITEM_VALUE_OF_HEAD_ENTRY( pxDelayedTaskList );
    2bca:	e0 91 3f 07 	lds	r30, 0x073F
    2bce:	f0 91 40 07 	lds	r31, 0x0740
    2bd2:	05 80       	ldd	r0, Z+5	; 0x05
    2bd4:	f6 81       	ldd	r31, Z+6	; 0x06
    2bd6:	e0 2d       	mov	r30, r0
    2bd8:	80 81       	ld	r24, Z
    2bda:	91 81       	ldd	r25, Z+1	; 0x01
    2bdc:	90 93 ff 06 	sts	0x06FF, r25
    2be0:	80 93 fe 06 	sts	0x06FE, r24

        /* See if this tick has made a timeout expire.  Tasks are stored in
         * the  queue in the order of their wake time - meaning once one task
         * has been found whose block time has not expired there is no need to
         * look any further down the list. */
        if( xConstTickCount >= xNextTaskUnblockTime )
    2be4:	80 91 fe 06 	lds	r24, 0x06FE
    2be8:	90 91 ff 06 	lds	r25, 0x06FF
    2bec:	08 17       	cp	r16, r24
    2bee:	19 07       	cpc	r17, r25
    2bf0:	08 f4       	brcc	.+2      	; 0x2bf4 <xTaskIncrementTick+0x98>
    2bf2:	a2 c0       	rjmp	.+324    	; 0x2d38 <xTaskIncrementTick+0x1dc>
    2bf4:	ff 24       	eor	r15, r15
                        mtCOVERAGE_TEST_MARKER();
                    }

                    /* Place the unblocked task into the appropriate ready
                     * list. */
                    prvAddTaskToReadyList( pxTCB );
    2bf6:	39 e0       	ldi	r19, 0x09	; 9
    2bf8:	e3 2e       	mov	r14, r19
         * look any further down the list. */
        if( xConstTickCount >= xNextTaskUnblockTime )
        {
            for( ; ; )
            {
                if( listLIST_IS_EMPTY( pxDelayedTaskList ) != pdFALSE )
    2bfa:	e0 91 3f 07 	lds	r30, 0x073F
    2bfe:	f0 91 40 07 	lds	r31, 0x0740
    2c02:	80 81       	ld	r24, Z
    2c04:	88 23       	and	r24, r24
    2c06:	19 f4       	brne	.+6      	; 0x2c0e <xTaskIncrementTick+0xb2>
                    /* The delayed list is empty.  Set xNextTaskUnblockTime
                     * to the maximum possible value so it is extremely
                     * unlikely that the
                     * if( xTickCount >= xNextTaskUnblockTime ) test will pass
                     * next time through. */
                    xNextTaskUnblockTime = portMAX_DELAY; /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
    2c08:	8f ef       	ldi	r24, 0xFF	; 255
    2c0a:	9f ef       	ldi	r25, 0xFF	; 255
    2c0c:	0e c0       	rjmp	.+28     	; 0x2c2a <xTaskIncrementTick+0xce>
                {
                    /* The delayed list is not empty, get the value of the
                     * item at the head of the delayed list.  This is the time
                     * at which the task at the head of the delayed list must
                     * be removed from the Blocked state. */
                    pxTCB = listGET_OWNER_OF_HEAD_ENTRY( pxDelayedTaskList ); /*lint !e9079 void * is used as this macro is used with timers and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
    2c0e:	e0 91 3f 07 	lds	r30, 0x073F
    2c12:	f0 91 40 07 	lds	r31, 0x0740
    2c16:	05 80       	ldd	r0, Z+5	; 0x05
    2c18:	f6 81       	ldd	r31, Z+6	; 0x06
    2c1a:	e0 2d       	mov	r30, r0
    2c1c:	c6 81       	ldd	r28, Z+6	; 0x06
    2c1e:	d7 81       	ldd	r29, Z+7	; 0x07
                    xItemValue = listGET_LIST_ITEM_VALUE( &( pxTCB->xStateListItem ) );
    2c20:	8a 81       	ldd	r24, Y+2	; 0x02
    2c22:	9b 81       	ldd	r25, Y+3	; 0x03

                    if( xConstTickCount < xItemValue )
    2c24:	08 17       	cp	r16, r24
    2c26:	19 07       	cpc	r17, r25
    2c28:	28 f4       	brcc	.+10     	; 0x2c34 <xTaskIncrementTick+0xd8>
                        /* It is not time to unblock this item yet, but the
                         * item value is the time at which the task at the head
                         * of the blocked list must be removed from the Blocked
                         * state -  so record the item value in
                         * xNextTaskUnblockTime. */
                        xNextTaskUnblockTime = xItemValue;
    2c2a:	90 93 ff 06 	sts	0x06FF, r25
    2c2e:	80 93 fe 06 	sts	0x06FE, r24
    2c32:	83 c0       	rjmp	.+262    	; 0x2d3a <xTaskIncrementTick+0x1de>
                    {
                        mtCOVERAGE_TEST_MARKER();
                    }

                    /* It is time to remove the item from the Blocked state. */
                    listREMOVE_ITEM( &( pxTCB->xStateListItem ) );
    2c34:	aa 85       	ldd	r26, Y+10	; 0x0a
    2c36:	bb 85       	ldd	r27, Y+11	; 0x0b
    2c38:	4c 81       	ldd	r20, Y+4	; 0x04
    2c3a:	5d 81       	ldd	r21, Y+5	; 0x05
    2c3c:	8e 81       	ldd	r24, Y+6	; 0x06
    2c3e:	9f 81       	ldd	r25, Y+7	; 0x07
    2c40:	fa 01       	movw	r30, r20
    2c42:	95 83       	std	Z+5, r25	; 0x05
    2c44:	84 83       	std	Z+4, r24	; 0x04
    2c46:	2e 81       	ldd	r18, Y+6	; 0x06
    2c48:	3f 81       	ldd	r19, Y+7	; 0x07
    2c4a:	f9 01       	movw	r30, r18
    2c4c:	53 83       	std	Z+3, r21	; 0x03
    2c4e:	42 83       	std	Z+2, r20	; 0x02
    2c50:	be 01       	movw	r22, r28
    2c52:	6e 5f       	subi	r22, 0xFE	; 254
    2c54:	7f 4f       	sbci	r23, 0xFF	; 255
    2c56:	11 96       	adiw	r26, 0x01	; 1
    2c58:	8d 91       	ld	r24, X+
    2c5a:	9c 91       	ld	r25, X
    2c5c:	12 97       	sbiw	r26, 0x02	; 2
    2c5e:	86 17       	cp	r24, r22
    2c60:	97 07       	cpc	r25, r23
    2c62:	21 f4       	brne	.+8      	; 0x2c6c <xTaskIncrementTick+0x110>
    2c64:	12 96       	adiw	r26, 0x02	; 2
    2c66:	3c 93       	st	X, r19
    2c68:	2e 93       	st	-X, r18
    2c6a:	11 97       	sbiw	r26, 0x01	; 1
    2c6c:	1b 86       	std	Y+11, r1	; 0x0b
    2c6e:	1a 86       	std	Y+10, r1	; 0x0a
    2c70:	8c 91       	ld	r24, X
    2c72:	81 50       	subi	r24, 0x01	; 1
    2c74:	8c 93       	st	X, r24

                    /* Is the task waiting on an event also?  If so remove
                     * it from the event list. */
                    if( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) != NULL )
    2c76:	ac 89       	ldd	r26, Y+20	; 0x14
    2c78:	bd 89       	ldd	r27, Y+21	; 0x15
    2c7a:	10 97       	sbiw	r26, 0x00	; 0
    2c7c:	f9 f0       	breq	.+62     	; 0x2cbc <xTaskIncrementTick+0x160>
                    {
                        listREMOVE_ITEM( &( pxTCB->xEventListItem ) );
    2c7e:	2e 85       	ldd	r18, Y+14	; 0x0e
    2c80:	3f 85       	ldd	r19, Y+15	; 0x0f
    2c82:	88 89       	ldd	r24, Y+16	; 0x10
    2c84:	99 89       	ldd	r25, Y+17	; 0x11
    2c86:	f9 01       	movw	r30, r18
    2c88:	95 83       	std	Z+5, r25	; 0x05
    2c8a:	84 83       	std	Z+4, r24	; 0x04
    2c8c:	48 89       	ldd	r20, Y+16	; 0x10
    2c8e:	59 89       	ldd	r21, Y+17	; 0x11
    2c90:	fa 01       	movw	r30, r20
    2c92:	33 83       	std	Z+3, r19	; 0x03
    2c94:	22 83       	std	Z+2, r18	; 0x02
    2c96:	9e 01       	movw	r18, r28
    2c98:	24 5f       	subi	r18, 0xF4	; 244
    2c9a:	3f 4f       	sbci	r19, 0xFF	; 255
    2c9c:	11 96       	adiw	r26, 0x01	; 1
    2c9e:	8d 91       	ld	r24, X+
    2ca0:	9c 91       	ld	r25, X
    2ca2:	12 97       	sbiw	r26, 0x02	; 2
    2ca4:	82 17       	cp	r24, r18
    2ca6:	93 07       	cpc	r25, r19
    2ca8:	21 f4       	brne	.+8      	; 0x2cb2 <xTaskIncrementTick+0x156>
    2caa:	12 96       	adiw	r26, 0x02	; 2
    2cac:	5c 93       	st	X, r21
    2cae:	4e 93       	st	-X, r20
    2cb0:	11 97       	sbiw	r26, 0x01	; 1
    2cb2:	1d 8a       	std	Y+21, r1	; 0x15
    2cb4:	1c 8a       	std	Y+20, r1	; 0x14
    2cb6:	8c 91       	ld	r24, X
    2cb8:	81 50       	subi	r24, 0x01	; 1
    2cba:	8c 93       	st	X, r24
                        mtCOVERAGE_TEST_MARKER();
                    }

                    /* Place the unblocked task into the appropriate ready
                     * list. */
                    prvAddTaskToReadyList( pxTCB );
    2cbc:	9e 89       	ldd	r25, Y+22	; 0x16
    2cbe:	80 91 fa 06 	lds	r24, 0x06FA
    2cc2:	89 17       	cp	r24, r25
    2cc4:	10 f4       	brcc	.+4      	; 0x2cca <xTaskIncrementTick+0x16e>
    2cc6:	90 93 fa 06 	sts	0x06FA, r25
    2cca:	89 2f       	mov	r24, r25
    2ccc:	90 e0       	ldi	r25, 0x00	; 0
    2cce:	fc 01       	movw	r30, r24
    2cd0:	23 e0       	ldi	r18, 0x03	; 3
    2cd2:	ee 0f       	add	r30, r30
    2cd4:	ff 1f       	adc	r31, r31
    2cd6:	2a 95       	dec	r18
    2cd8:	e1 f7       	brne	.-8      	; 0x2cd2 <xTaskIncrementTick+0x176>
    2cda:	e8 0f       	add	r30, r24
    2cdc:	f9 1f       	adc	r31, r25
    2cde:	e7 5f       	subi	r30, 0xF7	; 247
    2ce0:	f8 4f       	sbci	r31, 0xF8	; 248
    2ce2:	a1 81       	ldd	r26, Z+1	; 0x01
    2ce4:	b2 81       	ldd	r27, Z+2	; 0x02
    2ce6:	bd 83       	std	Y+5, r27	; 0x05
    2ce8:	ac 83       	std	Y+4, r26	; 0x04
    2cea:	14 96       	adiw	r26, 0x04	; 4
    2cec:	8d 91       	ld	r24, X+
    2cee:	9c 91       	ld	r25, X
    2cf0:	15 97       	sbiw	r26, 0x05	; 5
    2cf2:	9f 83       	std	Y+7, r25	; 0x07
    2cf4:	8e 83       	std	Y+6, r24	; 0x06
    2cf6:	14 96       	adiw	r26, 0x04	; 4
    2cf8:	ed 91       	ld	r30, X+
    2cfa:	fc 91       	ld	r31, X
    2cfc:	15 97       	sbiw	r26, 0x05	; 5
    2cfe:	73 83       	std	Z+3, r23	; 0x03
    2d00:	62 83       	std	Z+2, r22	; 0x02
    2d02:	15 96       	adiw	r26, 0x05	; 5
    2d04:	7c 93       	st	X, r23
    2d06:	6e 93       	st	-X, r22
    2d08:	14 97       	sbiw	r26, 0x04	; 4
    2d0a:	ee 89       	ldd	r30, Y+22	; 0x16
    2d0c:	ee 9d       	mul	r30, r14
    2d0e:	f0 01       	movw	r30, r0
    2d10:	11 24       	eor	r1, r1
    2d12:	e7 5f       	subi	r30, 0xF7	; 247
    2d14:	f8 4f       	sbci	r31, 0xF8	; 248
    2d16:	fb 87       	std	Y+11, r31	; 0x0b
    2d18:	ea 87       	std	Y+10, r30	; 0x0a
    2d1a:	80 81       	ld	r24, Z
    2d1c:	8f 5f       	subi	r24, 0xFF	; 255
    2d1e:	80 83       	st	Z, r24
                         * task.
                         * The case of equal priority tasks sharing
                         * processing time (which happens when both
                         * preemption and time slicing are on) is
                         * handled below.*/
                        if( pxTCB->uxPriority > pxCurrentTCB->uxPriority )
    2d20:	e0 91 f7 06 	lds	r30, 0x06F7
    2d24:	f0 91 f8 06 	lds	r31, 0x06F8
    2d28:	9e 89       	ldd	r25, Y+22	; 0x16
    2d2a:	86 89       	ldd	r24, Z+22	; 0x16
    2d2c:	89 17       	cp	r24, r25
    2d2e:	08 f0       	brcs	.+2      	; 0x2d32 <xTaskIncrementTick+0x1d6>
    2d30:	64 cf       	rjmp	.-312    	; 0x2bfa <xTaskIncrementTick+0x9e>
    2d32:	ff 24       	eor	r15, r15
    2d34:	f3 94       	inc	r15
    2d36:	61 cf       	rjmp	.-318    	; 0x2bfa <xTaskIncrementTick+0x9e>
    2d38:	ff 24       	eor	r15, r15
        /* Tasks of equal priority to the currently running task will share
         * processing time (time slice) if preemption is on, and the application
         * writer has not explicitly turned time slicing off. */
        #if ( ( configUSE_PREEMPTION == 1 ) && ( configUSE_TIME_SLICING == 1 ) )
        {
            if( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ pxCurrentTCB->uxPriority ] ) ) > ( UBaseType_t ) 1 )
    2d3a:	e0 91 f7 06 	lds	r30, 0x06F7
    2d3e:	f0 91 f8 06 	lds	r31, 0x06F8
    2d42:	e6 89       	ldd	r30, Z+22	; 0x16
    2d44:	89 e0       	ldi	r24, 0x09	; 9
    2d46:	e8 9f       	mul	r30, r24
    2d48:	f0 01       	movw	r30, r0
    2d4a:	11 24       	eor	r1, r1
    2d4c:	e7 5f       	subi	r30, 0xF7	; 247
    2d4e:	f8 4f       	sbci	r31, 0xF8	; 248
    2d50:	80 81       	ld	r24, Z
    2d52:	82 30       	cpi	r24, 0x02	; 2
    2d54:	10 f0       	brcs	.+4      	; 0x2d5a <xTaskIncrementTick+0x1fe>
    2d56:	ff 24       	eor	r15, r15
    2d58:	f3 94       	inc	r15
        }
        #endif /* configUSE_TICK_HOOK */

        #if ( configUSE_PREEMPTION == 1 )
        {
            if( xYieldPending != pdFALSE )
    2d5a:	80 91 fb 06 	lds	r24, 0x06FB
    2d5e:	88 23       	and	r24, r24
    2d60:	69 f0       	breq	.+26     	; 0x2d7c <xTaskIncrementTick+0x220>
    2d62:	ff 24       	eor	r15, r15
    2d64:	f3 94       	inc	r15
    2d66:	0a c0       	rjmp	.+20     	; 0x2d7c <xTaskIncrementTick+0x220>
        }
        #endif /* configUSE_PREEMPTION */
    }
    else
    {
        ++xPendedTicks;
    2d68:	80 91 01 07 	lds	r24, 0x0701
    2d6c:	90 91 02 07 	lds	r25, 0x0702
    2d70:	01 96       	adiw	r24, 0x01	; 1
    2d72:	90 93 02 07 	sts	0x0702, r25
    2d76:	80 93 01 07 	sts	0x0701, r24
    2d7a:	ff 24       	eor	r15, r15
        }
        #endif
    }

    return xSwitchRequired;
}
    2d7c:	8f 2d       	mov	r24, r15
    2d7e:	df 91       	pop	r29
    2d80:	cf 91       	pop	r28
    2d82:	1f 91       	pop	r17
    2d84:	0f 91       	pop	r16
    2d86:	ff 90       	pop	r15
    2d88:	ef 90       	pop	r14
    2d8a:	08 95       	ret

00002d8c <vTaskSwitchContext>:
#endif /* configUSE_APPLICATION_TASK_TAG */
/*-----------------------------------------------------------*/

void vTaskSwitchContext( void )
{
    if( uxSchedulerSuspended != ( UBaseType_t ) pdFALSE )
    2d8c:	80 91 f9 06 	lds	r24, 0x06F9
    2d90:	88 23       	and	r24, r24
    2d92:	21 f0       	breq	.+8      	; 0x2d9c <vTaskSwitchContext+0x10>
    {
        /* The scheduler is currently suspended - do not allow a context
         * switch. */
        xYieldPending = pdTRUE;
    2d94:	81 e0       	ldi	r24, 0x01	; 1
    2d96:	80 93 fb 06 	sts	0x06FB, r24
    2d9a:	08 95       	ret
    }
    else
    {
        xYieldPending = pdFALSE;
    2d9c:	10 92 fb 06 	sts	0x06FB, r1
        }
        #endif

        /* Select a new task to run using either the generic C or port
         * optimised asm code. */
        taskSELECT_HIGHEST_PRIORITY_TASK(); /*lint !e9079 void * is used as this macro is used with timers and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
    2da0:	20 91 fa 06 	lds	r18, 0x06FA
    2da4:	99 e0       	ldi	r25, 0x09	; 9
    2da6:	01 c0       	rjmp	.+2      	; 0x2daa <vTaskSwitchContext+0x1e>
    2da8:	21 50       	subi	r18, 0x01	; 1
    2daa:	29 9f       	mul	r18, r25
    2dac:	d0 01       	movw	r26, r0
    2dae:	11 24       	eor	r1, r1
    2db0:	a7 5f       	subi	r26, 0xF7	; 247
    2db2:	b8 4f       	sbci	r27, 0xF8	; 248
    2db4:	8c 91       	ld	r24, X
    2db6:	88 23       	and	r24, r24
    2db8:	b9 f3       	breq	.-18     	; 0x2da8 <vTaskSwitchContext+0x1c>
    2dba:	11 96       	adiw	r26, 0x01	; 1
    2dbc:	ed 91       	ld	r30, X+
    2dbe:	fc 91       	ld	r31, X
    2dc0:	12 97       	sbiw	r26, 0x02	; 2
    2dc2:	02 80       	ldd	r0, Z+2	; 0x02
    2dc4:	f3 81       	ldd	r31, Z+3	; 0x03
    2dc6:	e0 2d       	mov	r30, r0
    2dc8:	12 96       	adiw	r26, 0x02	; 2
    2dca:	fc 93       	st	X, r31
    2dcc:	ee 93       	st	-X, r30
    2dce:	11 97       	sbiw	r26, 0x01	; 1
    2dd0:	cd 01       	movw	r24, r26
    2dd2:	03 96       	adiw	r24, 0x03	; 3
    2dd4:	e8 17       	cp	r30, r24
    2dd6:	f9 07       	cpc	r31, r25
    2dd8:	31 f4       	brne	.+12     	; 0x2de6 <vTaskSwitchContext+0x5a>
    2dda:	82 81       	ldd	r24, Z+2	; 0x02
    2ddc:	93 81       	ldd	r25, Z+3	; 0x03
    2dde:	12 96       	adiw	r26, 0x02	; 2
    2de0:	9c 93       	st	X, r25
    2de2:	8e 93       	st	-X, r24
    2de4:	11 97       	sbiw	r26, 0x01	; 1
    2de6:	11 96       	adiw	r26, 0x01	; 1
    2de8:	ed 91       	ld	r30, X+
    2dea:	fc 91       	ld	r31, X
    2dec:	12 97       	sbiw	r26, 0x02	; 2
    2dee:	86 81       	ldd	r24, Z+6	; 0x06
    2df0:	97 81       	ldd	r25, Z+7	; 0x07
    2df2:	90 93 f8 06 	sts	0x06F8, r25
    2df6:	80 93 f7 06 	sts	0x06F7, r24
    2dfa:	20 93 fa 06 	sts	0x06FA, r18
    2dfe:	08 95       	ret

00002e00 <xTaskRemoveFromEventList>:

#endif /* configUSE_TIMERS */
/*-----------------------------------------------------------*/

BaseType_t xTaskRemoveFromEventList( const List_t * const pxEventList )
{
    2e00:	cf 93       	push	r28
    2e02:	df 93       	push	r29
     * get called - the lock count on the queue will get modified instead.  This
     * means exclusive access to the event list is guaranteed here.
     *
     * This function assumes that a check has already been made to ensure that
     * pxEventList is not empty. */
    pxUnblockedTCB = listGET_OWNER_OF_HEAD_ENTRY( pxEventList ); /*lint !e9079 void * is used as this macro is used with timers and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
    2e04:	dc 01       	movw	r26, r24
    2e06:	15 96       	adiw	r26, 0x05	; 5
    2e08:	ed 91       	ld	r30, X+
    2e0a:	fc 91       	ld	r31, X
    2e0c:	16 97       	sbiw	r26, 0x06	; 6
    2e0e:	c6 81       	ldd	r28, Z+6	; 0x06
    2e10:	d7 81       	ldd	r29, Z+7	; 0x07
    configASSERT( pxUnblockedTCB );
    listREMOVE_ITEM( &( pxUnblockedTCB->xEventListItem ) );
    2e12:	ac 89       	ldd	r26, Y+20	; 0x14
    2e14:	bd 89       	ldd	r27, Y+21	; 0x15
    2e16:	4e 85       	ldd	r20, Y+14	; 0x0e
    2e18:	5f 85       	ldd	r21, Y+15	; 0x0f
    2e1a:	88 89       	ldd	r24, Y+16	; 0x10
    2e1c:	99 89       	ldd	r25, Y+17	; 0x11
    2e1e:	fa 01       	movw	r30, r20
    2e20:	95 83       	std	Z+5, r25	; 0x05
    2e22:	84 83       	std	Z+4, r24	; 0x04
    2e24:	28 89       	ldd	r18, Y+16	; 0x10
    2e26:	39 89       	ldd	r19, Y+17	; 0x11
    2e28:	f9 01       	movw	r30, r18
    2e2a:	53 83       	std	Z+3, r21	; 0x03
    2e2c:	42 83       	std	Z+2, r20	; 0x02
    2e2e:	ae 01       	movw	r20, r28
    2e30:	44 5f       	subi	r20, 0xF4	; 244
    2e32:	5f 4f       	sbci	r21, 0xFF	; 255
    2e34:	11 96       	adiw	r26, 0x01	; 1
    2e36:	8d 91       	ld	r24, X+
    2e38:	9c 91       	ld	r25, X
    2e3a:	12 97       	sbiw	r26, 0x02	; 2
    2e3c:	84 17       	cp	r24, r20
    2e3e:	95 07       	cpc	r25, r21
    2e40:	21 f4       	brne	.+8      	; 0x2e4a <xTaskRemoveFromEventList+0x4a>
    2e42:	12 96       	adiw	r26, 0x02	; 2
    2e44:	3c 93       	st	X, r19
    2e46:	2e 93       	st	-X, r18
    2e48:	11 97       	sbiw	r26, 0x01	; 1
    2e4a:	1d 8a       	std	Y+21, r1	; 0x15
    2e4c:	1c 8a       	std	Y+20, r1	; 0x14
    2e4e:	8c 91       	ld	r24, X
    2e50:	81 50       	subi	r24, 0x01	; 1
    2e52:	8c 93       	st	X, r24

    if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
    2e54:	80 91 f9 06 	lds	r24, 0x06F9
    2e58:	88 23       	and	r24, r24
    2e5a:	09 f0       	breq	.+2      	; 0x2e5e <xTaskRemoveFromEventList+0x5e>
    2e5c:	55 c0       	rjmp	.+170    	; 0x2f08 <xTaskRemoveFromEventList+0x108>
    {
        listREMOVE_ITEM( &( pxUnblockedTCB->xStateListItem ) );
    2e5e:	aa 85       	ldd	r26, Y+10	; 0x0a
    2e60:	bb 85       	ldd	r27, Y+11	; 0x0b
    2e62:	4c 81       	ldd	r20, Y+4	; 0x04
    2e64:	5d 81       	ldd	r21, Y+5	; 0x05
    2e66:	8e 81       	ldd	r24, Y+6	; 0x06
    2e68:	9f 81       	ldd	r25, Y+7	; 0x07
    2e6a:	fa 01       	movw	r30, r20
    2e6c:	95 83       	std	Z+5, r25	; 0x05
    2e6e:	84 83       	std	Z+4, r24	; 0x04
    2e70:	2e 81       	ldd	r18, Y+6	; 0x06
    2e72:	3f 81       	ldd	r19, Y+7	; 0x07
    2e74:	f9 01       	movw	r30, r18
    2e76:	53 83       	std	Z+3, r21	; 0x03
    2e78:	42 83       	std	Z+2, r20	; 0x02
    2e7a:	ae 01       	movw	r20, r28
    2e7c:	4e 5f       	subi	r20, 0xFE	; 254
    2e7e:	5f 4f       	sbci	r21, 0xFF	; 255
    2e80:	11 96       	adiw	r26, 0x01	; 1
    2e82:	8d 91       	ld	r24, X+
    2e84:	9c 91       	ld	r25, X
    2e86:	12 97       	sbiw	r26, 0x02	; 2
    2e88:	84 17       	cp	r24, r20
    2e8a:	95 07       	cpc	r25, r21
    2e8c:	21 f4       	brne	.+8      	; 0x2e96 <xTaskRemoveFromEventList+0x96>
    2e8e:	12 96       	adiw	r26, 0x02	; 2
    2e90:	3c 93       	st	X, r19
    2e92:	2e 93       	st	-X, r18
    2e94:	11 97       	sbiw	r26, 0x01	; 1
    2e96:	1b 86       	std	Y+11, r1	; 0x0b
    2e98:	1a 86       	std	Y+10, r1	; 0x0a
    2e9a:	8c 91       	ld	r24, X
    2e9c:	81 50       	subi	r24, 0x01	; 1
    2e9e:	8c 93       	st	X, r24
        prvAddTaskToReadyList( pxUnblockedTCB );
    2ea0:	9e 89       	ldd	r25, Y+22	; 0x16
    2ea2:	80 91 fa 06 	lds	r24, 0x06FA
    2ea6:	89 17       	cp	r24, r25
    2ea8:	10 f4       	brcc	.+4      	; 0x2eae <xTaskRemoveFromEventList+0xae>
    2eaa:	90 93 fa 06 	sts	0x06FA, r25
    2eae:	89 2f       	mov	r24, r25
    2eb0:	90 e0       	ldi	r25, 0x00	; 0
    2eb2:	fc 01       	movw	r30, r24
    2eb4:	63 e0       	ldi	r22, 0x03	; 3
    2eb6:	ee 0f       	add	r30, r30
    2eb8:	ff 1f       	adc	r31, r31
    2eba:	6a 95       	dec	r22
    2ebc:	e1 f7       	brne	.-8      	; 0x2eb6 <xTaskRemoveFromEventList+0xb6>
    2ebe:	e8 0f       	add	r30, r24
    2ec0:	f9 1f       	adc	r31, r25
    2ec2:	e7 5f       	subi	r30, 0xF7	; 247
    2ec4:	f8 4f       	sbci	r31, 0xF8	; 248
    2ec6:	a1 81       	ldd	r26, Z+1	; 0x01
    2ec8:	b2 81       	ldd	r27, Z+2	; 0x02
    2eca:	bd 83       	std	Y+5, r27	; 0x05
    2ecc:	ac 83       	std	Y+4, r26	; 0x04
    2ece:	14 96       	adiw	r26, 0x04	; 4
    2ed0:	8d 91       	ld	r24, X+
    2ed2:	9c 91       	ld	r25, X
    2ed4:	15 97       	sbiw	r26, 0x05	; 5
    2ed6:	9f 83       	std	Y+7, r25	; 0x07
    2ed8:	8e 83       	std	Y+6, r24	; 0x06
    2eda:	14 96       	adiw	r26, 0x04	; 4
    2edc:	ed 91       	ld	r30, X+
    2ede:	fc 91       	ld	r31, X
    2ee0:	15 97       	sbiw	r26, 0x05	; 5
    2ee2:	53 83       	std	Z+3, r21	; 0x03
    2ee4:	42 83       	std	Z+2, r20	; 0x02
    2ee6:	15 96       	adiw	r26, 0x05	; 5
    2ee8:	5c 93       	st	X, r21
    2eea:	4e 93       	st	-X, r20
    2eec:	14 97       	sbiw	r26, 0x04	; 4
    2eee:	ee 89       	ldd	r30, Y+22	; 0x16
    2ef0:	89 e0       	ldi	r24, 0x09	; 9
    2ef2:	e8 9f       	mul	r30, r24
    2ef4:	f0 01       	movw	r30, r0
    2ef6:	11 24       	eor	r1, r1
    2ef8:	e7 5f       	subi	r30, 0xF7	; 247
    2efa:	f8 4f       	sbci	r31, 0xF8	; 248
    2efc:	fb 87       	std	Y+11, r31	; 0x0b
    2efe:	ea 87       	std	Y+10, r30	; 0x0a
    2f00:	80 81       	ld	r24, Z
    2f02:	8f 5f       	subi	r24, 0xFF	; 255
    2f04:	80 83       	st	Z, r24
    2f06:	1f c0       	rjmp	.+62     	; 0x2f46 <xTaskRemoveFromEventList+0x146>
    }
    else
    {
        /* The delayed and ready lists cannot be accessed, so hold this task
         * pending until the scheduler is resumed. */
        listINSERT_END( &( xPendingReadyList ), &( pxUnblockedTCB->xEventListItem ) );
    2f08:	a0 91 44 07 	lds	r26, 0x0744
    2f0c:	b0 91 45 07 	lds	r27, 0x0745
    2f10:	bf 87       	std	Y+15, r27	; 0x0f
    2f12:	ae 87       	std	Y+14, r26	; 0x0e
    2f14:	14 96       	adiw	r26, 0x04	; 4
    2f16:	8d 91       	ld	r24, X+
    2f18:	9c 91       	ld	r25, X
    2f1a:	15 97       	sbiw	r26, 0x05	; 5
    2f1c:	99 8b       	std	Y+17, r25	; 0x11
    2f1e:	88 8b       	std	Y+16, r24	; 0x10
    2f20:	14 96       	adiw	r26, 0x04	; 4
    2f22:	ed 91       	ld	r30, X+
    2f24:	fc 91       	ld	r31, X
    2f26:	15 97       	sbiw	r26, 0x05	; 5
    2f28:	53 83       	std	Z+3, r21	; 0x03
    2f2a:	42 83       	std	Z+2, r20	; 0x02
    2f2c:	15 96       	adiw	r26, 0x05	; 5
    2f2e:	5c 93       	st	X, r21
    2f30:	4e 93       	st	-X, r20
    2f32:	14 97       	sbiw	r26, 0x04	; 4
    2f34:	83 e4       	ldi	r24, 0x43	; 67
    2f36:	97 e0       	ldi	r25, 0x07	; 7
    2f38:	9d 8b       	std	Y+21, r25	; 0x15
    2f3a:	8c 8b       	std	Y+20, r24	; 0x14
    2f3c:	80 91 43 07 	lds	r24, 0x0743
    2f40:	8f 5f       	subi	r24, 0xFF	; 255
    2f42:	80 93 43 07 	sts	0x0743, r24
    }

    if( pxUnblockedTCB->uxPriority > pxCurrentTCB->uxPriority )
    2f46:	e0 91 f7 06 	lds	r30, 0x06F7
    2f4a:	f0 91 f8 06 	lds	r31, 0x06F8
    2f4e:	9e 89       	ldd	r25, Y+22	; 0x16
    2f50:	86 89       	ldd	r24, Z+22	; 0x16
    2f52:	89 17       	cp	r24, r25
    2f54:	10 f0       	brcs	.+4      	; 0x2f5a <xTaskRemoveFromEventList+0x15a>
    2f56:	80 e0       	ldi	r24, 0x00	; 0
    2f58:	03 c0       	rjmp	.+6      	; 0x2f60 <xTaskRemoveFromEventList+0x160>
         * it should force a context switch now. */
        xReturn = pdTRUE;

        /* Mark that a yield is pending in case the user is not using the
         * "xHigherPriorityTaskWoken" parameter to an ISR safe FreeRTOS function. */
        xYieldPending = pdTRUE;
    2f5a:	81 e0       	ldi	r24, 0x01	; 1
    2f5c:	80 93 fb 06 	sts	0x06FB, r24
    {
        xReturn = pdFALSE;
    }

    return xReturn;
}
    2f60:	df 91       	pop	r29
    2f62:	cf 91       	pop	r28
    2f64:	08 95       	ret

00002f66 <vTaskRemoveFromUnorderedEventList>:
/*-----------------------------------------------------------*/

void vTaskRemoveFromUnorderedEventList( ListItem_t * pxEventListItem,
                                        const TickType_t xItemValue )
{
    2f66:	cf 93       	push	r28
    2f68:	df 93       	push	r29
    2f6a:	dc 01       	movw	r26, r24
    /* THIS FUNCTION MUST BE CALLED WITH THE SCHEDULER SUSPENDED.  It is used by
     * the event flags implementation. */
    configASSERT( uxSchedulerSuspended != pdFALSE );

    /* Store the new item value in the event list. */
    listSET_LIST_ITEM_VALUE( pxEventListItem, xItemValue | taskEVENT_LIST_ITEM_VALUE_IN_USE );
    2f6c:	70 68       	ori	r23, 0x80	; 128
    2f6e:	11 96       	adiw	r26, 0x01	; 1
    2f70:	7c 93       	st	X, r23
    2f72:	6e 93       	st	-X, r22

    /* Remove the event list form the event flag.  Interrupts do not access
     * event flags. */
    pxUnblockedTCB = listGET_LIST_ITEM_OWNER( pxEventListItem ); /*lint !e9079 void * is used as this macro is used with timers and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
    2f74:	16 96       	adiw	r26, 0x06	; 6
    2f76:	2d 91       	ld	r18, X+
    2f78:	3c 91       	ld	r19, X
    2f7a:	17 97       	sbiw	r26, 0x07	; 7
    configASSERT( pxUnblockedTCB );
    listREMOVE_ITEM( pxEventListItem );
    2f7c:	18 96       	adiw	r26, 0x08	; 8
    2f7e:	cd 91       	ld	r28, X+
    2f80:	dc 91       	ld	r29, X
    2f82:	19 97       	sbiw	r26, 0x09	; 9
    2f84:	12 96       	adiw	r26, 0x02	; 2
    2f86:	6d 91       	ld	r22, X+
    2f88:	7c 91       	ld	r23, X
    2f8a:	13 97       	sbiw	r26, 0x03	; 3
    2f8c:	14 96       	adiw	r26, 0x04	; 4
    2f8e:	8d 91       	ld	r24, X+
    2f90:	9c 91       	ld	r25, X
    2f92:	15 97       	sbiw	r26, 0x05	; 5
    2f94:	fb 01       	movw	r30, r22
    2f96:	95 83       	std	Z+5, r25	; 0x05
    2f98:	84 83       	std	Z+4, r24	; 0x04
    2f9a:	14 96       	adiw	r26, 0x04	; 4
    2f9c:	4d 91       	ld	r20, X+
    2f9e:	5c 91       	ld	r21, X
    2fa0:	15 97       	sbiw	r26, 0x05	; 5
    2fa2:	fa 01       	movw	r30, r20
    2fa4:	73 83       	std	Z+3, r23	; 0x03
    2fa6:	62 83       	std	Z+2, r22	; 0x02
    2fa8:	89 81       	ldd	r24, Y+1	; 0x01
    2faa:	9a 81       	ldd	r25, Y+2	; 0x02
    2fac:	8a 17       	cp	r24, r26
    2fae:	9b 07       	cpc	r25, r27
    2fb0:	11 f4       	brne	.+4      	; 0x2fb6 <vTaskRemoveFromUnorderedEventList+0x50>
    2fb2:	5a 83       	std	Y+2, r21	; 0x02
    2fb4:	49 83       	std	Y+1, r20	; 0x01
    2fb6:	19 96       	adiw	r26, 0x09	; 9
    2fb8:	1c 92       	st	X, r1
    2fba:	1e 92       	st	-X, r1
    2fbc:	18 97       	sbiw	r26, 0x08	; 8
    2fbe:	88 81       	ld	r24, Y
    2fc0:	81 50       	subi	r24, 0x01	; 1
    2fc2:	88 83       	st	Y, r24
    #endif

    /* Remove the task from the delayed list and add it to the ready list.  The
     * scheduler is suspended so interrupts will not be accessing the ready
     * lists. */
    listREMOVE_ITEM( &( pxUnblockedTCB->xStateListItem ) );
    2fc4:	e9 01       	movw	r28, r18
    2fc6:	aa 85       	ldd	r26, Y+10	; 0x0a
    2fc8:	bb 85       	ldd	r27, Y+11	; 0x0b
    2fca:	4c 81       	ldd	r20, Y+4	; 0x04
    2fcc:	5d 81       	ldd	r21, Y+5	; 0x05
    2fce:	8e 81       	ldd	r24, Y+6	; 0x06
    2fd0:	9f 81       	ldd	r25, Y+7	; 0x07
    2fd2:	fa 01       	movw	r30, r20
    2fd4:	95 83       	std	Z+5, r25	; 0x05
    2fd6:	84 83       	std	Z+4, r24	; 0x04
    2fd8:	0e 80       	ldd	r0, Y+6	; 0x06
    2fda:	df 81       	ldd	r29, Y+7	; 0x07
    2fdc:	c0 2d       	mov	r28, r0
    2fde:	5b 83       	std	Y+3, r21	; 0x03
    2fe0:	4a 83       	std	Y+2, r20	; 0x02
    2fe2:	a9 01       	movw	r20, r18
    2fe4:	4e 5f       	subi	r20, 0xFE	; 254
    2fe6:	5f 4f       	sbci	r21, 0xFF	; 255
    2fe8:	11 96       	adiw	r26, 0x01	; 1
    2fea:	8d 91       	ld	r24, X+
    2fec:	9c 91       	ld	r25, X
    2fee:	12 97       	sbiw	r26, 0x02	; 2
    2ff0:	84 17       	cp	r24, r20
    2ff2:	95 07       	cpc	r25, r21
    2ff4:	21 f4       	brne	.+8      	; 0x2ffe <vTaskRemoveFromUnorderedEventList+0x98>
    2ff6:	12 96       	adiw	r26, 0x02	; 2
    2ff8:	dc 93       	st	X, r29
    2ffa:	ce 93       	st	-X, r28
    2ffc:	11 97       	sbiw	r26, 0x01	; 1
    2ffe:	e9 01       	movw	r28, r18
    3000:	1b 86       	std	Y+11, r1	; 0x0b
    3002:	1a 86       	std	Y+10, r1	; 0x0a
    3004:	8c 91       	ld	r24, X
    3006:	81 50       	subi	r24, 0x01	; 1
    3008:	8c 93       	st	X, r24
    prvAddTaskToReadyList( pxUnblockedTCB );
    300a:	9e 89       	ldd	r25, Y+22	; 0x16
    300c:	80 91 fa 06 	lds	r24, 0x06FA
    3010:	89 17       	cp	r24, r25
    3012:	10 f4       	brcc	.+4      	; 0x3018 <vTaskRemoveFromUnorderedEventList+0xb2>
    3014:	90 93 fa 06 	sts	0x06FA, r25
    3018:	89 2f       	mov	r24, r25
    301a:	90 e0       	ldi	r25, 0x00	; 0
    301c:	fc 01       	movw	r30, r24
    301e:	73 e0       	ldi	r23, 0x03	; 3
    3020:	ee 0f       	add	r30, r30
    3022:	ff 1f       	adc	r31, r31
    3024:	7a 95       	dec	r23
    3026:	e1 f7       	brne	.-8      	; 0x3020 <vTaskRemoveFromUnorderedEventList+0xba>
    3028:	e8 0f       	add	r30, r24
    302a:	f9 1f       	adc	r31, r25
    302c:	e7 5f       	subi	r30, 0xF7	; 247
    302e:	f8 4f       	sbci	r31, 0xF8	; 248
    3030:	a1 81       	ldd	r26, Z+1	; 0x01
    3032:	b2 81       	ldd	r27, Z+2	; 0x02
    3034:	f9 01       	movw	r30, r18
    3036:	b5 83       	std	Z+5, r27	; 0x05
    3038:	a4 83       	std	Z+4, r26	; 0x04
    303a:	14 96       	adiw	r26, 0x04	; 4
    303c:	8d 91       	ld	r24, X+
    303e:	9c 91       	ld	r25, X
    3040:	15 97       	sbiw	r26, 0x05	; 5
    3042:	97 83       	std	Z+7, r25	; 0x07
    3044:	86 83       	std	Z+6, r24	; 0x06
    3046:	14 96       	adiw	r26, 0x04	; 4
    3048:	ed 91       	ld	r30, X+
    304a:	fc 91       	ld	r31, X
    304c:	15 97       	sbiw	r26, 0x05	; 5
    304e:	53 83       	std	Z+3, r21	; 0x03
    3050:	42 83       	std	Z+2, r20	; 0x02
    3052:	15 96       	adiw	r26, 0x05	; 5
    3054:	5c 93       	st	X, r21
    3056:	4e 93       	st	-X, r20
    3058:	14 97       	sbiw	r26, 0x04	; 4
    305a:	d9 01       	movw	r26, r18
    305c:	56 96       	adiw	r26, 0x16	; 22
    305e:	ec 91       	ld	r30, X
    3060:	56 97       	sbiw	r26, 0x16	; 22
    3062:	89 e0       	ldi	r24, 0x09	; 9
    3064:	e8 9f       	mul	r30, r24
    3066:	f0 01       	movw	r30, r0
    3068:	11 24       	eor	r1, r1
    306a:	e7 5f       	subi	r30, 0xF7	; 247
    306c:	f8 4f       	sbci	r31, 0xF8	; 248
    306e:	1b 96       	adiw	r26, 0x0b	; 11
    3070:	fc 93       	st	X, r31
    3072:	ee 93       	st	-X, r30
    3074:	1a 97       	sbiw	r26, 0x0a	; 10
    3076:	80 81       	ld	r24, Z
    3078:	8f 5f       	subi	r24, 0xFF	; 255
    307a:	80 83       	st	Z, r24

    if( pxUnblockedTCB->uxPriority > pxCurrentTCB->uxPriority )
    307c:	e0 91 f7 06 	lds	r30, 0x06F7
    3080:	f0 91 f8 06 	lds	r31, 0x06F8
    3084:	56 96       	adiw	r26, 0x16	; 22
    3086:	9c 91       	ld	r25, X
    3088:	86 89       	ldd	r24, Z+22	; 0x16
    308a:	89 17       	cp	r24, r25
    308c:	18 f4       	brcc	.+6      	; 0x3094 <vTaskRemoveFromUnorderedEventList+0x12e>
    {
        /* The unblocked task has a priority above that of the calling task, so
         * a context switch is required.  This function is called with the
         * scheduler suspended so xYieldPending is set so the context switch
         * occurs immediately that the scheduler is resumed (unsuspended). */
        xYieldPending = pdTRUE;
    308e:	81 e0       	ldi	r24, 0x01	; 1
    3090:	80 93 fb 06 	sts	0x06FB, r24
    }
}
    3094:	df 91       	pop	r29
    3096:	cf 91       	pop	r28
    3098:	08 95       	ret

0000309a <vTaskSetTimeOutState>:
/*-----------------------------------------------------------*/

void vTaskSetTimeOutState( TimeOut_t * const pxTimeOut )
{
    309a:	fc 01       	movw	r30, r24
    configASSERT( pxTimeOut );
    taskENTER_CRITICAL();
    309c:	0f b6       	in	r0, 0x3f	; 63
    309e:	f8 94       	cli
    30a0:	0f 92       	push	r0
    {
        pxTimeOut->xOverflowCount = xNumOfOverflows;
    30a2:	80 91 00 07 	lds	r24, 0x0700
    30a6:	80 83       	st	Z, r24
        pxTimeOut->xTimeOnEntering = xTickCount;
    30a8:	80 91 fc 06 	lds	r24, 0x06FC
    30ac:	90 91 fd 06 	lds	r25, 0x06FD
    30b0:	92 83       	std	Z+2, r25	; 0x02
    30b2:	81 83       	std	Z+1, r24	; 0x01
    }
    taskEXIT_CRITICAL();
    30b4:	0f 90       	pop	r0
    30b6:	0f be       	out	0x3f, r0	; 63
}
    30b8:	08 95       	ret

000030ba <vTaskInternalSetTimeOutState>:
/*-----------------------------------------------------------*/

void vTaskInternalSetTimeOutState( TimeOut_t * const pxTimeOut )
{
    30ba:	fc 01       	movw	r30, r24
    /* For internal use only as it does not use a critical section. */
    pxTimeOut->xOverflowCount = xNumOfOverflows;
    30bc:	80 91 00 07 	lds	r24, 0x0700
    30c0:	80 83       	st	Z, r24
    pxTimeOut->xTimeOnEntering = xTickCount;
    30c2:	80 91 fc 06 	lds	r24, 0x06FC
    30c6:	90 91 fd 06 	lds	r25, 0x06FD
    30ca:	92 83       	std	Z+2, r25	; 0x02
    30cc:	81 83       	std	Z+1, r24	; 0x01
}
    30ce:	08 95       	ret

000030d0 <xTaskCheckForTimeOut>:
/*-----------------------------------------------------------*/

BaseType_t xTaskCheckForTimeOut( TimeOut_t * const pxTimeOut,
                                 TickType_t * const pxTicksToWait )
{
    30d0:	dc 01       	movw	r26, r24
    30d2:	fb 01       	movw	r30, r22
    BaseType_t xReturn;

    configASSERT( pxTimeOut );
    configASSERT( pxTicksToWait );

    taskENTER_CRITICAL();
    30d4:	0f b6       	in	r0, 0x3f	; 63
    30d6:	f8 94       	cli
    30d8:	0f 92       	push	r0
    {
        /* Minor optimisation.  The tick count cannot change in this block. */
        const TickType_t xConstTickCount = xTickCount;
    30da:	60 91 fc 06 	lds	r22, 0x06FC
    30de:	70 91 fd 06 	lds	r23, 0x06FD
        const TickType_t xElapsedTime = xConstTickCount - pxTimeOut->xTimeOnEntering;
    30e2:	11 96       	adiw	r26, 0x01	; 1
    30e4:	4d 91       	ld	r20, X+
    30e6:	5c 91       	ld	r21, X
    30e8:	12 97       	sbiw	r26, 0x02	; 2
            }
            else
        #endif

        #if ( INCLUDE_vTaskSuspend == 1 )
            if( *pxTicksToWait == portMAX_DELAY )
    30ea:	20 81       	ld	r18, Z
    30ec:	31 81       	ldd	r19, Z+1	; 0x01
    30ee:	8f ef       	ldi	r24, 0xFF	; 255
    30f0:	2f 3f       	cpi	r18, 0xFF	; 255
    30f2:	38 07       	cpc	r19, r24
    30f4:	e9 f0       	breq	.+58     	; 0x3130 <xTaskCheckForTimeOut+0x60>
                xReturn = pdFALSE;
            }
            else
        #endif

        if( ( xNumOfOverflows != pxTimeOut->xOverflowCount ) && ( xConstTickCount >= pxTimeOut->xTimeOnEntering ) ) /*lint !e525 Indentation preferred as is to make code within pre-processor directives clearer. */
    30f6:	90 91 00 07 	lds	r25, 0x0700
    30fa:	8c 91       	ld	r24, X
    30fc:	98 17       	cp	r25, r24
    30fe:	19 f0       	breq	.+6      	; 0x3106 <xTaskCheckForTimeOut+0x36>
    3100:	64 17       	cp	r22, r20
    3102:	75 07       	cpc	r23, r21
    3104:	b8 f4       	brcc	.+46     	; 0x3134 <xTaskCheckForTimeOut+0x64>

    taskENTER_CRITICAL();
    {
        /* Minor optimisation.  The tick count cannot change in this block. */
        const TickType_t xConstTickCount = xTickCount;
        const TickType_t xElapsedTime = xConstTickCount - pxTimeOut->xTimeOnEntering;
    3106:	cb 01       	movw	r24, r22
    3108:	84 1b       	sub	r24, r20
    310a:	95 0b       	sbc	r25, r21
             * around and gone past again. This passed since vTaskSetTimeout()
             * was called. */
            xReturn = pdTRUE;
            *pxTicksToWait = ( TickType_t ) 0;
        }
        else if( xElapsedTime < *pxTicksToWait ) /*lint !e961 Explicit casting is only redundant with some compilers, whereas others require it to prevent integer conversion errors. */
    310c:	82 17       	cp	r24, r18
    310e:	93 07       	cpc	r25, r19
    3110:	88 f4       	brcc	.+34     	; 0x3134 <xTaskCheckForTimeOut+0x64>
        {
            /* Not a genuine timeout. Adjust parameters for time remaining. */
            *pxTicksToWait -= xElapsedTime;
    3112:	28 1b       	sub	r18, r24
    3114:	39 0b       	sbc	r19, r25
    3116:	31 83       	std	Z+1, r19	; 0x01
    3118:	20 83       	st	Z, r18
/*-----------------------------------------------------------*/

void vTaskInternalSetTimeOutState( TimeOut_t * const pxTimeOut )
{
    /* For internal use only as it does not use a critical section. */
    pxTimeOut->xOverflowCount = xNumOfOverflows;
    311a:	80 91 00 07 	lds	r24, 0x0700
    311e:	8c 93       	st	X, r24
    pxTimeOut->xTimeOnEntering = xTickCount;
    3120:	80 91 fc 06 	lds	r24, 0x06FC
    3124:	90 91 fd 06 	lds	r25, 0x06FD
    3128:	12 96       	adiw	r26, 0x02	; 2
    312a:	9c 93       	st	X, r25
    312c:	8e 93       	st	-X, r24
    312e:	11 97       	sbiw	r26, 0x01	; 1
    3130:	80 e0       	ldi	r24, 0x00	; 0
    3132:	03 c0       	rjmp	.+6      	; 0x313a <xTaskCheckForTimeOut+0x6a>
            vTaskInternalSetTimeOutState( pxTimeOut );
            xReturn = pdFALSE;
        }
        else
        {
            *pxTicksToWait = ( TickType_t ) 0;
    3134:	11 82       	std	Z+1, r1	; 0x01
    3136:	10 82       	st	Z, r1
    3138:	81 e0       	ldi	r24, 0x01	; 1
            xReturn = pdTRUE;
        }
    }
    taskEXIT_CRITICAL();
    313a:	0f 90       	pop	r0
    313c:	0f be       	out	0x3f, r0	; 63

    return xReturn;
}
    313e:	08 95       	ret

00003140 <vTaskMissedYield>:
/*-----------------------------------------------------------*/

void vTaskMissedYield( void )
{
    xYieldPending = pdTRUE;
    3140:	81 e0       	ldi	r24, 0x01	; 1
    3142:	80 93 fb 06 	sts	0x06FB, r24
}
    3146:	08 95       	ret

00003148 <xTaskGetCurrentTaskHandle>:
        TaskHandle_t xReturn;

        /* A critical section is not required as this is not called from
         * an interrupt and the current TCB will always be the same for any
         * individual execution thread. */
        xReturn = pxCurrentTCB;
    3148:	20 91 f7 06 	lds	r18, 0x06F7
    314c:	30 91 f8 06 	lds	r19, 0x06F8

        return xReturn;
    }
    3150:	c9 01       	movw	r24, r18
    3152:	08 95       	ret

00003154 <uxTaskResetEventItemValue>:

TickType_t uxTaskResetEventItemValue( void )
{
    TickType_t uxReturn;

    uxReturn = listGET_LIST_ITEM_VALUE( &( pxCurrentTCB->xEventListItem ) );
    3154:	e0 91 f7 06 	lds	r30, 0x06F7
    3158:	f0 91 f8 06 	lds	r31, 0x06F8
    315c:	84 85       	ldd	r24, Z+12	; 0x0c
    315e:	95 85       	ldd	r25, Z+13	; 0x0d

    /* Reset the event list item to its normal value - so it can be used with
     * queues and semaphores. */
    listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xEventListItem ), ( ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) pxCurrentTCB->uxPriority ) ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
    3160:	a0 91 f7 06 	lds	r26, 0x06F7
    3164:	b0 91 f8 06 	lds	r27, 0x06F8
    3168:	e0 91 f7 06 	lds	r30, 0x06F7
    316c:	f0 91 f8 06 	lds	r31, 0x06F8
    3170:	46 89       	ldd	r20, Z+22	; 0x16
    3172:	24 e0       	ldi	r18, 0x04	; 4
    3174:	30 e0       	ldi	r19, 0x00	; 0
    3176:	24 1b       	sub	r18, r20
    3178:	31 09       	sbc	r19, r1
    317a:	1d 96       	adiw	r26, 0x0d	; 13
    317c:	3c 93       	st	X, r19
    317e:	2e 93       	st	-X, r18
    3180:	1c 97       	sbiw	r26, 0x0c	; 12

    return uxReturn;
}
    3182:	08 95       	ret

00003184 <pvTaskIncrementMutexHeldCount>:

    TaskHandle_t pvTaskIncrementMutexHeldCount( void )
    {
        /* If xSemaphoreCreateMutex() is called before any tasks have been created
         * then pxCurrentTCB will be NULL. */
        if( pxCurrentTCB != NULL )
    3184:	80 91 f7 06 	lds	r24, 0x06F7
    3188:	90 91 f8 06 	lds	r25, 0x06F8
    318c:	89 2b       	or	r24, r25
    318e:	39 f0       	breq	.+14     	; 0x319e <pvTaskIncrementMutexHeldCount+0x1a>
        {
            ( pxCurrentTCB->uxMutexesHeld )++;
    3190:	e0 91 f7 06 	lds	r30, 0x06F7
    3194:	f0 91 f8 06 	lds	r31, 0x06F8
    3198:	82 a1       	ldd	r24, Z+34	; 0x22
    319a:	8f 5f       	subi	r24, 0xFF	; 255
    319c:	82 a3       	std	Z+34, r24	; 0x22
        }

        return pxCurrentTCB;
    319e:	20 91 f7 06 	lds	r18, 0x06F7
    31a2:	30 91 f8 06 	lds	r19, 0x06F8
    }
    31a6:	c9 01       	movw	r24, r18
    31a8:	08 95       	ret

000031aa <xTaskGenericNotifyFromISR>:
                                          UBaseType_t uxIndexToNotify,
                                          uint32_t ulValue,
                                          eNotifyAction eAction,
                                          uint32_t * pulPreviousNotificationValue,
                                          BaseType_t * pxHigherPriorityTaskWoken )
    {
    31aa:	cf 92       	push	r12
    31ac:	df 92       	push	r13
    31ae:	ef 92       	push	r14
    31b0:	ff 92       	push	r15
    31b2:	0f 93       	push	r16
    31b4:	cf 93       	push	r28
    31b6:	df 93       	push	r29
    31b8:	ec 01       	movw	r28, r24

        pxTCB = xTaskToNotify;

        uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
        {
            if( pulPreviousNotificationValue != NULL )
    31ba:	e1 14       	cp	r14, r1
    31bc:	f1 04       	cpc	r15, r1
    31be:	89 f0       	breq	.+34     	; 0x31e2 <xTaskGenericNotifyFromISR+0x38>
            {
                *pulPreviousNotificationValue = pxTCB->ulNotifiedValue[ uxIndexToNotify ];
    31c0:	e6 2f       	mov	r30, r22
    31c2:	f0 e0       	ldi	r31, 0x00	; 0
    31c4:	ee 0f       	add	r30, r30
    31c6:	ff 1f       	adc	r31, r31
    31c8:	ee 0f       	add	r30, r30
    31ca:	ff 1f       	adc	r31, r31
    31cc:	e8 0f       	add	r30, r24
    31ce:	f9 1f       	adc	r31, r25
    31d0:	83 a1       	ldd	r24, Z+35	; 0x23
    31d2:	94 a1       	ldd	r25, Z+36	; 0x24
    31d4:	a5 a1       	ldd	r26, Z+37	; 0x25
    31d6:	b6 a1       	ldd	r27, Z+38	; 0x26
    31d8:	f7 01       	movw	r30, r14
    31da:	80 83       	st	Z, r24
    31dc:	91 83       	std	Z+1, r25	; 0x01
    31de:	a2 83       	std	Z+2, r26	; 0x02
    31e0:	b3 83       	std	Z+3, r27	; 0x03
            }

            ucOriginalNotifyState = pxTCB->ucNotifyState[ uxIndexToNotify ];
    31e2:	a6 2f       	mov	r26, r22
    31e4:	b0 e0       	ldi	r27, 0x00	; 0
    31e6:	fe 01       	movw	r30, r28
    31e8:	ea 0f       	add	r30, r26
    31ea:	fb 1f       	adc	r31, r27
    31ec:	67 a1       	ldd	r22, Z+39	; 0x27
            pxTCB->ucNotifyState[ uxIndexToNotify ] = taskNOTIFICATION_RECEIVED;
    31ee:	82 e0       	ldi	r24, 0x02	; 2
    31f0:	87 a3       	std	Z+39, r24	; 0x27

            switch( eAction )
    31f2:	02 30       	cpi	r16, 0x02	; 2
    31f4:	d1 f0       	breq	.+52     	; 0x322a <xTaskGenericNotifyFromISR+0x80>
    31f6:	03 30       	cpi	r16, 0x03	; 3
    31f8:	18 f4       	brcc	.+6      	; 0x3200 <xTaskGenericNotifyFromISR+0x56>
    31fa:	01 30       	cpi	r16, 0x01	; 1
    31fc:	c9 f5       	brne	.+114    	; 0x3270 <xTaskGenericNotifyFromISR+0xc6>
    31fe:	05 c0       	rjmp	.+10     	; 0x320a <xTaskGenericNotifyFromISR+0x60>
    3200:	03 30       	cpi	r16, 0x03	; 3
    3202:	51 f1       	breq	.+84     	; 0x3258 <xTaskGenericNotifyFromISR+0xae>
    3204:	04 30       	cpi	r16, 0x04	; 4
    3206:	a1 f5       	brne	.+104    	; 0x3270 <xTaskGenericNotifyFromISR+0xc6>
    3208:	23 c0       	rjmp	.+70     	; 0x3250 <xTaskGenericNotifyFromISR+0xa6>
            {
                case eSetBits:
                    pxTCB->ulNotifiedValue[ uxIndexToNotify ] |= ulValue;
    320a:	fd 01       	movw	r30, r26
    320c:	ee 0f       	add	r30, r30
    320e:	ff 1f       	adc	r31, r31
    3210:	ee 0f       	add	r30, r30
    3212:	ff 1f       	adc	r31, r31
    3214:	ec 0f       	add	r30, r28
    3216:	fd 1f       	adc	r31, r29
    3218:	83 a1       	ldd	r24, Z+35	; 0x23
    321a:	94 a1       	ldd	r25, Z+36	; 0x24
    321c:	a5 a1       	ldd	r26, Z+37	; 0x25
    321e:	b6 a1       	ldd	r27, Z+38	; 0x26
    3220:	82 2b       	or	r24, r18
    3222:	93 2b       	or	r25, r19
    3224:	a4 2b       	or	r26, r20
    3226:	b5 2b       	or	r27, r21
    3228:	0e c0       	rjmp	.+28     	; 0x3246 <xTaskGenericNotifyFromISR+0x9c>
                    break;

                case eIncrement:
                    ( pxTCB->ulNotifiedValue[ uxIndexToNotify ] )++;
    322a:	fd 01       	movw	r30, r26
    322c:	ee 0f       	add	r30, r30
    322e:	ff 1f       	adc	r31, r31
    3230:	ee 0f       	add	r30, r30
    3232:	ff 1f       	adc	r31, r31
    3234:	ec 0f       	add	r30, r28
    3236:	fd 1f       	adc	r31, r29
    3238:	83 a1       	ldd	r24, Z+35	; 0x23
    323a:	94 a1       	ldd	r25, Z+36	; 0x24
    323c:	a5 a1       	ldd	r26, Z+37	; 0x25
    323e:	b6 a1       	ldd	r27, Z+38	; 0x26
    3240:	01 96       	adiw	r24, 0x01	; 1
    3242:	a1 1d       	adc	r26, r1
    3244:	b1 1d       	adc	r27, r1
    3246:	83 a3       	std	Z+35, r24	; 0x23
    3248:	94 a3       	std	Z+36, r25	; 0x24
    324a:	a5 a3       	std	Z+37, r26	; 0x25
    324c:	b6 a3       	std	Z+38, r27	; 0x26
    324e:	10 c0       	rjmp	.+32     	; 0x3270 <xTaskGenericNotifyFromISR+0xc6>
                    pxTCB->ulNotifiedValue[ uxIndexToNotify ] = ulValue;
                    break;

                case eSetValueWithoutOverwrite:

                    if( ucOriginalNotifyState != taskNOTIFICATION_RECEIVED )
    3250:	62 30       	cpi	r22, 0x02	; 2
    3252:	11 f4       	brne	.+4      	; 0x3258 <xTaskGenericNotifyFromISR+0xae>
    3254:	80 e0       	ldi	r24, 0x00	; 0
    3256:	9d c0       	rjmp	.+314    	; 0x3392 <xTaskGenericNotifyFromISR+0x1e8>
                    {
                        pxTCB->ulNotifiedValue[ uxIndexToNotify ] = ulValue;
    3258:	aa 0f       	add	r26, r26
    325a:	bb 1f       	adc	r27, r27
    325c:	aa 0f       	add	r26, r26
    325e:	bb 1f       	adc	r27, r27
    3260:	ac 0f       	add	r26, r28
    3262:	bd 1f       	adc	r27, r29
    3264:	93 96       	adiw	r26, 0x23	; 35
    3266:	2d 93       	st	X+, r18
    3268:	3d 93       	st	X+, r19
    326a:	4d 93       	st	X+, r20
    326c:	5c 93       	st	X, r21
    326e:	96 97       	sbiw	r26, 0x26	; 38

            traceTASK_NOTIFY_FROM_ISR( uxIndexToNotify );

            /* If the task is in the blocked state specifically to wait for a
             * notification then unblock it now. */
            if( ucOriginalNotifyState == taskWAITING_NOTIFICATION )
    3270:	61 30       	cpi	r22, 0x01	; 1
    3272:	09 f0       	breq	.+2      	; 0x3276 <xTaskGenericNotifyFromISR+0xcc>
    3274:	8d c0       	rjmp	.+282    	; 0x3390 <xTaskGenericNotifyFromISR+0x1e6>
            {
                /* The task should not have been on an event list. */
                configASSERT( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) == NULL );

                if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
    3276:	80 91 f9 06 	lds	r24, 0x06F9
    327a:	88 23       	and	r24, r24
    327c:	09 f0       	breq	.+2      	; 0x3280 <xTaskGenericNotifyFromISR+0xd6>
    327e:	55 c0       	rjmp	.+170    	; 0x332a <xTaskGenericNotifyFromISR+0x180>
                {
                    listREMOVE_ITEM( &( pxTCB->xStateListItem ) );
    3280:	aa 85       	ldd	r26, Y+10	; 0x0a
    3282:	bb 85       	ldd	r27, Y+11	; 0x0b
    3284:	4c 81       	ldd	r20, Y+4	; 0x04
    3286:	5d 81       	ldd	r21, Y+5	; 0x05
    3288:	8e 81       	ldd	r24, Y+6	; 0x06
    328a:	9f 81       	ldd	r25, Y+7	; 0x07
    328c:	fa 01       	movw	r30, r20
    328e:	95 83       	std	Z+5, r25	; 0x05
    3290:	84 83       	std	Z+4, r24	; 0x04
    3292:	2e 81       	ldd	r18, Y+6	; 0x06
    3294:	3f 81       	ldd	r19, Y+7	; 0x07
    3296:	f9 01       	movw	r30, r18
    3298:	53 83       	std	Z+3, r21	; 0x03
    329a:	42 83       	std	Z+2, r20	; 0x02
    329c:	ae 01       	movw	r20, r28
    329e:	4e 5f       	subi	r20, 0xFE	; 254
    32a0:	5f 4f       	sbci	r21, 0xFF	; 255
    32a2:	11 96       	adiw	r26, 0x01	; 1
    32a4:	8d 91       	ld	r24, X+
    32a6:	9c 91       	ld	r25, X
    32a8:	12 97       	sbiw	r26, 0x02	; 2
    32aa:	84 17       	cp	r24, r20
    32ac:	95 07       	cpc	r25, r21
    32ae:	21 f4       	brne	.+8      	; 0x32b8 <xTaskGenericNotifyFromISR+0x10e>
    32b0:	12 96       	adiw	r26, 0x02	; 2
    32b2:	3c 93       	st	X, r19
    32b4:	2e 93       	st	-X, r18
    32b6:	11 97       	sbiw	r26, 0x01	; 1
    32b8:	1b 86       	std	Y+11, r1	; 0x0b
    32ba:	1a 86       	std	Y+10, r1	; 0x0a
    32bc:	8c 91       	ld	r24, X
    32be:	81 50       	subi	r24, 0x01	; 1
    32c0:	8c 93       	st	X, r24
                    prvAddTaskToReadyList( pxTCB );
    32c2:	9e 89       	ldd	r25, Y+22	; 0x16
    32c4:	80 91 fa 06 	lds	r24, 0x06FA
    32c8:	89 17       	cp	r24, r25
    32ca:	10 f4       	brcc	.+4      	; 0x32d0 <xTaskGenericNotifyFromISR+0x126>
    32cc:	90 93 fa 06 	sts	0x06FA, r25
    32d0:	89 2f       	mov	r24, r25
    32d2:	90 e0       	ldi	r25, 0x00	; 0
    32d4:	fc 01       	movw	r30, r24
    32d6:	a3 e0       	ldi	r26, 0x03	; 3
    32d8:	ee 0f       	add	r30, r30
    32da:	ff 1f       	adc	r31, r31
    32dc:	aa 95       	dec	r26
    32de:	e1 f7       	brne	.-8      	; 0x32d8 <xTaskGenericNotifyFromISR+0x12e>
    32e0:	e8 0f       	add	r30, r24
    32e2:	f9 1f       	adc	r31, r25
    32e4:	e7 5f       	subi	r30, 0xF7	; 247
    32e6:	f8 4f       	sbci	r31, 0xF8	; 248
    32e8:	a1 81       	ldd	r26, Z+1	; 0x01
    32ea:	b2 81       	ldd	r27, Z+2	; 0x02
    32ec:	bd 83       	std	Y+5, r27	; 0x05
    32ee:	ac 83       	std	Y+4, r26	; 0x04
    32f0:	14 96       	adiw	r26, 0x04	; 4
    32f2:	8d 91       	ld	r24, X+
    32f4:	9c 91       	ld	r25, X
    32f6:	15 97       	sbiw	r26, 0x05	; 5
    32f8:	9f 83       	std	Y+7, r25	; 0x07
    32fa:	8e 83       	std	Y+6, r24	; 0x06
    32fc:	14 96       	adiw	r26, 0x04	; 4
    32fe:	ed 91       	ld	r30, X+
    3300:	fc 91       	ld	r31, X
    3302:	15 97       	sbiw	r26, 0x05	; 5
    3304:	53 83       	std	Z+3, r21	; 0x03
    3306:	42 83       	std	Z+2, r20	; 0x02
    3308:	15 96       	adiw	r26, 0x05	; 5
    330a:	5c 93       	st	X, r21
    330c:	4e 93       	st	-X, r20
    330e:	14 97       	sbiw	r26, 0x04	; 4
    3310:	ee 89       	ldd	r30, Y+22	; 0x16
    3312:	89 e0       	ldi	r24, 0x09	; 9
    3314:	e8 9f       	mul	r30, r24
    3316:	f0 01       	movw	r30, r0
    3318:	11 24       	eor	r1, r1
    331a:	e7 5f       	subi	r30, 0xF7	; 247
    331c:	f8 4f       	sbci	r31, 0xF8	; 248
    331e:	fb 87       	std	Y+11, r31	; 0x0b
    3320:	ea 87       	std	Y+10, r30	; 0x0a
    3322:	80 81       	ld	r24, Z
    3324:	8f 5f       	subi	r24, 0xFF	; 255
    3326:	80 83       	st	Z, r24
    3328:	21 c0       	rjmp	.+66     	; 0x336c <xTaskGenericNotifyFromISR+0x1c2>
                }
                else
                {
                    /* The delayed and ready lists cannot be accessed, so hold
                     * this task pending until the scheduler is resumed. */
                    listINSERT_END( &( xPendingReadyList ), &( pxTCB->xEventListItem ) );
    332a:	a0 91 44 07 	lds	r26, 0x0744
    332e:	b0 91 45 07 	lds	r27, 0x0745
    3332:	bf 87       	std	Y+15, r27	; 0x0f
    3334:	ae 87       	std	Y+14, r26	; 0x0e
    3336:	14 96       	adiw	r26, 0x04	; 4
    3338:	8d 91       	ld	r24, X+
    333a:	9c 91       	ld	r25, X
    333c:	15 97       	sbiw	r26, 0x05	; 5
    333e:	99 8b       	std	Y+17, r25	; 0x11
    3340:	88 8b       	std	Y+16, r24	; 0x10
    3342:	ce 01       	movw	r24, r28
    3344:	0c 96       	adiw	r24, 0x0c	; 12
    3346:	14 96       	adiw	r26, 0x04	; 4
    3348:	ed 91       	ld	r30, X+
    334a:	fc 91       	ld	r31, X
    334c:	15 97       	sbiw	r26, 0x05	; 5
    334e:	93 83       	std	Z+3, r25	; 0x03
    3350:	82 83       	std	Z+2, r24	; 0x02
    3352:	15 96       	adiw	r26, 0x05	; 5
    3354:	9c 93       	st	X, r25
    3356:	8e 93       	st	-X, r24
    3358:	14 97       	sbiw	r26, 0x04	; 4
    335a:	83 e4       	ldi	r24, 0x43	; 67
    335c:	97 e0       	ldi	r25, 0x07	; 7
    335e:	9d 8b       	std	Y+21, r25	; 0x15
    3360:	8c 8b       	std	Y+20, r24	; 0x14
    3362:	80 91 43 07 	lds	r24, 0x0743
    3366:	8f 5f       	subi	r24, 0xFF	; 255
    3368:	80 93 43 07 	sts	0x0743, r24
                }

                if( pxTCB->uxPriority > pxCurrentTCB->uxPriority )
    336c:	e0 91 f7 06 	lds	r30, 0x06F7
    3370:	f0 91 f8 06 	lds	r31, 0x06F8
    3374:	9e 89       	ldd	r25, Y+22	; 0x16
    3376:	86 89       	ldd	r24, Z+22	; 0x16
    3378:	89 17       	cp	r24, r25
    337a:	50 f4       	brcc	.+20     	; 0x3390 <xTaskGenericNotifyFromISR+0x1e6>
                {
                    /* The notified task has a priority above the currently
                     * executing task so a yield is required. */
                    if( pxHigherPriorityTaskWoken != NULL )
    337c:	c1 14       	cp	r12, r1
    337e:	d1 04       	cpc	r13, r1
    3380:	19 f0       	breq	.+6      	; 0x3388 <xTaskGenericNotifyFromISR+0x1de>
                    {
                        *pxHigherPriorityTaskWoken = pdTRUE;
    3382:	81 e0       	ldi	r24, 0x01	; 1
    3384:	f6 01       	movw	r30, r12
    3386:	80 83       	st	Z, r24
                    }

                    /* Mark that a yield is pending in case the user is not
                     * using the "xHigherPriorityTaskWoken" parameter to an ISR
                     * safe FreeRTOS function. */
                    xYieldPending = pdTRUE;
    3388:	81 e0       	ldi	r24, 0x01	; 1
    338a:	80 93 fb 06 	sts	0x06FB, r24
    338e:	01 c0       	rjmp	.+2      	; 0x3392 <xTaskGenericNotifyFromISR+0x1e8>
    3390:	81 e0       	ldi	r24, 0x01	; 1
            }
        }
        portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

        return xReturn;
    }
    3392:	df 91       	pop	r29
    3394:	cf 91       	pop	r28
    3396:	0f 91       	pop	r16
    3398:	ff 90       	pop	r15
    339a:	ef 90       	pop	r14
    339c:	df 90       	pop	r13
    339e:	cf 90       	pop	r12
    33a0:	08 95       	ret

000033a2 <vTaskGenericNotifyGiveFromISR>:
#if ( configUSE_TASK_NOTIFICATIONS == 1 )

    void vTaskGenericNotifyGiveFromISR( TaskHandle_t xTaskToNotify,
                                        UBaseType_t uxIndexToNotify,
                                        BaseType_t * pxHigherPriorityTaskWoken )
    {
    33a2:	cf 93       	push	r28
    33a4:	df 93       	push	r29
    33a6:	ec 01       	movw	r28, r24
    33a8:	e6 2f       	mov	r30, r22
    33aa:	ba 01       	movw	r22, r20

        pxTCB = xTaskToNotify;

        uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
        {
            ucOriginalNotifyState = pxTCB->ucNotifyState[ uxIndexToNotify ];
    33ac:	f0 e0       	ldi	r31, 0x00	; 0
    33ae:	dc 01       	movw	r26, r24
    33b0:	ae 0f       	add	r26, r30
    33b2:	bf 1f       	adc	r27, r31
    33b4:	97 96       	adiw	r26, 0x27	; 39
    33b6:	2c 91       	ld	r18, X
    33b8:	97 97       	sbiw	r26, 0x27	; 39
            pxTCB->ucNotifyState[ uxIndexToNotify ] = taskNOTIFICATION_RECEIVED;
    33ba:	82 e0       	ldi	r24, 0x02	; 2
    33bc:	97 96       	adiw	r26, 0x27	; 39
    33be:	8c 93       	st	X, r24

            /* 'Giving' is equivalent to incrementing a count in a counting
             * semaphore. */
            ( pxTCB->ulNotifiedValue[ uxIndexToNotify ] )++;
    33c0:	ee 0f       	add	r30, r30
    33c2:	ff 1f       	adc	r31, r31
    33c4:	ee 0f       	add	r30, r30
    33c6:	ff 1f       	adc	r31, r31
    33c8:	ec 0f       	add	r30, r28
    33ca:	fd 1f       	adc	r31, r29
    33cc:	83 a1       	ldd	r24, Z+35	; 0x23
    33ce:	94 a1       	ldd	r25, Z+36	; 0x24
    33d0:	a5 a1       	ldd	r26, Z+37	; 0x25
    33d2:	b6 a1       	ldd	r27, Z+38	; 0x26
    33d4:	01 96       	adiw	r24, 0x01	; 1
    33d6:	a1 1d       	adc	r26, r1
    33d8:	b1 1d       	adc	r27, r1
    33da:	83 a3       	std	Z+35, r24	; 0x23
    33dc:	94 a3       	std	Z+36, r25	; 0x24
    33de:	a5 a3       	std	Z+37, r26	; 0x25
    33e0:	b6 a3       	std	Z+38, r27	; 0x26

            traceTASK_NOTIFY_GIVE_FROM_ISR( uxIndexToNotify );

            /* If the task is in the blocked state specifically to wait for a
             * notification then unblock it now. */
            if( ucOriginalNotifyState == taskWAITING_NOTIFICATION )
    33e2:	21 30       	cpi	r18, 0x01	; 1
    33e4:	09 f0       	breq	.+2      	; 0x33e8 <vTaskGenericNotifyGiveFromISR+0x46>
    33e6:	8c c0       	rjmp	.+280    	; 0x3500 <vTaskGenericNotifyGiveFromISR+0x15e>
            {
                /* The task should not have been on an event list. */
                configASSERT( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) == NULL );

                if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
    33e8:	80 91 f9 06 	lds	r24, 0x06F9
    33ec:	88 23       	and	r24, r24
    33ee:	09 f0       	breq	.+2      	; 0x33f2 <vTaskGenericNotifyGiveFromISR+0x50>
    33f0:	55 c0       	rjmp	.+170    	; 0x349c <vTaskGenericNotifyGiveFromISR+0xfa>
                {
                    listREMOVE_ITEM( &( pxTCB->xStateListItem ) );
    33f2:	aa 85       	ldd	r26, Y+10	; 0x0a
    33f4:	bb 85       	ldd	r27, Y+11	; 0x0b
    33f6:	4c 81       	ldd	r20, Y+4	; 0x04
    33f8:	5d 81       	ldd	r21, Y+5	; 0x05
    33fa:	8e 81       	ldd	r24, Y+6	; 0x06
    33fc:	9f 81       	ldd	r25, Y+7	; 0x07
    33fe:	fa 01       	movw	r30, r20
    3400:	95 83       	std	Z+5, r25	; 0x05
    3402:	84 83       	std	Z+4, r24	; 0x04
    3404:	2e 81       	ldd	r18, Y+6	; 0x06
    3406:	3f 81       	ldd	r19, Y+7	; 0x07
    3408:	f9 01       	movw	r30, r18
    340a:	53 83       	std	Z+3, r21	; 0x03
    340c:	42 83       	std	Z+2, r20	; 0x02
    340e:	ae 01       	movw	r20, r28
    3410:	4e 5f       	subi	r20, 0xFE	; 254
    3412:	5f 4f       	sbci	r21, 0xFF	; 255
    3414:	11 96       	adiw	r26, 0x01	; 1
    3416:	8d 91       	ld	r24, X+
    3418:	9c 91       	ld	r25, X
    341a:	12 97       	sbiw	r26, 0x02	; 2
    341c:	84 17       	cp	r24, r20
    341e:	95 07       	cpc	r25, r21
    3420:	21 f4       	brne	.+8      	; 0x342a <vTaskGenericNotifyGiveFromISR+0x88>
    3422:	12 96       	adiw	r26, 0x02	; 2
    3424:	3c 93       	st	X, r19
    3426:	2e 93       	st	-X, r18
    3428:	11 97       	sbiw	r26, 0x01	; 1
    342a:	1b 86       	std	Y+11, r1	; 0x0b
    342c:	1a 86       	std	Y+10, r1	; 0x0a
    342e:	8c 91       	ld	r24, X
    3430:	81 50       	subi	r24, 0x01	; 1
    3432:	8c 93       	st	X, r24
                    prvAddTaskToReadyList( pxTCB );
    3434:	9e 89       	ldd	r25, Y+22	; 0x16
    3436:	80 91 fa 06 	lds	r24, 0x06FA
    343a:	89 17       	cp	r24, r25
    343c:	10 f4       	brcc	.+4      	; 0x3442 <vTaskGenericNotifyGiveFromISR+0xa0>
    343e:	90 93 fa 06 	sts	0x06FA, r25
    3442:	89 2f       	mov	r24, r25
    3444:	90 e0       	ldi	r25, 0x00	; 0
    3446:	fc 01       	movw	r30, r24
    3448:	a3 e0       	ldi	r26, 0x03	; 3
    344a:	ee 0f       	add	r30, r30
    344c:	ff 1f       	adc	r31, r31
    344e:	aa 95       	dec	r26
    3450:	e1 f7       	brne	.-8      	; 0x344a <vTaskGenericNotifyGiveFromISR+0xa8>
    3452:	e8 0f       	add	r30, r24
    3454:	f9 1f       	adc	r31, r25
    3456:	e7 5f       	subi	r30, 0xF7	; 247
    3458:	f8 4f       	sbci	r31, 0xF8	; 248
    345a:	a1 81       	ldd	r26, Z+1	; 0x01
    345c:	b2 81       	ldd	r27, Z+2	; 0x02
    345e:	bd 83       	std	Y+5, r27	; 0x05
    3460:	ac 83       	std	Y+4, r26	; 0x04
    3462:	14 96       	adiw	r26, 0x04	; 4
    3464:	8d 91       	ld	r24, X+
    3466:	9c 91       	ld	r25, X
    3468:	15 97       	sbiw	r26, 0x05	; 5
    346a:	9f 83       	std	Y+7, r25	; 0x07
    346c:	8e 83       	std	Y+6, r24	; 0x06
    346e:	14 96       	adiw	r26, 0x04	; 4
    3470:	ed 91       	ld	r30, X+
    3472:	fc 91       	ld	r31, X
    3474:	15 97       	sbiw	r26, 0x05	; 5
    3476:	53 83       	std	Z+3, r21	; 0x03
    3478:	42 83       	std	Z+2, r20	; 0x02
    347a:	15 96       	adiw	r26, 0x05	; 5
    347c:	5c 93       	st	X, r21
    347e:	4e 93       	st	-X, r20
    3480:	14 97       	sbiw	r26, 0x04	; 4
    3482:	ee 89       	ldd	r30, Y+22	; 0x16
    3484:	89 e0       	ldi	r24, 0x09	; 9
    3486:	e8 9f       	mul	r30, r24
    3488:	f0 01       	movw	r30, r0
    348a:	11 24       	eor	r1, r1
    348c:	e7 5f       	subi	r30, 0xF7	; 247
    348e:	f8 4f       	sbci	r31, 0xF8	; 248
    3490:	fb 87       	std	Y+11, r31	; 0x0b
    3492:	ea 87       	std	Y+10, r30	; 0x0a
    3494:	80 81       	ld	r24, Z
    3496:	8f 5f       	subi	r24, 0xFF	; 255
    3498:	80 83       	st	Z, r24
    349a:	21 c0       	rjmp	.+66     	; 0x34de <vTaskGenericNotifyGiveFromISR+0x13c>
                }
                else
                {
                    /* The delayed and ready lists cannot be accessed, so hold
                     * this task pending until the scheduler is resumed. */
                    listINSERT_END( &( xPendingReadyList ), &( pxTCB->xEventListItem ) );
    349c:	a0 91 44 07 	lds	r26, 0x0744
    34a0:	b0 91 45 07 	lds	r27, 0x0745
    34a4:	bf 87       	std	Y+15, r27	; 0x0f
    34a6:	ae 87       	std	Y+14, r26	; 0x0e
    34a8:	14 96       	adiw	r26, 0x04	; 4
    34aa:	8d 91       	ld	r24, X+
    34ac:	9c 91       	ld	r25, X
    34ae:	15 97       	sbiw	r26, 0x05	; 5
    34b0:	99 8b       	std	Y+17, r25	; 0x11
    34b2:	88 8b       	std	Y+16, r24	; 0x10
    34b4:	ce 01       	movw	r24, r28
    34b6:	0c 96       	adiw	r24, 0x0c	; 12
    34b8:	14 96       	adiw	r26, 0x04	; 4
    34ba:	ed 91       	ld	r30, X+
    34bc:	fc 91       	ld	r31, X
    34be:	15 97       	sbiw	r26, 0x05	; 5
    34c0:	93 83       	std	Z+3, r25	; 0x03
    34c2:	82 83       	std	Z+2, r24	; 0x02
    34c4:	15 96       	adiw	r26, 0x05	; 5
    34c6:	9c 93       	st	X, r25
    34c8:	8e 93       	st	-X, r24
    34ca:	14 97       	sbiw	r26, 0x04	; 4
    34cc:	83 e4       	ldi	r24, 0x43	; 67
    34ce:	97 e0       	ldi	r25, 0x07	; 7
    34d0:	9d 8b       	std	Y+21, r25	; 0x15
    34d2:	8c 8b       	std	Y+20, r24	; 0x14
    34d4:	80 91 43 07 	lds	r24, 0x0743
    34d8:	8f 5f       	subi	r24, 0xFF	; 255
    34da:	80 93 43 07 	sts	0x0743, r24
                }

                if( pxTCB->uxPriority > pxCurrentTCB->uxPriority )
    34de:	e0 91 f7 06 	lds	r30, 0x06F7
    34e2:	f0 91 f8 06 	lds	r31, 0x06F8
    34e6:	9e 89       	ldd	r25, Y+22	; 0x16
    34e8:	86 89       	ldd	r24, Z+22	; 0x16
    34ea:	89 17       	cp	r24, r25
    34ec:	48 f4       	brcc	.+18     	; 0x3500 <vTaskGenericNotifyGiveFromISR+0x15e>
                {
                    /* The notified task has a priority above the currently
                     * executing task so a yield is required. */
                    if( pxHigherPriorityTaskWoken != NULL )
    34ee:	61 15       	cp	r22, r1
    34f0:	71 05       	cpc	r23, r1
    34f2:	19 f0       	breq	.+6      	; 0x34fa <vTaskGenericNotifyGiveFromISR+0x158>
                    {
                        *pxHigherPriorityTaskWoken = pdTRUE;
    34f4:	81 e0       	ldi	r24, 0x01	; 1
    34f6:	fb 01       	movw	r30, r22
    34f8:	80 83       	st	Z, r24
                    }

                    /* Mark that a yield is pending in case the user is not
                     * using the "xHigherPriorityTaskWoken" parameter in an ISR
                     * safe FreeRTOS function. */
                    xYieldPending = pdTRUE;
    34fa:	81 e0       	ldi	r24, 0x01	; 1
    34fc:	80 93 fb 06 	sts	0x06FB, r24
                    mtCOVERAGE_TEST_MARKER();
                }
            }
        }
        portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );
    }
    3500:	df 91       	pop	r29
    3502:	cf 91       	pop	r28
    3504:	08 95       	ret

00003506 <xTaskGenericNotifyStateClear>:

        configASSERT( uxIndexToClear < configTASK_NOTIFICATION_ARRAY_ENTRIES );

        /* If null is passed in here then it is the calling task that is having
         * its notification state cleared. */
        pxTCB = prvGetTCBFromHandle( xTask );
    3506:	00 97       	sbiw	r24, 0x00	; 0
    3508:	21 f4       	brne	.+8      	; 0x3512 <xTaskGenericNotifyStateClear+0xc>
    350a:	80 91 f7 06 	lds	r24, 0x06F7
    350e:	90 91 f8 06 	lds	r25, 0x06F8

        taskENTER_CRITICAL();
    3512:	0f b6       	in	r0, 0x3f	; 63
    3514:	f8 94       	cli
    3516:	0f 92       	push	r0
        {
            if( pxTCB->ucNotifyState[ uxIndexToClear ] == taskNOTIFICATION_RECEIVED )
    3518:	fc 01       	movw	r30, r24
    351a:	e6 0f       	add	r30, r22
    351c:	f1 1d       	adc	r31, r1
    351e:	87 a1       	ldd	r24, Z+39	; 0x27
    3520:	82 30       	cpi	r24, 0x02	; 2
    3522:	11 f0       	breq	.+4      	; 0x3528 <xTaskGenericNotifyStateClear+0x22>
    3524:	80 e0       	ldi	r24, 0x00	; 0
    3526:	02 c0       	rjmp	.+4      	; 0x352c <xTaskGenericNotifyStateClear+0x26>
            {
                pxTCB->ucNotifyState[ uxIndexToClear ] = taskNOT_WAITING_NOTIFICATION;
    3528:	17 a2       	std	Z+39, r1	; 0x27
    352a:	81 e0       	ldi	r24, 0x01	; 1
            else
            {
                xReturn = pdFAIL;
            }
        }
        taskEXIT_CRITICAL();
    352c:	0f 90       	pop	r0
    352e:	0f be       	out	0x3f, r0	; 63

        return xReturn;
    }
    3530:	08 95       	ret

00003532 <ulTaskGenericNotifyValueClear>:
#if ( configUSE_TASK_NOTIFICATIONS == 1 )

    uint32_t ulTaskGenericNotifyValueClear( TaskHandle_t xTask,
                                            UBaseType_t uxIndexToClear,
                                            uint32_t ulBitsToClear )
    {
    3532:	ef 92       	push	r14
    3534:	ff 92       	push	r15
    3536:	0f 93       	push	r16
    3538:	1f 93       	push	r17
    353a:	79 01       	movw	r14, r18
    353c:	8a 01       	movw	r16, r20
        TCB_t * pxTCB;
        uint32_t ulReturn;

        /* If null is passed in here then it is the calling task that is having
         * its notification state cleared. */
        pxTCB = prvGetTCBFromHandle( xTask );
    353e:	00 97       	sbiw	r24, 0x00	; 0
    3540:	21 f4       	brne	.+8      	; 0x354a <ulTaskGenericNotifyValueClear+0x18>
    3542:	80 91 f7 06 	lds	r24, 0x06F7
    3546:	90 91 f8 06 	lds	r25, 0x06F8

        taskENTER_CRITICAL();
    354a:	0f b6       	in	r0, 0x3f	; 63
    354c:	f8 94       	cli
    354e:	0f 92       	push	r0
        {
            /* Return the notification as it was before the bits were cleared,
             * then clear the bit mask. */
            ulReturn = pxTCB->ulNotifiedValue[ uxIndexToClear ];
    3550:	e6 2f       	mov	r30, r22
    3552:	f0 e0       	ldi	r31, 0x00	; 0
    3554:	ee 0f       	add	r30, r30
    3556:	ff 1f       	adc	r31, r31
    3558:	ee 0f       	add	r30, r30
    355a:	ff 1f       	adc	r31, r31
    355c:	e8 0f       	add	r30, r24
    355e:	f9 1f       	adc	r31, r25
    3560:	23 a1       	ldd	r18, Z+35	; 0x23
    3562:	34 a1       	ldd	r19, Z+36	; 0x24
    3564:	45 a1       	ldd	r20, Z+37	; 0x25
    3566:	56 a1       	ldd	r21, Z+38	; 0x26
            pxTCB->ulNotifiedValue[ uxIndexToClear ] &= ~ulBitsToClear;
    3568:	83 a1       	ldd	r24, Z+35	; 0x23
    356a:	94 a1       	ldd	r25, Z+36	; 0x24
    356c:	a5 a1       	ldd	r26, Z+37	; 0x25
    356e:	b6 a1       	ldd	r27, Z+38	; 0x26
    3570:	e0 94       	com	r14
    3572:	f0 94       	com	r15
    3574:	00 95       	com	r16
    3576:	10 95       	com	r17
    3578:	8e 21       	and	r24, r14
    357a:	9f 21       	and	r25, r15
    357c:	a0 23       	and	r26, r16
    357e:	b1 23       	and	r27, r17
    3580:	83 a3       	std	Z+35, r24	; 0x23
    3582:	94 a3       	std	Z+36, r25	; 0x24
    3584:	a5 a3       	std	Z+37, r26	; 0x25
    3586:	b6 a3       	std	Z+38, r27	; 0x26
        }
        taskEXIT_CRITICAL();
    3588:	0f 90       	pop	r0
    358a:	0f be       	out	0x3f, r0	; 63

        return ulReturn;
    }
    358c:	b9 01       	movw	r22, r18
    358e:	ca 01       	movw	r24, r20
    3590:	1f 91       	pop	r17
    3592:	0f 91       	pop	r16
    3594:	ff 90       	pop	r15
    3596:	ef 90       	pop	r14
    3598:	08 95       	ret

0000359a <xTaskGenericNotify>:
    BaseType_t xTaskGenericNotify( TaskHandle_t xTaskToNotify,
                                   UBaseType_t uxIndexToNotify,
                                   uint32_t ulValue,
                                   eNotifyAction eAction,
                                   uint32_t * pulPreviousNotificationValue )
    {
    359a:	ef 92       	push	r14
    359c:	ff 92       	push	r15
    359e:	0f 93       	push	r16
    35a0:	cf 93       	push	r28
    35a2:	df 93       	push	r29
    35a4:	ec 01       	movw	r28, r24

        configASSERT( uxIndexToNotify < configTASK_NOTIFICATION_ARRAY_ENTRIES );
        configASSERT( xTaskToNotify );
        pxTCB = xTaskToNotify;

        taskENTER_CRITICAL();
    35a6:	0f b6       	in	r0, 0x3f	; 63
    35a8:	f8 94       	cli
    35aa:	0f 92       	push	r0
        {
            if( pulPreviousNotificationValue != NULL )
    35ac:	e1 14       	cp	r14, r1
    35ae:	f1 04       	cpc	r15, r1
    35b0:	89 f0       	breq	.+34     	; 0x35d4 <xTaskGenericNotify+0x3a>
            {
                *pulPreviousNotificationValue = pxTCB->ulNotifiedValue[ uxIndexToNotify ];
    35b2:	e6 2f       	mov	r30, r22
    35b4:	f0 e0       	ldi	r31, 0x00	; 0
    35b6:	ee 0f       	add	r30, r30
    35b8:	ff 1f       	adc	r31, r31
    35ba:	ee 0f       	add	r30, r30
    35bc:	ff 1f       	adc	r31, r31
    35be:	ec 0f       	add	r30, r28
    35c0:	fd 1f       	adc	r31, r29
    35c2:	83 a1       	ldd	r24, Z+35	; 0x23
    35c4:	94 a1       	ldd	r25, Z+36	; 0x24
    35c6:	a5 a1       	ldd	r26, Z+37	; 0x25
    35c8:	b6 a1       	ldd	r27, Z+38	; 0x26
    35ca:	f7 01       	movw	r30, r14
    35cc:	80 83       	st	Z, r24
    35ce:	91 83       	std	Z+1, r25	; 0x01
    35d0:	a2 83       	std	Z+2, r26	; 0x02
    35d2:	b3 83       	std	Z+3, r27	; 0x03
            }

            ucOriginalNotifyState = pxTCB->ucNotifyState[ uxIndexToNotify ];
    35d4:	a6 2f       	mov	r26, r22
    35d6:	b0 e0       	ldi	r27, 0x00	; 0
    35d8:	fe 01       	movw	r30, r28
    35da:	ea 0f       	add	r30, r26
    35dc:	fb 1f       	adc	r31, r27
    35de:	67 a1       	ldd	r22, Z+39	; 0x27

            pxTCB->ucNotifyState[ uxIndexToNotify ] = taskNOTIFICATION_RECEIVED;
    35e0:	82 e0       	ldi	r24, 0x02	; 2
    35e2:	87 a3       	std	Z+39, r24	; 0x27

            switch( eAction )
    35e4:	02 30       	cpi	r16, 0x02	; 2
    35e6:	d1 f0       	breq	.+52     	; 0x361c <xTaskGenericNotify+0x82>
    35e8:	03 30       	cpi	r16, 0x03	; 3
    35ea:	18 f4       	brcc	.+6      	; 0x35f2 <xTaskGenericNotify+0x58>
    35ec:	01 30       	cpi	r16, 0x01	; 1
    35ee:	c9 f5       	brne	.+114    	; 0x3662 <xTaskGenericNotify+0xc8>
    35f0:	05 c0       	rjmp	.+10     	; 0x35fc <xTaskGenericNotify+0x62>
    35f2:	03 30       	cpi	r16, 0x03	; 3
    35f4:	51 f1       	breq	.+84     	; 0x364a <xTaskGenericNotify+0xb0>
    35f6:	04 30       	cpi	r16, 0x04	; 4
    35f8:	a1 f5       	brne	.+104    	; 0x3662 <xTaskGenericNotify+0xc8>
    35fa:	23 c0       	rjmp	.+70     	; 0x3642 <xTaskGenericNotify+0xa8>
            {
                case eSetBits:
                    pxTCB->ulNotifiedValue[ uxIndexToNotify ] |= ulValue;
    35fc:	fd 01       	movw	r30, r26
    35fe:	ee 0f       	add	r30, r30
    3600:	ff 1f       	adc	r31, r31
    3602:	ee 0f       	add	r30, r30
    3604:	ff 1f       	adc	r31, r31
    3606:	ec 0f       	add	r30, r28
    3608:	fd 1f       	adc	r31, r29
    360a:	83 a1       	ldd	r24, Z+35	; 0x23
    360c:	94 a1       	ldd	r25, Z+36	; 0x24
    360e:	a5 a1       	ldd	r26, Z+37	; 0x25
    3610:	b6 a1       	ldd	r27, Z+38	; 0x26
    3612:	82 2b       	or	r24, r18
    3614:	93 2b       	or	r25, r19
    3616:	a4 2b       	or	r26, r20
    3618:	b5 2b       	or	r27, r21
    361a:	0e c0       	rjmp	.+28     	; 0x3638 <xTaskGenericNotify+0x9e>
                    break;

                case eIncrement:
                    ( pxTCB->ulNotifiedValue[ uxIndexToNotify ] )++;
    361c:	fd 01       	movw	r30, r26
    361e:	ee 0f       	add	r30, r30
    3620:	ff 1f       	adc	r31, r31
    3622:	ee 0f       	add	r30, r30
    3624:	ff 1f       	adc	r31, r31
    3626:	ec 0f       	add	r30, r28
    3628:	fd 1f       	adc	r31, r29
    362a:	83 a1       	ldd	r24, Z+35	; 0x23
    362c:	94 a1       	ldd	r25, Z+36	; 0x24
    362e:	a5 a1       	ldd	r26, Z+37	; 0x25
    3630:	b6 a1       	ldd	r27, Z+38	; 0x26
    3632:	01 96       	adiw	r24, 0x01	; 1
    3634:	a1 1d       	adc	r26, r1
    3636:	b1 1d       	adc	r27, r1
    3638:	83 a3       	std	Z+35, r24	; 0x23
    363a:	94 a3       	std	Z+36, r25	; 0x24
    363c:	a5 a3       	std	Z+37, r26	; 0x25
    363e:	b6 a3       	std	Z+38, r27	; 0x26
    3640:	10 c0       	rjmp	.+32     	; 0x3662 <xTaskGenericNotify+0xc8>
                    pxTCB->ulNotifiedValue[ uxIndexToNotify ] = ulValue;
                    break;

                case eSetValueWithoutOverwrite:

                    if( ucOriginalNotifyState != taskNOTIFICATION_RECEIVED )
    3642:	62 30       	cpi	r22, 0x02	; 2
    3644:	11 f4       	brne	.+4      	; 0x364a <xTaskGenericNotify+0xb0>
    3646:	80 e0       	ldi	r24, 0x00	; 0
    3648:	6e c0       	rjmp	.+220    	; 0x3726 <xTaskGenericNotify+0x18c>
                    {
                        pxTCB->ulNotifiedValue[ uxIndexToNotify ] = ulValue;
    364a:	aa 0f       	add	r26, r26
    364c:	bb 1f       	adc	r27, r27
    364e:	aa 0f       	add	r26, r26
    3650:	bb 1f       	adc	r27, r27
    3652:	ac 0f       	add	r26, r28
    3654:	bd 1f       	adc	r27, r29
    3656:	93 96       	adiw	r26, 0x23	; 35
    3658:	2d 93       	st	X+, r18
    365a:	3d 93       	st	X+, r19
    365c:	4d 93       	st	X+, r20
    365e:	5c 93       	st	X, r21
    3660:	96 97       	sbiw	r26, 0x26	; 38

            traceTASK_NOTIFY( uxIndexToNotify );

            /* If the task is in the blocked state specifically to wait for a
             * notification then unblock it now. */
            if( ucOriginalNotifyState == taskWAITING_NOTIFICATION )
    3662:	61 30       	cpi	r22, 0x01	; 1
    3664:	09 f0       	breq	.+2      	; 0x3668 <xTaskGenericNotify+0xce>
    3666:	5e c0       	rjmp	.+188    	; 0x3724 <xTaskGenericNotify+0x18a>
            {
                listREMOVE_ITEM( &( pxTCB->xStateListItem ) );
    3668:	aa 85       	ldd	r26, Y+10	; 0x0a
    366a:	bb 85       	ldd	r27, Y+11	; 0x0b
    366c:	4c 81       	ldd	r20, Y+4	; 0x04
    366e:	5d 81       	ldd	r21, Y+5	; 0x05
    3670:	8e 81       	ldd	r24, Y+6	; 0x06
    3672:	9f 81       	ldd	r25, Y+7	; 0x07
    3674:	fa 01       	movw	r30, r20
    3676:	95 83       	std	Z+5, r25	; 0x05
    3678:	84 83       	std	Z+4, r24	; 0x04
    367a:	2e 81       	ldd	r18, Y+6	; 0x06
    367c:	3f 81       	ldd	r19, Y+7	; 0x07
    367e:	f9 01       	movw	r30, r18
    3680:	53 83       	std	Z+3, r21	; 0x03
    3682:	42 83       	std	Z+2, r20	; 0x02
    3684:	ae 01       	movw	r20, r28
    3686:	4e 5f       	subi	r20, 0xFE	; 254
    3688:	5f 4f       	sbci	r21, 0xFF	; 255
    368a:	11 96       	adiw	r26, 0x01	; 1
    368c:	8d 91       	ld	r24, X+
    368e:	9c 91       	ld	r25, X
    3690:	12 97       	sbiw	r26, 0x02	; 2
    3692:	84 17       	cp	r24, r20
    3694:	95 07       	cpc	r25, r21
    3696:	21 f4       	brne	.+8      	; 0x36a0 <xTaskGenericNotify+0x106>
    3698:	12 96       	adiw	r26, 0x02	; 2
    369a:	3c 93       	st	X, r19
    369c:	2e 93       	st	-X, r18
    369e:	11 97       	sbiw	r26, 0x01	; 1
    36a0:	1b 86       	std	Y+11, r1	; 0x0b
    36a2:	1a 86       	std	Y+10, r1	; 0x0a
    36a4:	8c 91       	ld	r24, X
    36a6:	81 50       	subi	r24, 0x01	; 1
    36a8:	8c 93       	st	X, r24
                prvAddTaskToReadyList( pxTCB );
    36aa:	9e 89       	ldd	r25, Y+22	; 0x16
    36ac:	80 91 fa 06 	lds	r24, 0x06FA
    36b0:	89 17       	cp	r24, r25
    36b2:	10 f4       	brcc	.+4      	; 0x36b8 <xTaskGenericNotify+0x11e>
    36b4:	90 93 fa 06 	sts	0x06FA, r25
    36b8:	89 2f       	mov	r24, r25
    36ba:	90 e0       	ldi	r25, 0x00	; 0
    36bc:	fc 01       	movw	r30, r24
    36be:	33 e0       	ldi	r19, 0x03	; 3
    36c0:	ee 0f       	add	r30, r30
    36c2:	ff 1f       	adc	r31, r31
    36c4:	3a 95       	dec	r19
    36c6:	e1 f7       	brne	.-8      	; 0x36c0 <xTaskGenericNotify+0x126>
    36c8:	e8 0f       	add	r30, r24
    36ca:	f9 1f       	adc	r31, r25
    36cc:	e7 5f       	subi	r30, 0xF7	; 247
    36ce:	f8 4f       	sbci	r31, 0xF8	; 248
    36d0:	a1 81       	ldd	r26, Z+1	; 0x01
    36d2:	b2 81       	ldd	r27, Z+2	; 0x02
    36d4:	bd 83       	std	Y+5, r27	; 0x05
    36d6:	ac 83       	std	Y+4, r26	; 0x04
    36d8:	14 96       	adiw	r26, 0x04	; 4
    36da:	8d 91       	ld	r24, X+
    36dc:	9c 91       	ld	r25, X
    36de:	15 97       	sbiw	r26, 0x05	; 5
    36e0:	9f 83       	std	Y+7, r25	; 0x07
    36e2:	8e 83       	std	Y+6, r24	; 0x06
    36e4:	14 96       	adiw	r26, 0x04	; 4
    36e6:	ed 91       	ld	r30, X+
    36e8:	fc 91       	ld	r31, X
    36ea:	15 97       	sbiw	r26, 0x05	; 5
    36ec:	53 83       	std	Z+3, r21	; 0x03
    36ee:	42 83       	std	Z+2, r20	; 0x02
    36f0:	15 96       	adiw	r26, 0x05	; 5
    36f2:	5c 93       	st	X, r21
    36f4:	4e 93       	st	-X, r20
    36f6:	14 97       	sbiw	r26, 0x04	; 4
    36f8:	ee 89       	ldd	r30, Y+22	; 0x16
    36fa:	89 e0       	ldi	r24, 0x09	; 9
    36fc:	e8 9f       	mul	r30, r24
    36fe:	f0 01       	movw	r30, r0
    3700:	11 24       	eor	r1, r1
    3702:	e7 5f       	subi	r30, 0xF7	; 247
    3704:	f8 4f       	sbci	r31, 0xF8	; 248
    3706:	fb 87       	std	Y+11, r31	; 0x0b
    3708:	ea 87       	std	Y+10, r30	; 0x0a
    370a:	80 81       	ld	r24, Z
    370c:	8f 5f       	subi	r24, 0xFF	; 255
    370e:	80 83       	st	Z, r24
                     * earliest possible time. */
                    prvResetNextTaskUnblockTime();
                }
                #endif

                if( pxTCB->uxPriority > pxCurrentTCB->uxPriority )
    3710:	e0 91 f7 06 	lds	r30, 0x06F7
    3714:	f0 91 f8 06 	lds	r31, 0x06F8
    3718:	9e 89       	ldd	r25, Y+22	; 0x16
    371a:	86 89       	ldd	r24, Z+22	; 0x16
    371c:	89 17       	cp	r24, r25
    371e:	10 f4       	brcc	.+4      	; 0x3724 <xTaskGenericNotify+0x18a>
                {
                    /* The notified task has a priority above the currently
                     * executing task so a yield is required. */
                    taskYIELD_IF_USING_PREEMPTION();
    3720:	0e 94 64 09 	call	0x12c8	; 0x12c8 <vPortYield>
    3724:	81 e0       	ldi	r24, 0x01	; 1
            else
            {
                mtCOVERAGE_TEST_MARKER();
            }
        }
        taskEXIT_CRITICAL();
    3726:	0f 90       	pop	r0
    3728:	0f be       	out	0x3f, r0	; 63

        return xReturn;
    }
    372a:	df 91       	pop	r29
    372c:	cf 91       	pop	r28
    372e:	0f 91       	pop	r16
    3730:	ff 90       	pop	r15
    3732:	ef 90       	pop	r14
    3734:	08 95       	ret

00003736 <xTaskResumeAll>:

#endif /* configUSE_TICKLESS_IDLE */
/*----------------------------------------------------------*/

BaseType_t xTaskResumeAll( void )
{
    3736:	1f 93       	push	r17
    3738:	cf 93       	push	r28
    373a:	df 93       	push	r29
    /* It is possible that an ISR caused a task to be removed from an event
     * list while the scheduler was suspended.  If this was the case then the
     * removed task will have been added to the xPendingReadyList.  Once the
     * scheduler has been resumed it is safe to move all the pending ready
     * tasks from this list into their appropriate ready list. */
    taskENTER_CRITICAL();
    373c:	0f b6       	in	r0, 0x3f	; 63
    373e:	f8 94       	cli
    3740:	0f 92       	push	r0
    {
        --uxSchedulerSuspended;
    3742:	80 91 f9 06 	lds	r24, 0x06F9
    3746:	81 50       	subi	r24, 0x01	; 1
    3748:	80 93 f9 06 	sts	0x06F9, r24

        if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
    374c:	80 91 f9 06 	lds	r24, 0x06F9
    3750:	88 23       	and	r24, r24
    3752:	09 f0       	breq	.+2      	; 0x3756 <xTaskResumeAll+0x20>
    3754:	c7 c0       	rjmp	.+398    	; 0x38e4 <xTaskResumeAll+0x1ae>
        {
            if( uxCurrentNumberOfTasks > ( UBaseType_t ) 0U )
    3756:	80 91 03 07 	lds	r24, 0x0703
    375a:	88 23       	and	r24, r24
    375c:	09 f4       	brne	.+2      	; 0x3760 <xTaskResumeAll+0x2a>
    375e:	c2 c0       	rjmp	.+388    	; 0x38e4 <xTaskResumeAll+0x1ae>
    3760:	c0 e0       	ldi	r28, 0x00	; 0
    3762:	d0 e0       	ldi	r29, 0x00	; 0
                {
                    pxTCB = listGET_OWNER_OF_HEAD_ENTRY( ( &xPendingReadyList ) ); /*lint !e9079 void * is used as this macro is used with timers and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
                    listREMOVE_ITEM( &( pxTCB->xEventListItem ) );
                    portMEMORY_BARRIER();
                    listREMOVE_ITEM( &( pxTCB->xStateListItem ) );
                    prvAddTaskToReadyList( pxTCB );
    3764:	79 e0       	ldi	r23, 0x09	; 9

                    /* If the moved task has a priority higher than or equal to
                     * the current task then a yield must be performed. */
                    if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
                    {
                        xYieldPending = pdTRUE;
    3766:	61 e0       	ldi	r22, 0x01	; 1
    3768:	84 c0       	rjmp	.+264    	; 0x3872 <xTaskResumeAll+0x13c>
            {
                /* Move any readied tasks from the pending list into the
                 * appropriate ready list. */
                while( listLIST_IS_EMPTY( &xPendingReadyList ) == pdFALSE )
                {
                    pxTCB = listGET_OWNER_OF_HEAD_ENTRY( ( &xPendingReadyList ) ); /*lint !e9079 void * is used as this macro is used with timers and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
    376a:	e0 91 48 07 	lds	r30, 0x0748
    376e:	f0 91 49 07 	lds	r31, 0x0749
    3772:	c6 81       	ldd	r28, Z+6	; 0x06
    3774:	d7 81       	ldd	r29, Z+7	; 0x07
                    listREMOVE_ITEM( &( pxTCB->xEventListItem ) );
    3776:	ac 89       	ldd	r26, Y+20	; 0x14
    3778:	bd 89       	ldd	r27, Y+21	; 0x15
    377a:	2e 85       	ldd	r18, Y+14	; 0x0e
    377c:	3f 85       	ldd	r19, Y+15	; 0x0f
    377e:	88 89       	ldd	r24, Y+16	; 0x10
    3780:	99 89       	ldd	r25, Y+17	; 0x11
    3782:	f9 01       	movw	r30, r18
    3784:	95 83       	std	Z+5, r25	; 0x05
    3786:	84 83       	std	Z+4, r24	; 0x04
    3788:	48 89       	ldd	r20, Y+16	; 0x10
    378a:	59 89       	ldd	r21, Y+17	; 0x11
    378c:	fa 01       	movw	r30, r20
    378e:	33 83       	std	Z+3, r19	; 0x03
    3790:	22 83       	std	Z+2, r18	; 0x02
    3792:	9e 01       	movw	r18, r28
    3794:	24 5f       	subi	r18, 0xF4	; 244
    3796:	3f 4f       	sbci	r19, 0xFF	; 255
    3798:	11 96       	adiw	r26, 0x01	; 1
    379a:	8d 91       	ld	r24, X+
    379c:	9c 91       	ld	r25, X
    379e:	12 97       	sbiw	r26, 0x02	; 2
    37a0:	82 17       	cp	r24, r18
    37a2:	93 07       	cpc	r25, r19
    37a4:	21 f4       	brne	.+8      	; 0x37ae <xTaskResumeAll+0x78>
    37a6:	12 96       	adiw	r26, 0x02	; 2
    37a8:	5c 93       	st	X, r21
    37aa:	4e 93       	st	-X, r20
    37ac:	11 97       	sbiw	r26, 0x01	; 1
    37ae:	1d 8a       	std	Y+21, r1	; 0x15
    37b0:	1c 8a       	std	Y+20, r1	; 0x14
    37b2:	8c 91       	ld	r24, X
    37b4:	81 50       	subi	r24, 0x01	; 1
    37b6:	8c 93       	st	X, r24
                    portMEMORY_BARRIER();
                    listREMOVE_ITEM( &( pxTCB->xStateListItem ) );
    37b8:	aa 85       	ldd	r26, Y+10	; 0x0a
    37ba:	bb 85       	ldd	r27, Y+11	; 0x0b
    37bc:	4c 81       	ldd	r20, Y+4	; 0x04
    37be:	5d 81       	ldd	r21, Y+5	; 0x05
    37c0:	8e 81       	ldd	r24, Y+6	; 0x06
    37c2:	9f 81       	ldd	r25, Y+7	; 0x07
    37c4:	fa 01       	movw	r30, r20
    37c6:	95 83       	std	Z+5, r25	; 0x05
    37c8:	84 83       	std	Z+4, r24	; 0x04
    37ca:	2e 81       	ldd	r18, Y+6	; 0x06
    37cc:	3f 81       	ldd	r19, Y+7	; 0x07
    37ce:	f9 01       	movw	r30, r18
    37d0:	53 83       	std	Z+3, r21	; 0x03
    37d2:	42 83       	std	Z+2, r20	; 0x02
    37d4:	ae 01       	movw	r20, r28
    37d6:	4e 5f       	subi	r20, 0xFE	; 254
    37d8:	5f 4f       	sbci	r21, 0xFF	; 255
    37da:	11 96       	adiw	r26, 0x01	; 1
    37dc:	8d 91       	ld	r24, X+
    37de:	9c 91       	ld	r25, X
    37e0:	12 97       	sbiw	r26, 0x02	; 2
    37e2:	84 17       	cp	r24, r20
    37e4:	95 07       	cpc	r25, r21
    37e6:	21 f4       	brne	.+8      	; 0x37f0 <xTaskResumeAll+0xba>
    37e8:	12 96       	adiw	r26, 0x02	; 2
    37ea:	3c 93       	st	X, r19
    37ec:	2e 93       	st	-X, r18
    37ee:	11 97       	sbiw	r26, 0x01	; 1
    37f0:	1b 86       	std	Y+11, r1	; 0x0b
    37f2:	1a 86       	std	Y+10, r1	; 0x0a
    37f4:	8c 91       	ld	r24, X
    37f6:	81 50       	subi	r24, 0x01	; 1
    37f8:	8c 93       	st	X, r24
                    prvAddTaskToReadyList( pxTCB );
    37fa:	9e 89       	ldd	r25, Y+22	; 0x16
    37fc:	80 91 fa 06 	lds	r24, 0x06FA
    3800:	89 17       	cp	r24, r25
    3802:	10 f4       	brcc	.+4      	; 0x3808 <xTaskResumeAll+0xd2>
    3804:	90 93 fa 06 	sts	0x06FA, r25
    3808:	89 2f       	mov	r24, r25
    380a:	90 e0       	ldi	r25, 0x00	; 0
    380c:	fc 01       	movw	r30, r24
    380e:	23 e0       	ldi	r18, 0x03	; 3
    3810:	ee 0f       	add	r30, r30
    3812:	ff 1f       	adc	r31, r31
    3814:	2a 95       	dec	r18
    3816:	e1 f7       	brne	.-8      	; 0x3810 <xTaskResumeAll+0xda>
    3818:	e8 0f       	add	r30, r24
    381a:	f9 1f       	adc	r31, r25
    381c:	e7 5f       	subi	r30, 0xF7	; 247
    381e:	f8 4f       	sbci	r31, 0xF8	; 248
    3820:	a1 81       	ldd	r26, Z+1	; 0x01
    3822:	b2 81       	ldd	r27, Z+2	; 0x02
    3824:	bd 83       	std	Y+5, r27	; 0x05
    3826:	ac 83       	std	Y+4, r26	; 0x04
    3828:	14 96       	adiw	r26, 0x04	; 4
    382a:	8d 91       	ld	r24, X+
    382c:	9c 91       	ld	r25, X
    382e:	15 97       	sbiw	r26, 0x05	; 5
    3830:	9f 83       	std	Y+7, r25	; 0x07
    3832:	8e 83       	std	Y+6, r24	; 0x06
    3834:	14 96       	adiw	r26, 0x04	; 4
    3836:	ed 91       	ld	r30, X+
    3838:	fc 91       	ld	r31, X
    383a:	15 97       	sbiw	r26, 0x05	; 5
    383c:	53 83       	std	Z+3, r21	; 0x03
    383e:	42 83       	std	Z+2, r20	; 0x02
    3840:	15 96       	adiw	r26, 0x05	; 5
    3842:	5c 93       	st	X, r21
    3844:	4e 93       	st	-X, r20
    3846:	14 97       	sbiw	r26, 0x04	; 4
    3848:	ee 89       	ldd	r30, Y+22	; 0x16
    384a:	e7 9f       	mul	r30, r23
    384c:	f0 01       	movw	r30, r0
    384e:	11 24       	eor	r1, r1
    3850:	e7 5f       	subi	r30, 0xF7	; 247
    3852:	f8 4f       	sbci	r31, 0xF8	; 248
    3854:	fb 87       	std	Y+11, r31	; 0x0b
    3856:	ea 87       	std	Y+10, r30	; 0x0a
    3858:	80 81       	ld	r24, Z
    385a:	8f 5f       	subi	r24, 0xFF	; 255
    385c:	80 83       	st	Z, r24

                    /* If the moved task has a priority higher than or equal to
                     * the current task then a yield must be performed. */
                    if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
    385e:	e0 91 f7 06 	lds	r30, 0x06F7
    3862:	f0 91 f8 06 	lds	r31, 0x06F8
    3866:	9e 89       	ldd	r25, Y+22	; 0x16
    3868:	86 89       	ldd	r24, Z+22	; 0x16
    386a:	98 17       	cp	r25, r24
    386c:	10 f0       	brcs	.+4      	; 0x3872 <xTaskResumeAll+0x13c>
                    {
                        xYieldPending = pdTRUE;
    386e:	60 93 fb 06 	sts	0x06FB, r22
        {
            if( uxCurrentNumberOfTasks > ( UBaseType_t ) 0U )
            {
                /* Move any readied tasks from the pending list into the
                 * appropriate ready list. */
                while( listLIST_IS_EMPTY( &xPendingReadyList ) == pdFALSE )
    3872:	80 91 43 07 	lds	r24, 0x0743
    3876:	88 23       	and	r24, r24
    3878:	09 f0       	breq	.+2      	; 0x387c <xTaskResumeAll+0x146>
    387a:	77 cf       	rjmp	.-274    	; 0x376a <xTaskResumeAll+0x34>
                    {
                        mtCOVERAGE_TEST_MARKER();
                    }
                }

                if( pxTCB != NULL )
    387c:	cd 2b       	or	r28, r29
    387e:	b9 f0       	breq	.+46     	; 0x38ae <xTaskResumeAll+0x178>
#endif /* INCLUDE_vTaskDelete */
/*-----------------------------------------------------------*/

static void prvResetNextTaskUnblockTime( void )
{
    if( listLIST_IS_EMPTY( pxDelayedTaskList ) != pdFALSE )
    3880:	e0 91 3f 07 	lds	r30, 0x073F
    3884:	f0 91 40 07 	lds	r31, 0x0740
    3888:	80 81       	ld	r24, Z
    388a:	88 23       	and	r24, r24
    388c:	19 f4       	brne	.+6      	; 0x3894 <xTaskResumeAll+0x15e>
    {
        /* The new current delayed list is empty.  Set xNextTaskUnblockTime to
         * the maximum possible value so it is  extremely unlikely that the
         * if( xTickCount >= xNextTaskUnblockTime ) test will pass until
         * there is an item in the delayed list. */
        xNextTaskUnblockTime = portMAX_DELAY;
    388e:	8f ef       	ldi	r24, 0xFF	; 255
    3890:	9f ef       	ldi	r25, 0xFF	; 255
    3892:	09 c0       	rjmp	.+18     	; 0x38a6 <xTaskResumeAll+0x170>
    {
        /* The new current delayed list is not empty, get the value of
         * the item at the head of the delayed list.  This is the time at
         * which the task at the head of the delayed list should be removed
         * from the Blocked state. */
        xNextTaskUnblockTime = listGET_ITEM_VALUE_OF_HEAD_ENTRY( pxDelayedTaskList );
    3894:	e0 91 3f 07 	lds	r30, 0x073F
    3898:	f0 91 40 07 	lds	r31, 0x0740
    389c:	05 80       	ldd	r0, Z+5	; 0x05
    389e:	f6 81       	ldd	r31, Z+6	; 0x06
    38a0:	e0 2d       	mov	r30, r0
    38a2:	80 81       	ld	r24, Z
    38a4:	91 81       	ldd	r25, Z+1	; 0x01
    38a6:	90 93 ff 06 	sts	0x06FF, r25
    38aa:	80 93 fe 06 	sts	0x06FE, r24
                /* If any ticks occurred while the scheduler was suspended then
                 * they should be processed now.  This ensures the tick count does
                 * not  slip, and that any delayed tasks are resumed at the correct
                 * time. */
                {
                    TickType_t xPendedCounts = xPendedTicks; /* Non-volatile copy. */
    38ae:	c0 91 01 07 	lds	r28, 0x0701
    38b2:	d0 91 02 07 	lds	r29, 0x0702

                    if( xPendedCounts > ( TickType_t ) 0U )
    38b6:	20 97       	sbiw	r28, 0x00	; 0
    38b8:	69 f0       	breq	.+26     	; 0x38d4 <xTaskResumeAll+0x19e>
                    {
                        do
                        {
                            if( xTaskIncrementTick() != pdFALSE )
                            {
                                xYieldPending = pdTRUE;
    38ba:	11 e0       	ldi	r17, 0x01	; 1

                    if( xPendedCounts > ( TickType_t ) 0U )
                    {
                        do
                        {
                            if( xTaskIncrementTick() != pdFALSE )
    38bc:	0e 94 ae 15 	call	0x2b5c	; 0x2b5c <xTaskIncrementTick>
    38c0:	88 23       	and	r24, r24
    38c2:	11 f0       	breq	.+4      	; 0x38c8 <xTaskResumeAll+0x192>
                            {
                                xYieldPending = pdTRUE;
    38c4:	10 93 fb 06 	sts	0x06FB, r17
                            else
                            {
                                mtCOVERAGE_TEST_MARKER();
                            }

                            --xPendedCounts;
    38c8:	21 97       	sbiw	r28, 0x01	; 1
                        } while( xPendedCounts > ( TickType_t ) 0U );
    38ca:	c1 f7       	brne	.-16     	; 0x38bc <xTaskResumeAll+0x186>

                        xPendedTicks = 0;
    38cc:	10 92 02 07 	sts	0x0702, r1
    38d0:	10 92 01 07 	sts	0x0701, r1
                    {
                        mtCOVERAGE_TEST_MARKER();
                    }
                }

                if( xYieldPending != pdFALSE )
    38d4:	80 91 fb 06 	lds	r24, 0x06FB
    38d8:	88 23       	and	r24, r24
    38da:	21 f0       	breq	.+8      	; 0x38e4 <xTaskResumeAll+0x1ae>
                    #if ( configUSE_PREEMPTION != 0 )
                    {
                        xAlreadyYielded = pdTRUE;
                    }
                    #endif
                    taskYIELD_IF_USING_PREEMPTION();
    38dc:	0e 94 64 09 	call	0x12c8	; 0x12c8 <vPortYield>
    38e0:	81 e0       	ldi	r24, 0x01	; 1
    38e2:	01 c0       	rjmp	.+2      	; 0x38e6 <xTaskResumeAll+0x1b0>
    38e4:	80 e0       	ldi	r24, 0x00	; 0
        else
        {
            mtCOVERAGE_TEST_MARKER();
        }
    }
    taskEXIT_CRITICAL();
    38e6:	0f 90       	pop	r0
    38e8:	0f be       	out	0x3f, r0	; 63

    return xAlreadyYielded;
}
    38ea:	df 91       	pop	r29
    38ec:	cf 91       	pop	r28
    38ee:	1f 91       	pop	r17
    38f0:	08 95       	ret

000038f2 <xTaskCatchUpTicks>:
     * do not otherwise exhibit real time behaviour. */
    portSOFTWARE_BARRIER();

    /* The scheduler is suspended if uxSchedulerSuspended is non-zero.  An increment
     * is used to allow calls to vTaskSuspendAll() to nest. */
    ++uxSchedulerSuspended;
    38f2:	20 91 f9 06 	lds	r18, 0x06F9
    38f6:	2f 5f       	subi	r18, 0xFF	; 255
    38f8:	20 93 f9 06 	sts	0x06F9, r18
    /* Use xPendedTicks to mimic xTicksToCatchUp number of ticks occurring when
     * the scheduler is suspended so the ticks are executed in xTaskResumeAll(). */
    vTaskSuspendAll();

    /* Prevent the tick interrupt modifying xPendedTicks simultaneously. */
    taskENTER_CRITICAL();
    38fc:	0f b6       	in	r0, 0x3f	; 63
    38fe:	f8 94       	cli
    3900:	0f 92       	push	r0
    {
        xPendedTicks += xTicksToCatchUp;
    3902:	20 91 01 07 	lds	r18, 0x0701
    3906:	30 91 02 07 	lds	r19, 0x0702
    390a:	28 0f       	add	r18, r24
    390c:	39 1f       	adc	r19, r25
    390e:	30 93 02 07 	sts	0x0702, r19
    3912:	20 93 01 07 	sts	0x0701, r18
    }
    taskEXIT_CRITICAL();
    3916:	0f 90       	pop	r0
    3918:	0f be       	out	0x3f, r0	; 63
    xYieldOccurred = xTaskResumeAll();
    391a:	0e 94 9b 1b 	call	0x3736	; 0x3736 <xTaskResumeAll>

    return xYieldOccurred;
}
    391e:	08 95       	ret

00003920 <vTaskPriorityDisinheritAfterTimeout>:

#if ( configUSE_MUTEXES == 1 )

    void vTaskPriorityDisinheritAfterTimeout( TaskHandle_t const pxMutexHolder,
                                              UBaseType_t uxHighestPriorityWaitingTask )
    {
    3920:	0f 93       	push	r16
    3922:	1f 93       	push	r17
    3924:	cf 93       	push	r28
    3926:	df 93       	push	r29
    3928:	ec 01       	movw	r28, r24
        TCB_t * const pxTCB = pxMutexHolder;
        UBaseType_t uxPriorityUsedOnEntry, uxPriorityToUse;
        const UBaseType_t uxOnlyOneMutexHeld = ( UBaseType_t ) 1;

        if( pxMutexHolder != NULL )
    392a:	00 97       	sbiw	r24, 0x00	; 0
    392c:	09 f4       	brne	.+2      	; 0x3930 <vTaskPriorityDisinheritAfterTimeout+0x10>
    392e:	5b c0       	rjmp	.+182    	; 0x39e6 <vTaskPriorityDisinheritAfterTimeout+0xc6>
    3930:	89 a1       	ldd	r24, Y+33	; 0x21
    3932:	68 17       	cp	r22, r24
    3934:	08 f4       	brcc	.+2      	; 0x3938 <vTaskPriorityDisinheritAfterTimeout+0x18>
    3936:	68 2f       	mov	r22, r24
            {
                uxPriorityToUse = pxTCB->uxBasePriority;
            }

            /* Does the priority need to change? */
            if( pxTCB->uxPriority != uxPriorityToUse )
    3938:	2e 89       	ldd	r18, Y+22	; 0x16
    393a:	26 17       	cp	r18, r22
    393c:	09 f4       	brne	.+2      	; 0x3940 <vTaskPriorityDisinheritAfterTimeout+0x20>
    393e:	53 c0       	rjmp	.+166    	; 0x39e6 <vTaskPriorityDisinheritAfterTimeout+0xc6>
            {
                /* Only disinherit if no other mutexes are held.  This is a
                 * simplification in the priority inheritance implementation.  If
                 * the task that holds the mutex is also holding other mutexes then
                 * the other mutexes may have caused the priority inheritance. */
                if( pxTCB->uxMutexesHeld == uxOnlyOneMutexHeld )
    3940:	8a a1       	ldd	r24, Y+34	; 0x22
    3942:	81 30       	cpi	r24, 0x01	; 1
    3944:	09 f0       	breq	.+2      	; 0x3948 <vTaskPriorityDisinheritAfterTimeout+0x28>
    3946:	4f c0       	rjmp	.+158    	; 0x39e6 <vTaskPriorityDisinheritAfterTimeout+0xc6>
                    /* Disinherit the priority, remembering the previous
                     * priority to facilitate determining the subject task's
                     * state. */
                    traceTASK_PRIORITY_DISINHERIT( pxTCB, uxPriorityToUse );
                    uxPriorityUsedOnEntry = pxTCB->uxPriority;
                    pxTCB->uxPriority = uxPriorityToUse;
    3948:	6e 8b       	std	Y+22, r22	; 0x16

                    /* Only reset the event list item value if the value is not
                     * being used for anything else. */
                    if( ( listGET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ) ) & taskEVENT_LIST_ITEM_VALUE_IN_USE ) == 0UL )
    394a:	8c 85       	ldd	r24, Y+12	; 0x0c
    394c:	9d 85       	ldd	r25, Y+13	; 0x0d
    394e:	97 fd       	sbrc	r25, 7
    3950:	06 c0       	rjmp	.+12     	; 0x395e <vTaskPriorityDisinheritAfterTimeout+0x3e>
                    {
                        listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) uxPriorityToUse ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
    3952:	84 e0       	ldi	r24, 0x04	; 4
    3954:	90 e0       	ldi	r25, 0x00	; 0
    3956:	86 1b       	sub	r24, r22
    3958:	91 09       	sbc	r25, r1
    395a:	9d 87       	std	Y+13, r25	; 0x0d
    395c:	8c 87       	std	Y+12, r24	; 0x0c
                     * then the task that holds the mutex could be in either the
                     * Ready, Blocked or Suspended states.  Only remove the task
                     * from its current state list if it is in the Ready state as
                     * the task's priority is going to change and there is one
                     * Ready list per priority. */
                    if( listIS_CONTAINED_WITHIN( &( pxReadyTasksLists[ uxPriorityUsedOnEntry ] ), &( pxTCB->xStateListItem ) ) != pdFALSE )
    395e:	89 e0       	ldi	r24, 0x09	; 9
    3960:	28 9f       	mul	r18, r24
    3962:	c0 01       	movw	r24, r0
    3964:	11 24       	eor	r1, r1
    3966:	87 5f       	subi	r24, 0xF7	; 247
    3968:	98 4f       	sbci	r25, 0xF8	; 248
    396a:	2a 85       	ldd	r18, Y+10	; 0x0a
    396c:	3b 85       	ldd	r19, Y+11	; 0x0b
    396e:	28 17       	cp	r18, r24
    3970:	39 07       	cpc	r19, r25
    3972:	c9 f5       	brne	.+114    	; 0x39e6 <vTaskPriorityDisinheritAfterTimeout+0xc6>
                    {
                        if( uxListRemove( &( pxTCB->xStateListItem ) ) == ( UBaseType_t ) 0 )
    3974:	8e 01       	movw	r16, r28
    3976:	0e 5f       	subi	r16, 0xFE	; 254
    3978:	1f 4f       	sbci	r17, 0xFF	; 255
    397a:	c8 01       	movw	r24, r16
    397c:	0e 94 5b 08 	call	0x10b6	; 0x10b6 <uxListRemove>
                        else
                        {
                            mtCOVERAGE_TEST_MARKER();
                        }

                        prvAddTaskToReadyList( pxTCB );
    3980:	9e 89       	ldd	r25, Y+22	; 0x16
    3982:	80 91 fa 06 	lds	r24, 0x06FA
    3986:	89 17       	cp	r24, r25
    3988:	10 f4       	brcc	.+4      	; 0x398e <vTaskPriorityDisinheritAfterTimeout+0x6e>
    398a:	90 93 fa 06 	sts	0x06FA, r25
    398e:	89 2f       	mov	r24, r25
    3990:	90 e0       	ldi	r25, 0x00	; 0
    3992:	fc 01       	movw	r30, r24
    3994:	33 e0       	ldi	r19, 0x03	; 3
    3996:	ee 0f       	add	r30, r30
    3998:	ff 1f       	adc	r31, r31
    399a:	3a 95       	dec	r19
    399c:	e1 f7       	brne	.-8      	; 0x3996 <vTaskPriorityDisinheritAfterTimeout+0x76>
    399e:	e8 0f       	add	r30, r24
    39a0:	f9 1f       	adc	r31, r25
    39a2:	e7 5f       	subi	r30, 0xF7	; 247
    39a4:	f8 4f       	sbci	r31, 0xF8	; 248
    39a6:	a1 81       	ldd	r26, Z+1	; 0x01
    39a8:	b2 81       	ldd	r27, Z+2	; 0x02
    39aa:	bd 83       	std	Y+5, r27	; 0x05
    39ac:	ac 83       	std	Y+4, r26	; 0x04
    39ae:	14 96       	adiw	r26, 0x04	; 4
    39b0:	8d 91       	ld	r24, X+
    39b2:	9c 91       	ld	r25, X
    39b4:	15 97       	sbiw	r26, 0x05	; 5
    39b6:	9f 83       	std	Y+7, r25	; 0x07
    39b8:	8e 83       	std	Y+6, r24	; 0x06
    39ba:	14 96       	adiw	r26, 0x04	; 4
    39bc:	ed 91       	ld	r30, X+
    39be:	fc 91       	ld	r31, X
    39c0:	15 97       	sbiw	r26, 0x05	; 5
    39c2:	13 83       	std	Z+3, r17	; 0x03
    39c4:	02 83       	std	Z+2, r16	; 0x02
    39c6:	15 96       	adiw	r26, 0x05	; 5
    39c8:	1c 93       	st	X, r17
    39ca:	0e 93       	st	-X, r16
    39cc:	14 97       	sbiw	r26, 0x04	; 4
    39ce:	ee 89       	ldd	r30, Y+22	; 0x16
    39d0:	89 e0       	ldi	r24, 0x09	; 9
    39d2:	e8 9f       	mul	r30, r24
    39d4:	f0 01       	movw	r30, r0
    39d6:	11 24       	eor	r1, r1
    39d8:	e7 5f       	subi	r30, 0xF7	; 247
    39da:	f8 4f       	sbci	r31, 0xF8	; 248
    39dc:	fb 87       	std	Y+11, r31	; 0x0b
    39de:	ea 87       	std	Y+10, r30	; 0x0a
    39e0:	80 81       	ld	r24, Z
    39e2:	8f 5f       	subi	r24, 0xFF	; 255
    39e4:	80 83       	st	Z, r24
        }
        else
        {
            mtCOVERAGE_TEST_MARKER();
        }
    }
    39e6:	df 91       	pop	r29
    39e8:	cf 91       	pop	r28
    39ea:	1f 91       	pop	r17
    39ec:	0f 91       	pop	r16
    39ee:	08 95       	ret

000039f0 <xTaskPriorityDisinherit>:
/*-----------------------------------------------------------*/

#if ( configUSE_MUTEXES == 1 )

    BaseType_t xTaskPriorityDisinherit( TaskHandle_t const pxMutexHolder )
    {
    39f0:	0f 93       	push	r16
    39f2:	1f 93       	push	r17
    39f4:	cf 93       	push	r28
    39f6:	df 93       	push	r29
    39f8:	ec 01       	movw	r28, r24
        TCB_t * const pxTCB = pxMutexHolder;
        BaseType_t xReturn = pdFALSE;

        if( pxMutexHolder != NULL )
    39fa:	00 97       	sbiw	r24, 0x00	; 0
    39fc:	09 f4       	brne	.+2      	; 0x3a00 <xTaskPriorityDisinherit+0x10>
    39fe:	4d c0       	rjmp	.+154    	; 0x3a9a <xTaskPriorityDisinherit+0xaa>
             * If the mutex is held by a task then it cannot be given from an
             * interrupt, and if a mutex is given by the holding task then it must
             * be the running state task. */
            configASSERT( pxTCB == pxCurrentTCB );
            configASSERT( pxTCB->uxMutexesHeld );
            ( pxTCB->uxMutexesHeld )--;
    3a00:	2a a1       	ldd	r18, Y+34	; 0x22
    3a02:	21 50       	subi	r18, 0x01	; 1
    3a04:	2a a3       	std	Y+34, r18	; 0x22

            /* Has the holder of the mutex inherited the priority of another
             * task? */
            if( pxTCB->uxPriority != pxTCB->uxBasePriority )
    3a06:	9e 89       	ldd	r25, Y+22	; 0x16
    3a08:	89 a1       	ldd	r24, Y+33	; 0x21
    3a0a:	98 17       	cp	r25, r24
    3a0c:	09 f4       	brne	.+2      	; 0x3a10 <xTaskPriorityDisinherit+0x20>
    3a0e:	45 c0       	rjmp	.+138    	; 0x3a9a <xTaskPriorityDisinherit+0xaa>
            {
                /* Only disinherit if no other mutexes are held. */
                if( pxTCB->uxMutexesHeld == ( UBaseType_t ) 0 )
    3a10:	22 23       	and	r18, r18
    3a12:	09 f0       	breq	.+2      	; 0x3a16 <xTaskPriorityDisinherit+0x26>
    3a14:	42 c0       	rjmp	.+132    	; 0x3a9a <xTaskPriorityDisinherit+0xaa>
                    /* A task can only have an inherited priority if it holds
                     * the mutex.  If the mutex is held by a task then it cannot be
                     * given from an interrupt, and if a mutex is given by the
                     * holding task then it must be the running state task.  Remove
                     * the holding task from the ready list. */
                    if( uxListRemove( &( pxTCB->xStateListItem ) ) == ( UBaseType_t ) 0 )
    3a16:	8e 01       	movw	r16, r28
    3a18:	0e 5f       	subi	r16, 0xFE	; 254
    3a1a:	1f 4f       	sbci	r17, 0xFF	; 255
    3a1c:	c8 01       	movw	r24, r16
    3a1e:	0e 94 5b 08 	call	0x10b6	; 0x10b6 <uxListRemove>
                    }

                    /* Disinherit the priority before adding the task into the
                     * new  ready list. */
                    traceTASK_PRIORITY_DISINHERIT( pxTCB, pxTCB->uxBasePriority );
                    pxTCB->uxPriority = pxTCB->uxBasePriority;
    3a22:	29 a1       	ldd	r18, Y+33	; 0x21
    3a24:	2e 8b       	std	Y+22, r18	; 0x16

                    /* Reset the event list item value.  It cannot be in use for
                     * any other purpose if this task is running, and it must be
                     * running to give back the mutex. */
                    listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) pxTCB->uxPriority ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
    3a26:	84 e0       	ldi	r24, 0x04	; 4
    3a28:	90 e0       	ldi	r25, 0x00	; 0
    3a2a:	82 1b       	sub	r24, r18
    3a2c:	91 09       	sbc	r25, r1
    3a2e:	9d 87       	std	Y+13, r25	; 0x0d
    3a30:	8c 87       	std	Y+12, r24	; 0x0c
                    prvAddTaskToReadyList( pxTCB );
    3a32:	80 91 fa 06 	lds	r24, 0x06FA
    3a36:	82 17       	cp	r24, r18
    3a38:	10 f4       	brcc	.+4      	; 0x3a3e <xTaskPriorityDisinherit+0x4e>
    3a3a:	20 93 fa 06 	sts	0x06FA, r18
    3a3e:	82 2f       	mov	r24, r18
    3a40:	90 e0       	ldi	r25, 0x00	; 0
    3a42:	fc 01       	movw	r30, r24
    3a44:	43 e0       	ldi	r20, 0x03	; 3
    3a46:	ee 0f       	add	r30, r30
    3a48:	ff 1f       	adc	r31, r31
    3a4a:	4a 95       	dec	r20
    3a4c:	e1 f7       	brne	.-8      	; 0x3a46 <xTaskPriorityDisinherit+0x56>
    3a4e:	e8 0f       	add	r30, r24
    3a50:	f9 1f       	adc	r31, r25
    3a52:	e7 5f       	subi	r30, 0xF7	; 247
    3a54:	f8 4f       	sbci	r31, 0xF8	; 248
    3a56:	a1 81       	ldd	r26, Z+1	; 0x01
    3a58:	b2 81       	ldd	r27, Z+2	; 0x02
    3a5a:	bd 83       	std	Y+5, r27	; 0x05
    3a5c:	ac 83       	std	Y+4, r26	; 0x04
    3a5e:	14 96       	adiw	r26, 0x04	; 4
    3a60:	8d 91       	ld	r24, X+
    3a62:	9c 91       	ld	r25, X
    3a64:	15 97       	sbiw	r26, 0x05	; 5
    3a66:	9f 83       	std	Y+7, r25	; 0x07
    3a68:	8e 83       	std	Y+6, r24	; 0x06
    3a6a:	14 96       	adiw	r26, 0x04	; 4
    3a6c:	ed 91       	ld	r30, X+
    3a6e:	fc 91       	ld	r31, X
    3a70:	15 97       	sbiw	r26, 0x05	; 5
    3a72:	13 83       	std	Z+3, r17	; 0x03
    3a74:	02 83       	std	Z+2, r16	; 0x02
    3a76:	15 96       	adiw	r26, 0x05	; 5
    3a78:	1c 93       	st	X, r17
    3a7a:	0e 93       	st	-X, r16
    3a7c:	14 97       	sbiw	r26, 0x04	; 4
    3a7e:	ee 89       	ldd	r30, Y+22	; 0x16
    3a80:	89 e0       	ldi	r24, 0x09	; 9
    3a82:	e8 9f       	mul	r30, r24
    3a84:	f0 01       	movw	r30, r0
    3a86:	11 24       	eor	r1, r1
    3a88:	e7 5f       	subi	r30, 0xF7	; 247
    3a8a:	f8 4f       	sbci	r31, 0xF8	; 248
    3a8c:	fb 87       	std	Y+11, r31	; 0x0b
    3a8e:	ea 87       	std	Y+10, r30	; 0x0a
    3a90:	80 81       	ld	r24, Z
    3a92:	8f 5f       	subi	r24, 0xFF	; 255
    3a94:	80 83       	st	Z, r24
    3a96:	81 e0       	ldi	r24, 0x01	; 1
    3a98:	01 c0       	rjmp	.+2      	; 0x3a9c <xTaskPriorityDisinherit+0xac>
    3a9a:	80 e0       	ldi	r24, 0x00	; 0
        {
            mtCOVERAGE_TEST_MARKER();
        }

        return xReturn;
    }
    3a9c:	df 91       	pop	r29
    3a9e:	cf 91       	pop	r28
    3aa0:	1f 91       	pop	r17
    3aa2:	0f 91       	pop	r16
    3aa4:	08 95       	ret

00003aa6 <xTaskPriorityInherit>:
/*-----------------------------------------------------------*/

#if ( configUSE_MUTEXES == 1 )

    BaseType_t xTaskPriorityInherit( TaskHandle_t const pxMutexHolder )
    {
    3aa6:	0f 93       	push	r16
    3aa8:	1f 93       	push	r17
    3aaa:	cf 93       	push	r28
    3aac:	df 93       	push	r29
    3aae:	ec 01       	movw	r28, r24
        BaseType_t xReturn = pdFALSE;

        /* If the mutex was given back by an interrupt while the queue was
         * locked then the mutex holder might now be NULL.  _RB_ Is this still
         * needed as interrupts can no longer use mutexes? */
        if( pxMutexHolder != NULL )
    3ab0:	00 97       	sbiw	r24, 0x00	; 0
    3ab2:	11 f4       	brne	.+4      	; 0x3ab8 <xTaskPriorityInherit+0x12>
    3ab4:	20 e0       	ldi	r18, 0x00	; 0
    3ab6:	75 c0       	rjmp	.+234    	; 0x3ba2 <xTaskPriorityInherit+0xfc>
        {
            /* If the holder of the mutex has a priority below the priority of
             * the task attempting to obtain the mutex then it will temporarily
             * inherit the priority of the task attempting to obtain the mutex. */
            if( pxMutexHolderTCB->uxPriority < pxCurrentTCB->uxPriority )
    3ab8:	e0 91 f7 06 	lds	r30, 0x06F7
    3abc:	f0 91 f8 06 	lds	r31, 0x06F8
    3ac0:	9e 89       	ldd	r25, Y+22	; 0x16
    3ac2:	86 89       	ldd	r24, Z+22	; 0x16
    3ac4:	98 17       	cp	r25, r24
    3ac6:	08 f0       	brcs	.+2      	; 0x3aca <xTaskPriorityInherit+0x24>
    3ac8:	62 c0       	rjmp	.+196    	; 0x3b8e <xTaskPriorityInherit+0xe8>
            {
                /* Adjust the mutex holder state to account for its new
                 * priority.  Only reset the event list item value if the value is
                 * not being used for anything else. */
                if( ( listGET_LIST_ITEM_VALUE( &( pxMutexHolderTCB->xEventListItem ) ) & taskEVENT_LIST_ITEM_VALUE_IN_USE ) == 0UL )
    3aca:	8c 85       	ldd	r24, Y+12	; 0x0c
    3acc:	9d 85       	ldd	r25, Y+13	; 0x0d
    3ace:	97 fd       	sbrc	r25, 7
    3ad0:	0b c0       	rjmp	.+22     	; 0x3ae8 <xTaskPriorityInherit+0x42>
                {
                    listSET_LIST_ITEM_VALUE( &( pxMutexHolderTCB->xEventListItem ), ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) pxCurrentTCB->uxPriority ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
    3ad2:	e0 91 f7 06 	lds	r30, 0x06F7
    3ad6:	f0 91 f8 06 	lds	r31, 0x06F8
    3ada:	26 89       	ldd	r18, Z+22	; 0x16
    3adc:	84 e0       	ldi	r24, 0x04	; 4
    3ade:	90 e0       	ldi	r25, 0x00	; 0
    3ae0:	82 1b       	sub	r24, r18
    3ae2:	91 09       	sbc	r25, r1
    3ae4:	9d 87       	std	Y+13, r25	; 0x0d
    3ae6:	8c 87       	std	Y+12, r24	; 0x0c
                    mtCOVERAGE_TEST_MARKER();
                }

                /* If the task being modified is in the ready state it will need
                 * to be moved into a new list. */
                if( listIS_CONTAINED_WITHIN( &( pxReadyTasksLists[ pxMutexHolderTCB->uxPriority ] ), &( pxMutexHolderTCB->xStateListItem ) ) != pdFALSE )
    3ae8:	8e 89       	ldd	r24, Y+22	; 0x16
    3aea:	29 e0       	ldi	r18, 0x09	; 9
    3aec:	82 9f       	mul	r24, r18
    3aee:	c0 01       	movw	r24, r0
    3af0:	11 24       	eor	r1, r1
    3af2:	87 5f       	subi	r24, 0xF7	; 247
    3af4:	98 4f       	sbci	r25, 0xF8	; 248
    3af6:	2a 85       	ldd	r18, Y+10	; 0x0a
    3af8:	3b 85       	ldd	r19, Y+11	; 0x0b
    3afa:	28 17       	cp	r18, r24
    3afc:	39 07       	cpc	r19, r25
    3afe:	09 f0       	breq	.+2      	; 0x3b02 <xTaskPriorityInherit+0x5c>
    3b00:	3f c0       	rjmp	.+126    	; 0x3b80 <xTaskPriorityInherit+0xda>
                {
                    if( uxListRemove( &( pxMutexHolderTCB->xStateListItem ) ) == ( UBaseType_t ) 0 )
    3b02:	8e 01       	movw	r16, r28
    3b04:	0e 5f       	subi	r16, 0xFE	; 254
    3b06:	1f 4f       	sbci	r17, 0xFF	; 255
    3b08:	c8 01       	movw	r24, r16
    3b0a:	0e 94 5b 08 	call	0x10b6	; 0x10b6 <uxListRemove>
                    {
                        mtCOVERAGE_TEST_MARKER();
                    }

                    /* Inherit the priority before being moved into the new list. */
                    pxMutexHolderTCB->uxPriority = pxCurrentTCB->uxPriority;
    3b0e:	e0 91 f7 06 	lds	r30, 0x06F7
    3b12:	f0 91 f8 06 	lds	r31, 0x06F8
    3b16:	96 89       	ldd	r25, Z+22	; 0x16
    3b18:	9e 8b       	std	Y+22, r25	; 0x16
                    prvAddTaskToReadyList( pxMutexHolderTCB );
    3b1a:	80 91 fa 06 	lds	r24, 0x06FA
    3b1e:	89 17       	cp	r24, r25
    3b20:	10 f4       	brcc	.+4      	; 0x3b26 <xTaskPriorityInherit+0x80>
    3b22:	90 93 fa 06 	sts	0x06FA, r25
    3b26:	89 2f       	mov	r24, r25
    3b28:	90 e0       	ldi	r25, 0x00	; 0
    3b2a:	fc 01       	movw	r30, r24
    3b2c:	53 e0       	ldi	r21, 0x03	; 3
    3b2e:	ee 0f       	add	r30, r30
    3b30:	ff 1f       	adc	r31, r31
    3b32:	5a 95       	dec	r21
    3b34:	e1 f7       	brne	.-8      	; 0x3b2e <xTaskPriorityInherit+0x88>
    3b36:	e8 0f       	add	r30, r24
    3b38:	f9 1f       	adc	r31, r25
    3b3a:	e7 5f       	subi	r30, 0xF7	; 247
    3b3c:	f8 4f       	sbci	r31, 0xF8	; 248
    3b3e:	a1 81       	ldd	r26, Z+1	; 0x01
    3b40:	b2 81       	ldd	r27, Z+2	; 0x02
    3b42:	bd 83       	std	Y+5, r27	; 0x05
    3b44:	ac 83       	std	Y+4, r26	; 0x04
    3b46:	14 96       	adiw	r26, 0x04	; 4
    3b48:	8d 91       	ld	r24, X+
    3b4a:	9c 91       	ld	r25, X
    3b4c:	15 97       	sbiw	r26, 0x05	; 5
    3b4e:	9f 83       	std	Y+7, r25	; 0x07
    3b50:	8e 83       	std	Y+6, r24	; 0x06
    3b52:	14 96       	adiw	r26, 0x04	; 4
    3b54:	ed 91       	ld	r30, X+
    3b56:	fc 91       	ld	r31, X
    3b58:	15 97       	sbiw	r26, 0x05	; 5
    3b5a:	13 83       	std	Z+3, r17	; 0x03
    3b5c:	02 83       	std	Z+2, r16	; 0x02
    3b5e:	15 96       	adiw	r26, 0x05	; 5
    3b60:	1c 93       	st	X, r17
    3b62:	0e 93       	st	-X, r16
    3b64:	14 97       	sbiw	r26, 0x04	; 4
    3b66:	ee 89       	ldd	r30, Y+22	; 0x16
    3b68:	89 e0       	ldi	r24, 0x09	; 9
    3b6a:	e8 9f       	mul	r30, r24
    3b6c:	f0 01       	movw	r30, r0
    3b6e:	11 24       	eor	r1, r1
    3b70:	e7 5f       	subi	r30, 0xF7	; 247
    3b72:	f8 4f       	sbci	r31, 0xF8	; 248
    3b74:	fb 87       	std	Y+11, r31	; 0x0b
    3b76:	ea 87       	std	Y+10, r30	; 0x0a
    3b78:	80 81       	ld	r24, Z
    3b7a:	8f 5f       	subi	r24, 0xFF	; 255
    3b7c:	80 83       	st	Z, r24
    3b7e:	10 c0       	rjmp	.+32     	; 0x3ba0 <xTaskPriorityInherit+0xfa>
                }
                else
                {
                    /* Just inherit the priority. */
                    pxMutexHolderTCB->uxPriority = pxCurrentTCB->uxPriority;
    3b80:	e0 91 f7 06 	lds	r30, 0x06F7
    3b84:	f0 91 f8 06 	lds	r31, 0x06F8
    3b88:	86 89       	ldd	r24, Z+22	; 0x16
    3b8a:	8e 8b       	std	Y+22, r24	; 0x16
    3b8c:	09 c0       	rjmp	.+18     	; 0x3ba0 <xTaskPriorityInherit+0xfa>
                /* Inheritance occurred. */
                xReturn = pdTRUE;
            }
            else
            {
                if( pxMutexHolderTCB->uxBasePriority < pxCurrentTCB->uxPriority )
    3b8e:	e0 91 f7 06 	lds	r30, 0x06F7
    3b92:	f0 91 f8 06 	lds	r31, 0x06F8
    3b96:	20 e0       	ldi	r18, 0x00	; 0
    3b98:	99 a1       	ldd	r25, Y+33	; 0x21
    3b9a:	86 89       	ldd	r24, Z+22	; 0x16
    3b9c:	98 17       	cp	r25, r24
    3b9e:	08 f4       	brcc	.+2      	; 0x3ba2 <xTaskPriorityInherit+0xfc>
    3ba0:	21 e0       	ldi	r18, 0x01	; 1
        {
            mtCOVERAGE_TEST_MARKER();
        }

        return xReturn;
    }
    3ba2:	82 2f       	mov	r24, r18
    3ba4:	df 91       	pop	r29
    3ba6:	cf 91       	pop	r28
    3ba8:	1f 91       	pop	r17
    3baa:	0f 91       	pop	r16
    3bac:	08 95       	ret

00003bae <vTaskResume>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskSuspend == 1 )

    void vTaskResume( TaskHandle_t xTaskToResume )
    {
    3bae:	0f 93       	push	r16
    3bb0:	1f 93       	push	r17
    3bb2:	cf 93       	push	r28
    3bb4:	df 93       	push	r29
    3bb6:	ec 01       	movw	r28, r24
        /* It does not make sense to resume the calling task. */
        configASSERT( xTaskToResume );

        /* The parameter cannot be NULL as it is impossible to resume the
         * currently executing task. */
        if( ( pxTCB != pxCurrentTCB ) && ( pxTCB != NULL ) )
    3bb8:	80 91 f7 06 	lds	r24, 0x06F7
    3bbc:	90 91 f8 06 	lds	r25, 0x06F8
    3bc0:	c8 17       	cp	r28, r24
    3bc2:	d9 07       	cpc	r29, r25
    3bc4:	09 f4       	brne	.+2      	; 0x3bc8 <vTaskResume+0x1a>
    3bc6:	5d c0       	rjmp	.+186    	; 0x3c82 <vTaskResume+0xd4>
    3bc8:	20 97       	sbiw	r28, 0x00	; 0
    3bca:	09 f4       	brne	.+2      	; 0x3bce <vTaskResume+0x20>
    3bcc:	5a c0       	rjmp	.+180    	; 0x3c82 <vTaskResume+0xd4>
        {
            taskENTER_CRITICAL();
    3bce:	0f b6       	in	r0, 0x3f	; 63
    3bd0:	f8 94       	cli
    3bd2:	0f 92       	push	r0

        /* It does not make sense to check if the calling task is suspended. */
        configASSERT( xTask );

        /* Is the task being resumed actually in the suspended list? */
        if( listIS_CONTAINED_WITHIN( &xSuspendedTaskList, &( pxTCB->xStateListItem ) ) != pdFALSE )
    3bd4:	8a 85       	ldd	r24, Y+10	; 0x0a
    3bd6:	9b 85       	ldd	r25, Y+11	; 0x0b
    3bd8:	85 55       	subi	r24, 0x55	; 85
    3bda:	97 40       	sbci	r25, 0x07	; 7
    3bdc:	09 f0       	breq	.+2      	; 0x3be0 <vTaskResume+0x32>
    3bde:	41 c0       	rjmp	.+130    	; 0x3c62 <vTaskResume+0xb4>
        {
            /* Has the task already been resumed from within an ISR? */
            if( listIS_CONTAINED_WITHIN( &xPendingReadyList, &( pxTCB->xEventListItem ) ) == pdFALSE )
    3be0:	8c 89       	ldd	r24, Y+20	; 0x14
    3be2:	9d 89       	ldd	r25, Y+21	; 0x15
    3be4:	27 e0       	ldi	r18, 0x07	; 7
    3be6:	83 34       	cpi	r24, 0x43	; 67
    3be8:	92 07       	cpc	r25, r18
    3bea:	d9 f1       	breq	.+118    	; 0x3c62 <vTaskResume+0xb4>
            {
                /* Is it in the suspended list because it is in the Suspended
                 * state, or because is is blocked with no timeout? */
                if( listIS_CONTAINED_WITHIN( NULL, &( pxTCB->xEventListItem ) ) != pdFALSE ) /*lint !e961.  The cast is only redundant when NULL is used. */
    3bec:	89 2b       	or	r24, r25
    3bee:	c9 f5       	brne	.+114    	; 0x3c62 <vTaskResume+0xb4>
    3bf0:	3b c0       	rjmp	.+118    	; 0x3c68 <vTaskResume+0xba>
                    traceTASK_RESUME( pxTCB );

                    /* The ready list can be accessed even if the scheduler is
                     * suspended because this is inside a critical section. */
                    ( void ) uxListRemove( &( pxTCB->xStateListItem ) );
                    prvAddTaskToReadyList( pxTCB );
    3bf2:	90 93 fa 06 	sts	0x06FA, r25
    3bf6:	89 2f       	mov	r24, r25
    3bf8:	90 e0       	ldi	r25, 0x00	; 0
    3bfa:	fc 01       	movw	r30, r24
    3bfc:	63 e0       	ldi	r22, 0x03	; 3
    3bfe:	ee 0f       	add	r30, r30
    3c00:	ff 1f       	adc	r31, r31
    3c02:	6a 95       	dec	r22
    3c04:	e1 f7       	brne	.-8      	; 0x3bfe <vTaskResume+0x50>
    3c06:	e8 0f       	add	r30, r24
    3c08:	f9 1f       	adc	r31, r25
    3c0a:	e7 5f       	subi	r30, 0xF7	; 247
    3c0c:	f8 4f       	sbci	r31, 0xF8	; 248
    3c0e:	a1 81       	ldd	r26, Z+1	; 0x01
    3c10:	b2 81       	ldd	r27, Z+2	; 0x02
    3c12:	bd 83       	std	Y+5, r27	; 0x05
    3c14:	ac 83       	std	Y+4, r26	; 0x04
    3c16:	14 96       	adiw	r26, 0x04	; 4
    3c18:	8d 91       	ld	r24, X+
    3c1a:	9c 91       	ld	r25, X
    3c1c:	15 97       	sbiw	r26, 0x05	; 5
    3c1e:	9f 83       	std	Y+7, r25	; 0x07
    3c20:	8e 83       	std	Y+6, r24	; 0x06
    3c22:	14 96       	adiw	r26, 0x04	; 4
    3c24:	ed 91       	ld	r30, X+
    3c26:	fc 91       	ld	r31, X
    3c28:	15 97       	sbiw	r26, 0x05	; 5
    3c2a:	13 83       	std	Z+3, r17	; 0x03
    3c2c:	02 83       	std	Z+2, r16	; 0x02
    3c2e:	15 96       	adiw	r26, 0x05	; 5
    3c30:	1c 93       	st	X, r17
    3c32:	0e 93       	st	-X, r16
    3c34:	14 97       	sbiw	r26, 0x04	; 4
    3c36:	ee 89       	ldd	r30, Y+22	; 0x16
    3c38:	89 e0       	ldi	r24, 0x09	; 9
    3c3a:	e8 9f       	mul	r30, r24
    3c3c:	f0 01       	movw	r30, r0
    3c3e:	11 24       	eor	r1, r1
    3c40:	e7 5f       	subi	r30, 0xF7	; 247
    3c42:	f8 4f       	sbci	r31, 0xF8	; 248
    3c44:	fb 87       	std	Y+11, r31	; 0x0b
    3c46:	ea 87       	std	Y+10, r30	; 0x0a
    3c48:	80 81       	ld	r24, Z
    3c4a:	8f 5f       	subi	r24, 0xFF	; 255
    3c4c:	80 83       	st	Z, r24

                    /* A higher priority task may have just been resumed. */
                    if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
    3c4e:	e0 91 f7 06 	lds	r30, 0x06F7
    3c52:	f0 91 f8 06 	lds	r31, 0x06F8
    3c56:	9e 89       	ldd	r25, Y+22	; 0x16
    3c58:	86 89       	ldd	r24, Z+22	; 0x16
    3c5a:	98 17       	cp	r25, r24
    3c5c:	10 f0       	brcs	.+4      	; 0x3c62 <vTaskResume+0xb4>
                    {
                        /* This yield may not cause the task just resumed to run,
                         * but will leave the lists in the correct state for the
                         * next yield. */
                        taskYIELD_IF_USING_PREEMPTION();
    3c5e:	0e 94 64 09 	call	0x12c8	; 0x12c8 <vPortYield>
                else
                {
                    mtCOVERAGE_TEST_MARKER();
                }
            }
            taskEXIT_CRITICAL();
    3c62:	0f 90       	pop	r0
    3c64:	0f be       	out	0x3f, r0	; 63
    3c66:	0d c0       	rjmp	.+26     	; 0x3c82 <vTaskResume+0xd4>
                {
                    traceTASK_RESUME( pxTCB );

                    /* The ready list can be accessed even if the scheduler is
                     * suspended because this is inside a critical section. */
                    ( void ) uxListRemove( &( pxTCB->xStateListItem ) );
    3c68:	8e 01       	movw	r16, r28
    3c6a:	0e 5f       	subi	r16, 0xFE	; 254
    3c6c:	1f 4f       	sbci	r17, 0xFF	; 255
    3c6e:	c8 01       	movw	r24, r16
    3c70:	0e 94 5b 08 	call	0x10b6	; 0x10b6 <uxListRemove>
                    prvAddTaskToReadyList( pxTCB );
    3c74:	9e 89       	ldd	r25, Y+22	; 0x16
    3c76:	80 91 fa 06 	lds	r24, 0x06FA
    3c7a:	89 17       	cp	r24, r25
    3c7c:	08 f4       	brcc	.+2      	; 0x3c80 <vTaskResume+0xd2>
    3c7e:	b9 cf       	rjmp	.-142    	; 0x3bf2 <vTaskResume+0x44>
    3c80:	ba cf       	rjmp	.-140    	; 0x3bf6 <vTaskResume+0x48>
        }
        else
        {
            mtCOVERAGE_TEST_MARKER();
        }
    }
    3c82:	df 91       	pop	r29
    3c84:	cf 91       	pop	r28
    3c86:	1f 91       	pop	r17
    3c88:	0f 91       	pop	r16
    3c8a:	08 95       	ret

00003c8c <prvAddCurrentTaskToDelayedList>:
#endif /* if ( ( configGENERATE_RUN_TIME_STATS == 1 ) && ( INCLUDE_xTaskGetIdleTaskHandle == 1 ) ) */
/*-----------------------------------------------------------*/

static void prvAddCurrentTaskToDelayedList( TickType_t xTicksToWait,
                                            const BaseType_t xCanBlockIndefinitely )
{
    3c8c:	ff 92       	push	r15
    3c8e:	0f 93       	push	r16
    3c90:	1f 93       	push	r17
    3c92:	cf 93       	push	r28
    3c94:	df 93       	push	r29
    3c96:	ec 01       	movw	r28, r24
    3c98:	f6 2e       	mov	r15, r22
    TickType_t xTimeToWake;
    const TickType_t xConstTickCount = xTickCount;
    3c9a:	00 91 fc 06 	lds	r16, 0x06FC
    3c9e:	10 91 fd 06 	lds	r17, 0x06FD
    }
    #endif

    /* Remove the task from the ready list before adding it to the blocked list
     * as the same list item is used for both lists. */
    if( uxListRemove( &( pxCurrentTCB->xStateListItem ) ) == ( UBaseType_t ) 0 )
    3ca2:	80 91 f7 06 	lds	r24, 0x06F7
    3ca6:	90 91 f8 06 	lds	r25, 0x06F8
    3caa:	02 96       	adiw	r24, 0x02	; 2
    3cac:	0e 94 5b 08 	call	0x10b6	; 0x10b6 <uxListRemove>
        mtCOVERAGE_TEST_MARKER();
    }

    #if ( INCLUDE_vTaskSuspend == 1 )
    {
        if( ( xTicksToWait == portMAX_DELAY ) && ( xCanBlockIndefinitely != pdFALSE ) )
    3cb0:	8f ef       	ldi	r24, 0xFF	; 255
    3cb2:	cf 3f       	cpi	r28, 0xFF	; 255
    3cb4:	d8 07       	cpc	r29, r24
    3cb6:	c1 f5       	brne	.+112    	; 0x3d28 <prvAddCurrentTaskToDelayedList+0x9c>
    3cb8:	ff 20       	and	r15, r15
    3cba:	b1 f1       	breq	.+108    	; 0x3d28 <prvAddCurrentTaskToDelayedList+0x9c>
        {
            /* Add the task to the suspended task list instead of a delayed task
             * list to ensure it is not woken by a timing event.  It will block
             * indefinitely. */
            listINSERT_END( &xSuspendedTaskList, &( pxCurrentTCB->xStateListItem ) );
    3cbc:	a0 91 56 07 	lds	r26, 0x0756
    3cc0:	b0 91 57 07 	lds	r27, 0x0757
    3cc4:	e0 91 f7 06 	lds	r30, 0x06F7
    3cc8:	f0 91 f8 06 	lds	r31, 0x06F8
    3ccc:	b5 83       	std	Z+5, r27	; 0x05
    3cce:	a4 83       	std	Z+4, r26	; 0x04
    3cd0:	e0 91 f7 06 	lds	r30, 0x06F7
    3cd4:	f0 91 f8 06 	lds	r31, 0x06F8
    3cd8:	14 96       	adiw	r26, 0x04	; 4
    3cda:	8d 91       	ld	r24, X+
    3cdc:	9c 91       	ld	r25, X
    3cde:	15 97       	sbiw	r26, 0x05	; 5
    3ce0:	97 83       	std	Z+7, r25	; 0x07
    3ce2:	86 83       	std	Z+6, r24	; 0x06
    3ce4:	80 91 f7 06 	lds	r24, 0x06F7
    3ce8:	90 91 f8 06 	lds	r25, 0x06F8
    3cec:	14 96       	adiw	r26, 0x04	; 4
    3cee:	ed 91       	ld	r30, X+
    3cf0:	fc 91       	ld	r31, X
    3cf2:	15 97       	sbiw	r26, 0x05	; 5
    3cf4:	02 96       	adiw	r24, 0x02	; 2
    3cf6:	93 83       	std	Z+3, r25	; 0x03
    3cf8:	82 83       	std	Z+2, r24	; 0x02
    3cfa:	80 91 f7 06 	lds	r24, 0x06F7
    3cfe:	90 91 f8 06 	lds	r25, 0x06F8
    3d02:	02 96       	adiw	r24, 0x02	; 2
    3d04:	15 96       	adiw	r26, 0x05	; 5
    3d06:	9c 93       	st	X, r25
    3d08:	8e 93       	st	-X, r24
    3d0a:	14 97       	sbiw	r26, 0x04	; 4
    3d0c:	e0 91 f7 06 	lds	r30, 0x06F7
    3d10:	f0 91 f8 06 	lds	r31, 0x06F8
    3d14:	85 e5       	ldi	r24, 0x55	; 85
    3d16:	97 e0       	ldi	r25, 0x07	; 7
    3d18:	93 87       	std	Z+11, r25	; 0x0b
    3d1a:	82 87       	std	Z+10, r24	; 0x0a
    3d1c:	80 91 55 07 	lds	r24, 0x0755
    3d20:	8f 5f       	subi	r24, 0xFF	; 255
    3d22:	80 93 55 07 	sts	0x0755, r24
    3d26:	2f c0       	rjmp	.+94     	; 0x3d86 <prvAddCurrentTaskToDelayedList+0xfa>
        else
        {
            /* Calculate the time at which the task should be woken if the event
             * does not occur.  This may overflow but this doesn't matter, the
             * kernel will manage it correctly. */
            xTimeToWake = xConstTickCount + xTicksToWait;
    3d28:	c0 0f       	add	r28, r16
    3d2a:	d1 1f       	adc	r29, r17

            /* The list item will be inserted in wake time order. */
            listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xStateListItem ), xTimeToWake );
    3d2c:	e0 91 f7 06 	lds	r30, 0x06F7
    3d30:	f0 91 f8 06 	lds	r31, 0x06F8
    3d34:	d3 83       	std	Z+3, r29	; 0x03
    3d36:	c2 83       	std	Z+2, r28	; 0x02

            if( xTimeToWake < xConstTickCount )
    3d38:	c0 17       	cp	r28, r16
    3d3a:	d1 07       	cpc	r29, r17
    3d3c:	68 f4       	brcc	.+26     	; 0x3d58 <prvAddCurrentTaskToDelayedList+0xcc>
            {
                /* Wake time has overflowed.  Place this item in the overflow
                 * list. */
                vListInsert( pxOverflowDelayedTaskList, &( pxCurrentTCB->xStateListItem ) );
    3d3e:	80 91 41 07 	lds	r24, 0x0741
    3d42:	90 91 42 07 	lds	r25, 0x0742
    3d46:	60 91 f7 06 	lds	r22, 0x06F7
    3d4a:	70 91 f8 06 	lds	r23, 0x06F8
    3d4e:	6e 5f       	subi	r22, 0xFE	; 254
    3d50:	7f 4f       	sbci	r23, 0xFF	; 255
    3d52:	0e 94 29 08 	call	0x1052	; 0x1052 <vListInsert>
    3d56:	17 c0       	rjmp	.+46     	; 0x3d86 <prvAddCurrentTaskToDelayedList+0xfa>
            }
            else
            {
                /* The wake time has not overflowed, so the current block list
                 * is used. */
                vListInsert( pxDelayedTaskList, &( pxCurrentTCB->xStateListItem ) );
    3d58:	80 91 3f 07 	lds	r24, 0x073F
    3d5c:	90 91 40 07 	lds	r25, 0x0740
    3d60:	60 91 f7 06 	lds	r22, 0x06F7
    3d64:	70 91 f8 06 	lds	r23, 0x06F8
    3d68:	6e 5f       	subi	r22, 0xFE	; 254
    3d6a:	7f 4f       	sbci	r23, 0xFF	; 255
    3d6c:	0e 94 29 08 	call	0x1052	; 0x1052 <vListInsert>

                /* If the task entering the blocked state was placed at the
                 * head of the list of blocked tasks then xNextTaskUnblockTime
                 * needs to be updated too. */
                if( xTimeToWake < xNextTaskUnblockTime )
    3d70:	80 91 fe 06 	lds	r24, 0x06FE
    3d74:	90 91 ff 06 	lds	r25, 0x06FF
    3d78:	c8 17       	cp	r28, r24
    3d7a:	d9 07       	cpc	r29, r25
    3d7c:	20 f4       	brcc	.+8      	; 0x3d86 <prvAddCurrentTaskToDelayedList+0xfa>
                {
                    xNextTaskUnblockTime = xTimeToWake;
    3d7e:	d0 93 ff 06 	sts	0x06FF, r29
    3d82:	c0 93 fe 06 	sts	0x06FE, r28

        /* Avoid compiler warning when INCLUDE_vTaskSuspend is not 1. */
        ( void ) xCanBlockIndefinitely;
    }
    #endif /* INCLUDE_vTaskSuspend */
}
    3d86:	df 91       	pop	r29
    3d88:	cf 91       	pop	r28
    3d8a:	1f 91       	pop	r17
    3d8c:	0f 91       	pop	r16
    3d8e:	ff 90       	pop	r15
    3d90:	08 95       	ret

00003d92 <xTaskGenericNotifyWait>:
    BaseType_t xTaskGenericNotifyWait( UBaseType_t uxIndexToWait,
                                       uint32_t ulBitsToClearOnEntry,
                                       uint32_t ulBitsToClearOnExit,
                                       uint32_t * pulNotificationValue,
                                       TickType_t xTicksToWait )
    {
    3d92:	8f 92       	push	r8
    3d94:	9f 92       	push	r9
    3d96:	af 92       	push	r10
    3d98:	bf 92       	push	r11
    3d9a:	cf 92       	push	r12
    3d9c:	df 92       	push	r13
    3d9e:	ef 92       	push	r14
    3da0:	ff 92       	push	r15
    3da2:	0f 93       	push	r16
    3da4:	1f 93       	push	r17
    3da6:	cf 93       	push	r28
    3da8:	df 93       	push	r29
    3daa:	48 01       	movw	r8, r16
    3dac:	59 01       	movw	r10, r18
    3dae:	e7 01       	movw	r28, r14
        BaseType_t xReturn;

        configASSERT( uxIndexToWait < configTASK_NOTIFICATION_ARRAY_ENTRIES );

        taskENTER_CRITICAL();
    3db0:	0f b6       	in	r0, 0x3f	; 63
    3db2:	f8 94       	cli
    3db4:	0f 92       	push	r0
        {
            /* Only block if a notification is not already pending. */
            if( pxCurrentTCB->ucNotifyState[ uxIndexToWait ] != taskNOTIFICATION_RECEIVED )
    3db6:	e0 91 f7 06 	lds	r30, 0x06F7
    3dba:	f0 91 f8 06 	lds	r31, 0x06F8
    3dbe:	e8 2e       	mov	r14, r24
    3dc0:	ff 24       	eor	r15, r15
    3dc2:	ee 0d       	add	r30, r14
    3dc4:	ff 1d       	adc	r31, r15
    3dc6:	87 a1       	ldd	r24, Z+39	; 0x27
    3dc8:	82 30       	cpi	r24, 0x02	; 2
    3dca:	61 f1       	breq	.+88     	; 0x3e24 <xTaskGenericNotifyWait+0x92>
            {
                /* Clear bits in the task's notification value as bits may get
                 * set  by the notifying task or interrupt.  This can be used to
                 * clear the value to zero. */
                pxCurrentTCB->ulNotifiedValue[ uxIndexToWait ] &= ~ulBitsToClearOnEntry;
    3dcc:	e0 91 f7 06 	lds	r30, 0x06F7
    3dd0:	f0 91 f8 06 	lds	r31, 0x06F8
    3dd4:	c7 01       	movw	r24, r14
    3dd6:	88 0f       	add	r24, r24
    3dd8:	99 1f       	adc	r25, r25
    3dda:	88 0f       	add	r24, r24
    3ddc:	99 1f       	adc	r25, r25
    3dde:	e8 0f       	add	r30, r24
    3de0:	f9 1f       	adc	r31, r25
    3de2:	83 a1       	ldd	r24, Z+35	; 0x23
    3de4:	94 a1       	ldd	r25, Z+36	; 0x24
    3de6:	a5 a1       	ldd	r26, Z+37	; 0x25
    3de8:	b6 a1       	ldd	r27, Z+38	; 0x26
    3dea:	40 95       	com	r20
    3dec:	50 95       	com	r21
    3dee:	60 95       	com	r22
    3df0:	70 95       	com	r23
    3df2:	84 23       	and	r24, r20
    3df4:	95 23       	and	r25, r21
    3df6:	a6 23       	and	r26, r22
    3df8:	b7 23       	and	r27, r23
    3dfa:	83 a3       	std	Z+35, r24	; 0x23
    3dfc:	94 a3       	std	Z+36, r25	; 0x24
    3dfe:	a5 a3       	std	Z+37, r26	; 0x25
    3e00:	b6 a3       	std	Z+38, r27	; 0x26

                /* Mark this task as waiting for a notification. */
                pxCurrentTCB->ucNotifyState[ uxIndexToWait ] = taskWAITING_NOTIFICATION;
    3e02:	e0 91 f7 06 	lds	r30, 0x06F7
    3e06:	f0 91 f8 06 	lds	r31, 0x06F8
    3e0a:	ee 0d       	add	r30, r14
    3e0c:	ff 1d       	adc	r31, r15
    3e0e:	81 e0       	ldi	r24, 0x01	; 1
    3e10:	87 a3       	std	Z+39, r24	; 0x27

                if( xTicksToWait > ( TickType_t ) 0 )
    3e12:	c1 14       	cp	r12, r1
    3e14:	d1 04       	cpc	r13, r1
    3e16:	31 f0       	breq	.+12     	; 0x3e24 <xTaskGenericNotifyWait+0x92>
                {
                    prvAddCurrentTaskToDelayedList( xTicksToWait, pdTRUE );
    3e18:	c6 01       	movw	r24, r12
    3e1a:	61 e0       	ldi	r22, 0x01	; 1
    3e1c:	0e 94 46 1e 	call	0x3c8c	; 0x3c8c <prvAddCurrentTaskToDelayedList>

                    /* All ports are written to allow a yield in a critical
                     * section (some will yield immediately, others wait until the
                     * critical section exits) - but it is not something that
                     * application code should ever do. */
                    portYIELD_WITHIN_API();
    3e20:	0e 94 64 09 	call	0x12c8	; 0x12c8 <vPortYield>
            else
            {
                mtCOVERAGE_TEST_MARKER();
            }
        }
        taskEXIT_CRITICAL();
    3e24:	0f 90       	pop	r0
    3e26:	0f be       	out	0x3f, r0	; 63

        taskENTER_CRITICAL();
    3e28:	0f b6       	in	r0, 0x3f	; 63
    3e2a:	f8 94       	cli
    3e2c:	0f 92       	push	r0
        {
            traceTASK_NOTIFY_WAIT( uxIndexToWait );

            if( pulNotificationValue != NULL )
    3e2e:	20 97       	sbiw	r28, 0x00	; 0
    3e30:	99 f0       	breq	.+38     	; 0x3e58 <xTaskGenericNotifyWait+0xc6>
            {
                /* Output the current notification value, which may or may not
                 * have changed. */
                *pulNotificationValue = pxCurrentTCB->ulNotifiedValue[ uxIndexToWait ];
    3e32:	e0 91 f7 06 	lds	r30, 0x06F7
    3e36:	f0 91 f8 06 	lds	r31, 0x06F8
    3e3a:	c7 01       	movw	r24, r14
    3e3c:	88 0f       	add	r24, r24
    3e3e:	99 1f       	adc	r25, r25
    3e40:	88 0f       	add	r24, r24
    3e42:	99 1f       	adc	r25, r25
    3e44:	e8 0f       	add	r30, r24
    3e46:	f9 1f       	adc	r31, r25
    3e48:	83 a1       	ldd	r24, Z+35	; 0x23
    3e4a:	94 a1       	ldd	r25, Z+36	; 0x24
    3e4c:	a5 a1       	ldd	r26, Z+37	; 0x25
    3e4e:	b6 a1       	ldd	r27, Z+38	; 0x26
    3e50:	88 83       	st	Y, r24
    3e52:	99 83       	std	Y+1, r25	; 0x01
    3e54:	aa 83       	std	Y+2, r26	; 0x02
    3e56:	bb 83       	std	Y+3, r27	; 0x03

            /* If ucNotifyValue is set then either the task never entered the
             * blocked state (because a notification was already pending) or the
             * task unblocked because of a notification.  Otherwise the task
             * unblocked because of a timeout. */
            if( pxCurrentTCB->ucNotifyState[ uxIndexToWait ] != taskNOTIFICATION_RECEIVED )
    3e58:	e0 91 f7 06 	lds	r30, 0x06F7
    3e5c:	f0 91 f8 06 	lds	r31, 0x06F8
    3e60:	ee 0d       	add	r30, r14
    3e62:	ff 1d       	adc	r31, r15
    3e64:	87 a1       	ldd	r24, Z+39	; 0x27
    3e66:	82 30       	cpi	r24, 0x02	; 2
    3e68:	11 f0       	breq	.+4      	; 0x3e6e <xTaskGenericNotifyWait+0xdc>
    3e6a:	80 e0       	ldi	r24, 0x00	; 0
    3e6c:	1c c0       	rjmp	.+56     	; 0x3ea6 <xTaskGenericNotifyWait+0x114>
            }
            else
            {
                /* A notification was already pending or a notification was
                 * received while the task was waiting. */
                pxCurrentTCB->ulNotifiedValue[ uxIndexToWait ] &= ~ulBitsToClearOnExit;
    3e6e:	e0 91 f7 06 	lds	r30, 0x06F7
    3e72:	f0 91 f8 06 	lds	r31, 0x06F8
    3e76:	c7 01       	movw	r24, r14
    3e78:	88 0f       	add	r24, r24
    3e7a:	99 1f       	adc	r25, r25
    3e7c:	88 0f       	add	r24, r24
    3e7e:	99 1f       	adc	r25, r25
    3e80:	e8 0f       	add	r30, r24
    3e82:	f9 1f       	adc	r31, r25
    3e84:	83 a1       	ldd	r24, Z+35	; 0x23
    3e86:	94 a1       	ldd	r25, Z+36	; 0x24
    3e88:	a5 a1       	ldd	r26, Z+37	; 0x25
    3e8a:	b6 a1       	ldd	r27, Z+38	; 0x26
    3e8c:	80 94       	com	r8
    3e8e:	90 94       	com	r9
    3e90:	a0 94       	com	r10
    3e92:	b0 94       	com	r11
    3e94:	88 21       	and	r24, r8
    3e96:	99 21       	and	r25, r9
    3e98:	aa 21       	and	r26, r10
    3e9a:	bb 21       	and	r27, r11
    3e9c:	83 a3       	std	Z+35, r24	; 0x23
    3e9e:	94 a3       	std	Z+36, r25	; 0x24
    3ea0:	a5 a3       	std	Z+37, r26	; 0x25
    3ea2:	b6 a3       	std	Z+38, r27	; 0x26
    3ea4:	81 e0       	ldi	r24, 0x01	; 1
                xReturn = pdTRUE;
            }

            pxCurrentTCB->ucNotifyState[ uxIndexToWait ] = taskNOT_WAITING_NOTIFICATION;
    3ea6:	e0 91 f7 06 	lds	r30, 0x06F7
    3eaa:	f0 91 f8 06 	lds	r31, 0x06F8
    3eae:	ee 0d       	add	r30, r14
    3eb0:	ff 1d       	adc	r31, r15
    3eb2:	17 a2       	std	Z+39, r1	; 0x27
        }
        taskEXIT_CRITICAL();
    3eb4:	0f 90       	pop	r0
    3eb6:	0f be       	out	0x3f, r0	; 63

        return xReturn;
    }
    3eb8:	df 91       	pop	r29
    3eba:	cf 91       	pop	r28
    3ebc:	1f 91       	pop	r17
    3ebe:	0f 91       	pop	r16
    3ec0:	ff 90       	pop	r15
    3ec2:	ef 90       	pop	r14
    3ec4:	df 90       	pop	r13
    3ec6:	cf 90       	pop	r12
    3ec8:	bf 90       	pop	r11
    3eca:	af 90       	pop	r10
    3ecc:	9f 90       	pop	r9
    3ece:	8f 90       	pop	r8
    3ed0:	08 95       	ret

00003ed2 <ulTaskGenericNotifyTake>:
#if ( configUSE_TASK_NOTIFICATIONS == 1 )

    uint32_t ulTaskGenericNotifyTake( UBaseType_t uxIndexToWait,
                                      BaseType_t xClearCountOnExit,
                                      TickType_t xTicksToWait )
    {
    3ed2:	1f 93       	push	r17
    3ed4:	cf 93       	push	r28
    3ed6:	df 93       	push	r29
    3ed8:	16 2f       	mov	r17, r22
        uint32_t ulReturn;

        configASSERT( uxIndexToWait < configTASK_NOTIFICATION_ARRAY_ENTRIES );

        taskENTER_CRITICAL();
    3eda:	0f b6       	in	r0, 0x3f	; 63
    3edc:	f8 94       	cli
    3ede:	0f 92       	push	r0
        {
            /* Only block if the notification count is not already non-zero. */
            if( pxCurrentTCB->ulNotifiedValue[ uxIndexToWait ] == 0UL )
    3ee0:	e0 91 f7 06 	lds	r30, 0x06F7
    3ee4:	f0 91 f8 06 	lds	r31, 0x06F8
    3ee8:	c8 2f       	mov	r28, r24
    3eea:	d0 e0       	ldi	r29, 0x00	; 0
    3eec:	ce 01       	movw	r24, r28
    3eee:	88 0f       	add	r24, r24
    3ef0:	99 1f       	adc	r25, r25
    3ef2:	88 0f       	add	r24, r24
    3ef4:	99 1f       	adc	r25, r25
    3ef6:	e8 0f       	add	r30, r24
    3ef8:	f9 1f       	adc	r31, r25
    3efa:	83 a1       	ldd	r24, Z+35	; 0x23
    3efc:	94 a1       	ldd	r25, Z+36	; 0x24
    3efe:	a5 a1       	ldd	r26, Z+37	; 0x25
    3f00:	b6 a1       	ldd	r27, Z+38	; 0x26
    3f02:	00 97       	sbiw	r24, 0x00	; 0
    3f04:	a1 05       	cpc	r26, r1
    3f06:	b1 05       	cpc	r27, r1
    3f08:	89 f4       	brne	.+34     	; 0x3f2c <ulTaskGenericNotifyTake+0x5a>
            {
                /* Mark this task as waiting for a notification. */
                pxCurrentTCB->ucNotifyState[ uxIndexToWait ] = taskWAITING_NOTIFICATION;
    3f0a:	e0 91 f7 06 	lds	r30, 0x06F7
    3f0e:	f0 91 f8 06 	lds	r31, 0x06F8
    3f12:	ec 0f       	add	r30, r28
    3f14:	fd 1f       	adc	r31, r29
    3f16:	81 e0       	ldi	r24, 0x01	; 1
    3f18:	87 a3       	std	Z+39, r24	; 0x27

                if( xTicksToWait > ( TickType_t ) 0 )
    3f1a:	41 15       	cp	r20, r1
    3f1c:	51 05       	cpc	r21, r1
    3f1e:	31 f0       	breq	.+12     	; 0x3f2c <ulTaskGenericNotifyTake+0x5a>
                {
                    prvAddCurrentTaskToDelayedList( xTicksToWait, pdTRUE );
    3f20:	ca 01       	movw	r24, r20
    3f22:	61 e0       	ldi	r22, 0x01	; 1
    3f24:	0e 94 46 1e 	call	0x3c8c	; 0x3c8c <prvAddCurrentTaskToDelayedList>

                    /* All ports are written to allow a yield in a critical
                     * section (some will yield immediately, others wait until the
                     * critical section exits) - but it is not something that
                     * application code should ever do. */
                    portYIELD_WITHIN_API();
    3f28:	0e 94 64 09 	call	0x12c8	; 0x12c8 <vPortYield>
            else
            {
                mtCOVERAGE_TEST_MARKER();
            }
        }
        taskEXIT_CRITICAL();
    3f2c:	0f 90       	pop	r0
    3f2e:	0f be       	out	0x3f, r0	; 63

        taskENTER_CRITICAL();
    3f30:	0f b6       	in	r0, 0x3f	; 63
    3f32:	f8 94       	cli
    3f34:	0f 92       	push	r0
        {
            traceTASK_NOTIFY_TAKE( uxIndexToWait );
            ulReturn = pxCurrentTCB->ulNotifiedValue[ uxIndexToWait ];
    3f36:	e0 91 f7 06 	lds	r30, 0x06F7
    3f3a:	f0 91 f8 06 	lds	r31, 0x06F8
    3f3e:	ce 01       	movw	r24, r28
    3f40:	88 0f       	add	r24, r24
    3f42:	99 1f       	adc	r25, r25
    3f44:	88 0f       	add	r24, r24
    3f46:	99 1f       	adc	r25, r25
    3f48:	e8 0f       	add	r30, r24
    3f4a:	f9 1f       	adc	r31, r25
    3f4c:	23 a1       	ldd	r18, Z+35	; 0x23
    3f4e:	34 a1       	ldd	r19, Z+36	; 0x24
    3f50:	45 a1       	ldd	r20, Z+37	; 0x25
    3f52:	56 a1       	ldd	r21, Z+38	; 0x26

            if( ulReturn != 0UL )
    3f54:	21 15       	cp	r18, r1
    3f56:	31 05       	cpc	r19, r1
    3f58:	41 05       	cpc	r20, r1
    3f5a:	51 05       	cpc	r21, r1
    3f5c:	f9 f0       	breq	.+62     	; 0x3f9c <ulTaskGenericNotifyTake+0xca>
            {
                if( xClearCountOnExit != pdFALSE )
    3f5e:	11 23       	and	r17, r17
    3f60:	59 f0       	breq	.+22     	; 0x3f78 <ulTaskGenericNotifyTake+0xa6>
                {
                    pxCurrentTCB->ulNotifiedValue[ uxIndexToWait ] = 0UL;
    3f62:	e0 91 f7 06 	lds	r30, 0x06F7
    3f66:	f0 91 f8 06 	lds	r31, 0x06F8
    3f6a:	e8 0f       	add	r30, r24
    3f6c:	f9 1f       	adc	r31, r25
    3f6e:	13 a2       	std	Z+35, r1	; 0x23
    3f70:	14 a2       	std	Z+36, r1	; 0x24
    3f72:	15 a2       	std	Z+37, r1	; 0x25
    3f74:	16 a2       	std	Z+38, r1	; 0x26
    3f76:	12 c0       	rjmp	.+36     	; 0x3f9c <ulTaskGenericNotifyTake+0xca>
                }
                else
                {
                    pxCurrentTCB->ulNotifiedValue[ uxIndexToWait ] = ulReturn - ( uint32_t ) 1;
    3f78:	e0 91 f7 06 	lds	r30, 0x06F7
    3f7c:	f0 91 f8 06 	lds	r31, 0x06F8
    3f80:	21 50       	subi	r18, 0x01	; 1
    3f82:	30 40       	sbci	r19, 0x00	; 0
    3f84:	40 40       	sbci	r20, 0x00	; 0
    3f86:	50 40       	sbci	r21, 0x00	; 0
    3f88:	e8 0f       	add	r30, r24
    3f8a:	f9 1f       	adc	r31, r25
    3f8c:	23 a3       	std	Z+35, r18	; 0x23
    3f8e:	34 a3       	std	Z+36, r19	; 0x24
    3f90:	45 a3       	std	Z+37, r20	; 0x25
    3f92:	56 a3       	std	Z+38, r21	; 0x26
    3f94:	2f 5f       	subi	r18, 0xFF	; 255
    3f96:	3f 4f       	sbci	r19, 0xFF	; 255
    3f98:	4f 4f       	sbci	r20, 0xFF	; 255
    3f9a:	5f 4f       	sbci	r21, 0xFF	; 255
            else
            {
                mtCOVERAGE_TEST_MARKER();
            }

            pxCurrentTCB->ucNotifyState[ uxIndexToWait ] = taskNOT_WAITING_NOTIFICATION;
    3f9c:	e0 91 f7 06 	lds	r30, 0x06F7
    3fa0:	f0 91 f8 06 	lds	r31, 0x06F8
    3fa4:	ec 0f       	add	r30, r28
    3fa6:	fd 1f       	adc	r31, r29
    3fa8:	17 a2       	std	Z+39, r1	; 0x27
        }
        taskEXIT_CRITICAL();
    3faa:	0f 90       	pop	r0
    3fac:	0f be       	out	0x3f, r0	; 63

        return ulReturn;
    }
    3fae:	b9 01       	movw	r22, r18
    3fb0:	ca 01       	movw	r24, r20
    3fb2:	df 91       	pop	r29
    3fb4:	cf 91       	pop	r28
    3fb6:	1f 91       	pop	r17
    3fb8:	08 95       	ret

00003fba <vTaskPlaceOnUnorderedEventList>:
/*-----------------------------------------------------------*/

void vTaskPlaceOnUnorderedEventList( List_t * pxEventList,
                                     const TickType_t xItemValue,
                                     const TickType_t xTicksToWait )
{
    3fba:	0f 93       	push	r16
    3fbc:	1f 93       	push	r17
    3fbe:	8c 01       	movw	r16, r24
    3fc0:	ca 01       	movw	r24, r20
    configASSERT( uxSchedulerSuspended != 0 );

    /* Store the item value in the event list item.  It is safe to access the
     * event list item here as interrupts won't access the event list item of a
     * task that is not in the Blocked state. */
    listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xEventListItem ), xItemValue | taskEVENT_LIST_ITEM_VALUE_IN_USE );
    3fc2:	e0 91 f7 06 	lds	r30, 0x06F7
    3fc6:	f0 91 f8 06 	lds	r31, 0x06F8
    3fca:	70 68       	ori	r23, 0x80	; 128
    3fcc:	75 87       	std	Z+13, r23	; 0x0d
    3fce:	64 87       	std	Z+12, r22	; 0x0c
    /* Place the event list item of the TCB at the end of the appropriate event
     * list.  It is safe to access the event list here because it is part of an
     * event group implementation - and interrupts don't access event groups
     * directly (instead they access them indirectly by pending function calls to
     * the task level). */
    listINSERT_END( pxEventList, &( pxCurrentTCB->xEventListItem ) );
    3fd0:	f8 01       	movw	r30, r16
    3fd2:	a1 81       	ldd	r26, Z+1	; 0x01
    3fd4:	b2 81       	ldd	r27, Z+2	; 0x02
    3fd6:	e0 91 f7 06 	lds	r30, 0x06F7
    3fda:	f0 91 f8 06 	lds	r31, 0x06F8
    3fde:	b7 87       	std	Z+15, r27	; 0x0f
    3fe0:	a6 87       	std	Z+14, r26	; 0x0e
    3fe2:	e0 91 f7 06 	lds	r30, 0x06F7
    3fe6:	f0 91 f8 06 	lds	r31, 0x06F8
    3fea:	14 96       	adiw	r26, 0x04	; 4
    3fec:	2d 91       	ld	r18, X+
    3fee:	3c 91       	ld	r19, X
    3ff0:	15 97       	sbiw	r26, 0x05	; 5
    3ff2:	31 8b       	std	Z+17, r19	; 0x11
    3ff4:	20 8b       	std	Z+16, r18	; 0x10
    3ff6:	20 91 f7 06 	lds	r18, 0x06F7
    3ffa:	30 91 f8 06 	lds	r19, 0x06F8
    3ffe:	14 96       	adiw	r26, 0x04	; 4
    4000:	ed 91       	ld	r30, X+
    4002:	fc 91       	ld	r31, X
    4004:	15 97       	sbiw	r26, 0x05	; 5
    4006:	24 5f       	subi	r18, 0xF4	; 244
    4008:	3f 4f       	sbci	r19, 0xFF	; 255
    400a:	33 83       	std	Z+3, r19	; 0x03
    400c:	22 83       	std	Z+2, r18	; 0x02
    400e:	20 91 f7 06 	lds	r18, 0x06F7
    4012:	30 91 f8 06 	lds	r19, 0x06F8
    4016:	24 5f       	subi	r18, 0xF4	; 244
    4018:	3f 4f       	sbci	r19, 0xFF	; 255
    401a:	15 96       	adiw	r26, 0x05	; 5
    401c:	3c 93       	st	X, r19
    401e:	2e 93       	st	-X, r18
    4020:	14 97       	sbiw	r26, 0x04	; 4
    4022:	e0 91 f7 06 	lds	r30, 0x06F7
    4026:	f0 91 f8 06 	lds	r31, 0x06F8
    402a:	15 8b       	std	Z+21, r17	; 0x15
    402c:	04 8b       	std	Z+20, r16	; 0x14
    402e:	f8 01       	movw	r30, r16
    4030:	20 81       	ld	r18, Z
    4032:	2f 5f       	subi	r18, 0xFF	; 255
    4034:	20 83       	st	Z, r18

    prvAddCurrentTaskToDelayedList( xTicksToWait, pdTRUE );
    4036:	61 e0       	ldi	r22, 0x01	; 1
    4038:	0e 94 46 1e 	call	0x3c8c	; 0x3c8c <prvAddCurrentTaskToDelayedList>
}
    403c:	1f 91       	pop	r17
    403e:	0f 91       	pop	r16
    4040:	08 95       	ret

00004042 <vTaskDelay>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelay == 1 )

    void vTaskDelay( const TickType_t xTicksToDelay )
    {
    4042:	9c 01       	movw	r18, r24
        BaseType_t xAlreadyYielded = pdFALSE;

        /* A delay time of zero just forces a reschedule. */
        if( xTicksToDelay > ( TickType_t ) 0U )
    4044:	00 97       	sbiw	r24, 0x00	; 0
    4046:	69 f0       	breq	.+26     	; 0x4062 <vTaskDelay+0x20>
     * do not otherwise exhibit real time behaviour. */
    portSOFTWARE_BARRIER();

    /* The scheduler is suspended if uxSchedulerSuspended is non-zero.  An increment
     * is used to allow calls to vTaskSuspendAll() to nest. */
    ++uxSchedulerSuspended;
    4048:	80 91 f9 06 	lds	r24, 0x06F9
    404c:	8f 5f       	subi	r24, 0xFF	; 255
    404e:	80 93 f9 06 	sts	0x06F9, r24
                 * list or removed from the blocked list until the scheduler
                 * is resumed.
                 *
                 * This task cannot be in an event list as it is the currently
                 * executing task. */
                prvAddCurrentTaskToDelayedList( xTicksToDelay, pdFALSE );
    4052:	c9 01       	movw	r24, r18
    4054:	60 e0       	ldi	r22, 0x00	; 0
    4056:	0e 94 46 1e 	call	0x3c8c	; 0x3c8c <prvAddCurrentTaskToDelayedList>
            }
            xAlreadyYielded = xTaskResumeAll();
    405a:	0e 94 9b 1b 	call	0x3736	; 0x3736 <xTaskResumeAll>
            mtCOVERAGE_TEST_MARKER();
        }

        /* Force a reschedule if xTaskResumeAll has not already done so, we may
         * have put ourselves to sleep. */
        if( xAlreadyYielded == pdFALSE )
    405e:	88 23       	and	r24, r24
    4060:	11 f4       	brne	.+4      	; 0x4066 <vTaskDelay+0x24>
        {
            portYIELD_WITHIN_API();
    4062:	0e 94 64 09 	call	0x12c8	; 0x12c8 <vPortYield>
    4066:	08 95       	ret

00004068 <vTaskPlaceOnEventList>:
}
/*-----------------------------------------------------------*/

void vTaskPlaceOnEventList( List_t * const pxEventList,
                            const TickType_t xTicksToWait )
{
    4068:	0f 93       	push	r16
    406a:	1f 93       	push	r17
    406c:	8b 01       	movw	r16, r22
     *      xItemValue = ( configMAX_PRIORITIES - uxPriority )
     * Therefore, the event list is sorted in descending priority order.
     *
     * The queue that contains the event list is locked, preventing
     * simultaneous access from interrupts. */
    vListInsert( pxEventList, &( pxCurrentTCB->xEventListItem ) );
    406e:	60 91 f7 06 	lds	r22, 0x06F7
    4072:	70 91 f8 06 	lds	r23, 0x06F8
    4076:	64 5f       	subi	r22, 0xF4	; 244
    4078:	7f 4f       	sbci	r23, 0xFF	; 255
    407a:	0e 94 29 08 	call	0x1052	; 0x1052 <vListInsert>

    prvAddCurrentTaskToDelayedList( xTicksToWait, pdTRUE );
    407e:	c8 01       	movw	r24, r16
    4080:	61 e0       	ldi	r22, 0x01	; 1
    4082:	0e 94 46 1e 	call	0x3c8c	; 0x3c8c <prvAddCurrentTaskToDelayedList>
}
    4086:	1f 91       	pop	r17
    4088:	0f 91       	pop	r16
    408a:	08 95       	ret

0000408c <vTaskEndScheduler>:
void vTaskEndScheduler( void )
{
    /* Stop the scheduler interrupts and call the portable scheduler end
     * routine so the original ISRs can be restored if necessary.  The port
     * layer must ensure interrupts enable  bit is left in the correct state. */
    portDISABLE_INTERRUPTS();
    408c:	f8 94       	cli
    xSchedulerRunning = pdFALSE;
    408e:	10 92 04 07 	sts	0x0704, r1
    vPortEndScheduler();
    4092:	0e 94 03 09 	call	0x1206	; 0x1206 <vPortEndScheduler>
}
    4096:	08 95       	ret

00004098 <prvIdleTask>:
 *
 * void prvIdleTask( void *pvParameters );
 *
 */
static portTASK_FUNCTION( prvIdleTask, pvParameters )
{
    4098:	0f 93       	push	r16
    409a:	1f 93       	push	r17
    409c:	21 c0       	rjmp	.+66     	; 0x40e0 <prvIdleTask+0x48>

        /* uxDeletedTasksWaitingCleanUp is used to prevent taskENTER_CRITICAL()
         * being called too often in the idle task. */
        while( uxDeletedTasksWaitingCleanUp > ( UBaseType_t ) 0U )
        {
            taskENTER_CRITICAL();
    409e:	0f b6       	in	r0, 0x3f	; 63
    40a0:	f8 94       	cli
    40a2:	0f 92       	push	r0
            {
                pxTCB = listGET_OWNER_OF_HEAD_ENTRY( ( &xTasksWaitingTermination ) ); /*lint !e9079 void * is used as this macro is used with timers and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
    40a4:	e0 91 51 07 	lds	r30, 0x0751
    40a8:	f0 91 52 07 	lds	r31, 0x0752
    40ac:	06 81       	ldd	r16, Z+6	; 0x06
    40ae:	17 81       	ldd	r17, Z+7	; 0x07
                ( void ) uxListRemove( &( pxTCB->xStateListItem ) );
    40b0:	c8 01       	movw	r24, r16
    40b2:	02 96       	adiw	r24, 0x02	; 2
    40b4:	0e 94 5b 08 	call	0x10b6	; 0x10b6 <uxListRemove>
                --uxCurrentNumberOfTasks;
    40b8:	80 91 03 07 	lds	r24, 0x0703
    40bc:	81 50       	subi	r24, 0x01	; 1
    40be:	80 93 03 07 	sts	0x0703, r24
                --uxDeletedTasksWaitingCleanUp;
    40c2:	80 91 07 07 	lds	r24, 0x0707
    40c6:	81 50       	subi	r24, 0x01	; 1
    40c8:	80 93 07 07 	sts	0x0707, r24
            }
            taskEXIT_CRITICAL();
    40cc:	0f 90       	pop	r0
    40ce:	0f be       	out	0x3f, r0	; 63

        #if ( ( configSUPPORT_DYNAMIC_ALLOCATION == 1 ) && ( configSUPPORT_STATIC_ALLOCATION == 0 ) && ( portUSING_MPU_WRAPPERS == 0 ) )
        {
            /* The task can only have been allocated dynamically - free both
             * the stack and TCB. */
            vPortFreeStack( pxTCB->pxStack );
    40d0:	f8 01       	movw	r30, r16
    40d2:	87 89       	ldd	r24, Z+23	; 0x17
    40d4:	90 8d       	ldd	r25, Z+24	; 0x18
    40d6:	0e 94 b2 07 	call	0xf64	; 0xf64 <vPortFree>
            vPortFree( pxTCB );
    40da:	c8 01       	movw	r24, r16
    40dc:	0e 94 b2 07 	call	0xf64	; 0xf64 <vPortFree>
    {
        TCB_t * pxTCB;

        /* uxDeletedTasksWaitingCleanUp is used to prevent taskENTER_CRITICAL()
         * being called too often in the idle task. */
        while( uxDeletedTasksWaitingCleanUp > ( UBaseType_t ) 0U )
    40e0:	80 91 07 07 	lds	r24, 0x0707
    40e4:	88 23       	and	r24, r24
    40e6:	d9 f6       	brne	.-74     	; 0x409e <prvIdleTask+0x6>
             *
             * A critical region is not required here as we are just reading from
             * the list, and an occasional incorrect value will not matter.  If
             * the ready list at the idle priority contains more than one task
             * then a task other than the idle task is ready to execute. */
            if( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ tskIDLE_PRIORITY ] ) ) > ( UBaseType_t ) 1 )
    40e8:	80 91 09 07 	lds	r24, 0x0709
    40ec:	82 30       	cpi	r24, 0x02	; 2
    40ee:	c0 f3       	brcs	.-16     	; 0x40e0 <prvIdleTask+0x48>
            {
                taskYIELD();
    40f0:	0e 94 64 09 	call	0x12c8	; 0x12c8 <vPortYield>
    40f4:	f5 cf       	rjmp	.-22     	; 0x40e0 <prvIdleTask+0x48>

000040f6 <xTaskResumeFromISR>:
/*-----------------------------------------------------------*/

#if ( ( INCLUDE_xTaskResumeFromISR == 1 ) && ( INCLUDE_vTaskSuspend == 1 ) )

    BaseType_t xTaskResumeFromISR( TaskHandle_t xTaskToResume )
    {
    40f6:	ff 92       	push	r15
    40f8:	0f 93       	push	r16
    40fa:	1f 93       	push	r17
    40fc:	cf 93       	push	r28
    40fe:	df 93       	push	r29
    4100:	ec 01       	movw	r28, r24

        /* It does not make sense to check if the calling task is suspended. */
        configASSERT( xTask );

        /* Is the task being resumed actually in the suspended list? */
        if( listIS_CONTAINED_WITHIN( &xSuspendedTaskList, &( pxTCB->xStateListItem ) ) != pdFALSE )
    4102:	8a 85       	ldd	r24, Y+10	; 0x0a
    4104:	9b 85       	ldd	r25, Y+11	; 0x0b
    4106:	85 55       	subi	r24, 0x55	; 85
    4108:	97 40       	sbci	r25, 0x07	; 7
    410a:	09 f0       	breq	.+2      	; 0x410e <xTaskResumeFromISR+0x18>
    410c:	5a c0       	rjmp	.+180    	; 0x41c2 <xTaskResumeFromISR+0xcc>
        {
            /* Has the task already been resumed from within an ISR? */
            if( listIS_CONTAINED_WITHIN( &xPendingReadyList, &( pxTCB->xEventListItem ) ) == pdFALSE )
    410e:	8c 89       	ldd	r24, Y+20	; 0x14
    4110:	9d 89       	ldd	r25, Y+21	; 0x15
    4112:	27 e0       	ldi	r18, 0x07	; 7
    4114:	83 34       	cpi	r24, 0x43	; 67
    4116:	92 07       	cpc	r25, r18
    4118:	09 f4       	brne	.+2      	; 0x411c <xTaskResumeFromISR+0x26>
    411a:	53 c0       	rjmp	.+166    	; 0x41c2 <xTaskResumeFromISR+0xcc>
            {
                /* Is it in the suspended list because it is in the Suspended
                 * state, or because is is blocked with no timeout? */
                if( listIS_CONTAINED_WITHIN( NULL, &( pxTCB->xEventListItem ) ) != pdFALSE ) /*lint !e961.  The cast is only redundant when NULL is used. */
    411c:	89 2b       	or	r24, r25
    411e:	09 f0       	breq	.+2      	; 0x4122 <xTaskResumeFromISR+0x2c>
    4120:	50 c0       	rjmp	.+160    	; 0x41c2 <xTaskResumeFromISR+0xcc>
    4122:	57 c0       	rjmp	.+174    	; 0x41d2 <xTaskResumeFromISR+0xdc>
                /* Check the ready lists can be accessed. */
                if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
                {
                    /* Ready lists can be accessed so move the task from the
                     * suspended list to the ready list directly. */
                    if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
    4124:	e0 91 f7 06 	lds	r30, 0x06F7
    4128:	f0 91 f8 06 	lds	r31, 0x06F8
    412c:	9e 89       	ldd	r25, Y+22	; 0x16
    412e:	86 89       	ldd	r24, Z+22	; 0x16
    4130:	98 17       	cp	r25, r24
    4132:	10 f4       	brcc	.+4      	; 0x4138 <xTaskResumeFromISR+0x42>
    4134:	ff 24       	eor	r15, r15
    4136:	05 c0       	rjmp	.+10     	; 0x4142 <xTaskResumeFromISR+0x4c>
                        xYieldRequired = pdTRUE;

                        /* Mark that a yield is pending in case the user is not
                         * using the return value to initiate a context switch
                         * from the ISR using portYIELD_FROM_ISR. */
                        xYieldPending = pdTRUE;
    4138:	81 e0       	ldi	r24, 0x01	; 1
    413a:	80 93 fb 06 	sts	0x06FB, r24
    413e:	ff 24       	eor	r15, r15
    4140:	f3 94       	inc	r15
                    else
                    {
                        mtCOVERAGE_TEST_MARKER();
                    }

                    ( void ) uxListRemove( &( pxTCB->xStateListItem ) );
    4142:	8e 01       	movw	r16, r28
    4144:	0e 5f       	subi	r16, 0xFE	; 254
    4146:	1f 4f       	sbci	r17, 0xFF	; 255
    4148:	c8 01       	movw	r24, r16
    414a:	0e 94 5b 08 	call	0x10b6	; 0x10b6 <uxListRemove>
                    prvAddTaskToReadyList( pxTCB );
    414e:	9e 89       	ldd	r25, Y+22	; 0x16
    4150:	80 91 fa 06 	lds	r24, 0x06FA
    4154:	89 17       	cp	r24, r25
    4156:	10 f4       	brcc	.+4      	; 0x415c <xTaskResumeFromISR+0x66>
    4158:	90 93 fa 06 	sts	0x06FA, r25
    415c:	89 2f       	mov	r24, r25
    415e:	90 e0       	ldi	r25, 0x00	; 0
    4160:	fc 01       	movw	r30, r24
    4162:	43 e0       	ldi	r20, 0x03	; 3
    4164:	ee 0f       	add	r30, r30
    4166:	ff 1f       	adc	r31, r31
    4168:	4a 95       	dec	r20
    416a:	e1 f7       	brne	.-8      	; 0x4164 <xTaskResumeFromISR+0x6e>
    416c:	e8 0f       	add	r30, r24
    416e:	f9 1f       	adc	r31, r25
    4170:	e7 5f       	subi	r30, 0xF7	; 247
    4172:	f8 4f       	sbci	r31, 0xF8	; 248
    4174:	a1 81       	ldd	r26, Z+1	; 0x01
    4176:	b2 81       	ldd	r27, Z+2	; 0x02
    4178:	bd 83       	std	Y+5, r27	; 0x05
    417a:	ac 83       	std	Y+4, r26	; 0x04
    417c:	14 96       	adiw	r26, 0x04	; 4
    417e:	8d 91       	ld	r24, X+
    4180:	9c 91       	ld	r25, X
    4182:	15 97       	sbiw	r26, 0x05	; 5
    4184:	9f 83       	std	Y+7, r25	; 0x07
    4186:	8e 83       	std	Y+6, r24	; 0x06
    4188:	14 96       	adiw	r26, 0x04	; 4
    418a:	ed 91       	ld	r30, X+
    418c:	fc 91       	ld	r31, X
    418e:	15 97       	sbiw	r26, 0x05	; 5
    4190:	13 83       	std	Z+3, r17	; 0x03
    4192:	02 83       	std	Z+2, r16	; 0x02
    4194:	15 96       	adiw	r26, 0x05	; 5
    4196:	1c 93       	st	X, r17
    4198:	0e 93       	st	-X, r16
    419a:	14 97       	sbiw	r26, 0x04	; 4
    419c:	ee 89       	ldd	r30, Y+22	; 0x16
    419e:	89 e0       	ldi	r24, 0x09	; 9
    41a0:	e8 9f       	mul	r30, r24
    41a2:	f0 01       	movw	r30, r0
    41a4:	11 24       	eor	r1, r1
    41a6:	e7 5f       	subi	r30, 0xF7	; 247
    41a8:	f8 4f       	sbci	r31, 0xF8	; 248
    41aa:	fb 87       	std	Y+11, r31	; 0x0b
    41ac:	ea 87       	std	Y+10, r30	; 0x0a
    41ae:	80 81       	ld	r24, Z
    41b0:	8f 5f       	subi	r24, 0xFF	; 255
    41b2:	80 83       	st	Z, r24
    41b4:	07 c0       	rjmp	.+14     	; 0x41c4 <xTaskResumeFromISR+0xce>
                else
                {
                    /* The delayed or ready lists cannot be accessed so the task
                     * is held in the pending ready list until the scheduler is
                     * unsuspended. */
                    vListInsertEnd( &( xPendingReadyList ), &( pxTCB->xEventListItem ) );
    41b6:	2c 96       	adiw	r28, 0x0c	; 12
    41b8:	83 e4       	ldi	r24, 0x43	; 67
    41ba:	97 e0       	ldi	r25, 0x07	; 7
    41bc:	be 01       	movw	r22, r28
    41be:	0e 94 0a 08 	call	0x1014	; 0x1014 <vListInsertEnd>
    41c2:	ff 24       	eor	r15, r15
            }
        }
        portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

        return xYieldRequired;
    }
    41c4:	8f 2d       	mov	r24, r15
    41c6:	df 91       	pop	r29
    41c8:	cf 91       	pop	r28
    41ca:	1f 91       	pop	r17
    41cc:	0f 91       	pop	r16
    41ce:	ff 90       	pop	r15
    41d0:	08 95       	ret
            if( prvTaskIsTaskSuspended( pxTCB ) != pdFALSE )
            {
                traceTASK_RESUME_FROM_ISR( pxTCB );

                /* Check the ready lists can be accessed. */
                if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
    41d2:	80 91 f9 06 	lds	r24, 0x06F9
    41d6:	88 23       	and	r24, r24
    41d8:	09 f4       	brne	.+2      	; 0x41dc <xTaskResumeFromISR+0xe6>
    41da:	a4 cf       	rjmp	.-184    	; 0x4124 <xTaskResumeFromISR+0x2e>
    41dc:	ec cf       	rjmp	.-40     	; 0x41b6 <xTaskResumeFromISR+0xc0>

000041de <vTaskSuspend>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskSuspend == 1 )

    void vTaskSuspend( TaskHandle_t xTaskToSuspend )
    {
    41de:	0f 93       	push	r16
    41e0:	1f 93       	push	r17
    41e2:	cf 93       	push	r28
    41e4:	df 93       	push	r29
        TCB_t * pxTCB;

        taskENTER_CRITICAL();
    41e6:	0f b6       	in	r0, 0x3f	; 63
    41e8:	f8 94       	cli
    41ea:	0f 92       	push	r0
        {
            /* If null is passed in here then it is the running task that is
             * being suspended. */
            pxTCB = prvGetTCBFromHandle( xTaskToSuspend );
    41ec:	00 97       	sbiw	r24, 0x00	; 0
    41ee:	11 f0       	breq	.+4      	; 0x41f4 <vTaskSuspend+0x16>
    41f0:	ec 01       	movw	r28, r24
    41f2:	04 c0       	rjmp	.+8      	; 0x41fc <vTaskSuspend+0x1e>
    41f4:	c0 91 f7 06 	lds	r28, 0x06F7
    41f8:	d0 91 f8 06 	lds	r29, 0x06F8

            traceTASK_SUSPEND( pxTCB );

            /* Remove task from the ready/delayed list and place in the
             * suspended list. */
            if( uxListRemove( &( pxTCB->xStateListItem ) ) == ( UBaseType_t ) 0 )
    41fc:	8e 01       	movw	r16, r28
    41fe:	0e 5f       	subi	r16, 0xFE	; 254
    4200:	1f 4f       	sbci	r17, 0xFF	; 255
    4202:	c8 01       	movw	r24, r16
    4204:	0e 94 5b 08 	call	0x10b6	; 0x10b6 <uxListRemove>
            {
                mtCOVERAGE_TEST_MARKER();
            }

            /* Is the task waiting on an event also? */
            if( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) != NULL )
    4208:	8c 89       	ldd	r24, Y+20	; 0x14
    420a:	9d 89       	ldd	r25, Y+21	; 0x15
    420c:	89 2b       	or	r24, r25
    420e:	21 f0       	breq	.+8      	; 0x4218 <vTaskSuspend+0x3a>
            {
                ( void ) uxListRemove( &( pxTCB->xEventListItem ) );
    4210:	ce 01       	movw	r24, r28
    4212:	0c 96       	adiw	r24, 0x0c	; 12
    4214:	0e 94 5b 08 	call	0x10b6	; 0x10b6 <uxListRemove>
            else
            {
                mtCOVERAGE_TEST_MARKER();
            }

            vListInsertEnd( &xSuspendedTaskList, &( pxTCB->xStateListItem ) );
    4218:	85 e5       	ldi	r24, 0x55	; 85
    421a:	97 e0       	ldi	r25, 0x07	; 7
    421c:	b8 01       	movw	r22, r16
    421e:	0e 94 0a 08 	call	0x1014	; 0x1014 <vListInsertEnd>
            {
                BaseType_t x;

                for( x = 0; x < configTASK_NOTIFICATION_ARRAY_ENTRIES; x++ )
                {
                    if( pxTCB->ucNotifyState[ x ] == taskWAITING_NOTIFICATION )
    4222:	8f a1       	ldd	r24, Y+39	; 0x27
    4224:	81 30       	cpi	r24, 0x01	; 1
    4226:	09 f4       	brne	.+2      	; 0x422a <vTaskSuspend+0x4c>
                    {
                        /* The task was blocked to wait for a notification, but is
                         * now suspended, so no notification was received. */
                        pxTCB->ucNotifyState[ x ] = taskNOT_WAITING_NOTIFICATION;
    4228:	1f a2       	std	Y+39, r1	; 0x27
                    }
                }
            }
            #endif /* if ( configUSE_TASK_NOTIFICATIONS == 1 ) */
        }
        taskEXIT_CRITICAL();
    422a:	0f 90       	pop	r0
    422c:	0f be       	out	0x3f, r0	; 63

        if( xSchedulerRunning != pdFALSE )
    422e:	80 91 04 07 	lds	r24, 0x0704
    4232:	88 23       	and	r24, r24
    4234:	e1 f0       	breq	.+56     	; 0x426e <vTaskSuspend+0x90>
        {
            /* Reset the next expected unblock time in case it referred to the
             * task that is now in the Suspended state. */
            taskENTER_CRITICAL();
    4236:	0f b6       	in	r0, 0x3f	; 63
    4238:	f8 94       	cli
    423a:	0f 92       	push	r0
#endif /* INCLUDE_vTaskDelete */
/*-----------------------------------------------------------*/

static void prvResetNextTaskUnblockTime( void )
{
    if( listLIST_IS_EMPTY( pxDelayedTaskList ) != pdFALSE )
    423c:	e0 91 3f 07 	lds	r30, 0x073F
    4240:	f0 91 40 07 	lds	r31, 0x0740
    4244:	80 81       	ld	r24, Z
    4246:	88 23       	and	r24, r24
    4248:	19 f4       	brne	.+6      	; 0x4250 <vTaskSuspend+0x72>
    {
        /* The new current delayed list is empty.  Set xNextTaskUnblockTime to
         * the maximum possible value so it is  extremely unlikely that the
         * if( xTickCount >= xNextTaskUnblockTime ) test will pass until
         * there is an item in the delayed list. */
        xNextTaskUnblockTime = portMAX_DELAY;
    424a:	8f ef       	ldi	r24, 0xFF	; 255
    424c:	9f ef       	ldi	r25, 0xFF	; 255
    424e:	09 c0       	rjmp	.+18     	; 0x4262 <vTaskSuspend+0x84>
    {
        /* The new current delayed list is not empty, get the value of
         * the item at the head of the delayed list.  This is the time at
         * which the task at the head of the delayed list should be removed
         * from the Blocked state. */
        xNextTaskUnblockTime = listGET_ITEM_VALUE_OF_HEAD_ENTRY( pxDelayedTaskList );
    4250:	e0 91 3f 07 	lds	r30, 0x073F
    4254:	f0 91 40 07 	lds	r31, 0x0740
    4258:	05 80       	ldd	r0, Z+5	; 0x05
    425a:	f6 81       	ldd	r31, Z+6	; 0x06
    425c:	e0 2d       	mov	r30, r0
    425e:	80 81       	ld	r24, Z
    4260:	91 81       	ldd	r25, Z+1	; 0x01
    4262:	90 93 ff 06 	sts	0x06FF, r25
    4266:	80 93 fe 06 	sts	0x06FE, r24
             * task that is now in the Suspended state. */
            taskENTER_CRITICAL();
            {
                prvResetNextTaskUnblockTime();
            }
            taskEXIT_CRITICAL();
    426a:	0f 90       	pop	r0
    426c:	0f be       	out	0x3f, r0	; 63
        else
        {
            mtCOVERAGE_TEST_MARKER();
        }

        if( pxTCB == pxCurrentTCB )
    426e:	80 91 f7 06 	lds	r24, 0x06F7
    4272:	90 91 f8 06 	lds	r25, 0x06F8
    4276:	c8 17       	cp	r28, r24
    4278:	d9 07       	cpc	r29, r25
    427a:	a1 f4       	brne	.+40     	; 0x42a4 <vTaskSuspend+0xc6>
        {
            if( xSchedulerRunning != pdFALSE )
    427c:	80 91 04 07 	lds	r24, 0x0704
    4280:	88 23       	and	r24, r24
    4282:	19 f0       	breq	.+6      	; 0x428a <vTaskSuspend+0xac>
            {
                /* The current task has just been suspended. */
                configASSERT( uxSchedulerSuspended == 0 );
                portYIELD_WITHIN_API();
    4284:	0e 94 64 09 	call	0x12c8	; 0x12c8 <vPortYield>
    4288:	0d c0       	rjmp	.+26     	; 0x42a4 <vTaskSuspend+0xc6>
            else
            {
                /* The scheduler is not running, but the task that was pointed
                 * to by pxCurrentTCB has just been suspended and pxCurrentTCB
                 * must be adjusted to point to a different task. */
                if( listCURRENT_LIST_LENGTH( &xSuspendedTaskList ) == uxCurrentNumberOfTasks ) /*lint !e931 Right has no side effect, just volatile. */
    428a:	90 91 55 07 	lds	r25, 0x0755
    428e:	80 91 03 07 	lds	r24, 0x0703
    4292:	98 17       	cp	r25, r24
    4294:	29 f4       	brne	.+10     	; 0x42a0 <vTaskSuspend+0xc2>
                {
                    /* No other tasks are ready, so set pxCurrentTCB back to
                     * NULL so when the next task is created pxCurrentTCB will
                     * be set to point to it no matter what its relative priority
                     * is. */
                    pxCurrentTCB = NULL;
    4296:	10 92 f8 06 	sts	0x06F8, r1
    429a:	10 92 f7 06 	sts	0x06F7, r1
    429e:	02 c0       	rjmp	.+4      	; 0x42a4 <vTaskSuspend+0xc6>
                }
                else
                {
                    vTaskSwitchContext();
    42a0:	0e 94 c6 16 	call	0x2d8c	; 0x2d8c <vTaskSwitchContext>
        }
        else
        {
            mtCOVERAGE_TEST_MARKER();
        }
    }
    42a4:	df 91       	pop	r29
    42a6:	cf 91       	pop	r28
    42a8:	1f 91       	pop	r17
    42aa:	0f 91       	pop	r16
    42ac:	08 95       	ret

000042ae <vTaskDelete>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelete == 1 )

    void vTaskDelete( TaskHandle_t xTaskToDelete )
    {
    42ae:	0f 93       	push	r16
    42b0:	1f 93       	push	r17
    42b2:	cf 93       	push	r28
    42b4:	df 93       	push	r29
        TCB_t * pxTCB;

        taskENTER_CRITICAL();
    42b6:	0f b6       	in	r0, 0x3f	; 63
    42b8:	f8 94       	cli
    42ba:	0f 92       	push	r0
        {
            /* If null is passed in here then it is the calling task that is
             * being deleted. */
            pxTCB = prvGetTCBFromHandle( xTaskToDelete );
    42bc:	00 97       	sbiw	r24, 0x00	; 0
    42be:	11 f0       	breq	.+4      	; 0x42c4 <vTaskDelete+0x16>
    42c0:	ec 01       	movw	r28, r24
    42c2:	04 c0       	rjmp	.+8      	; 0x42cc <vTaskDelete+0x1e>
    42c4:	c0 91 f7 06 	lds	r28, 0x06F7
    42c8:	d0 91 f8 06 	lds	r29, 0x06F8

            /* Remove task from the ready/delayed list. */
            if( uxListRemove( &( pxTCB->xStateListItem ) ) == ( UBaseType_t ) 0 )
    42cc:	8e 01       	movw	r16, r28
    42ce:	0e 5f       	subi	r16, 0xFE	; 254
    42d0:	1f 4f       	sbci	r17, 0xFF	; 255
    42d2:	c8 01       	movw	r24, r16
    42d4:	0e 94 5b 08 	call	0x10b6	; 0x10b6 <uxListRemove>
            {
                mtCOVERAGE_TEST_MARKER();
            }

            /* Is the task waiting on an event also? */
            if( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) != NULL )
    42d8:	8c 89       	ldd	r24, Y+20	; 0x14
    42da:	9d 89       	ldd	r25, Y+21	; 0x15
    42dc:	89 2b       	or	r24, r25
    42de:	21 f0       	breq	.+8      	; 0x42e8 <vTaskDelete+0x3a>
            {
                ( void ) uxListRemove( &( pxTCB->xEventListItem ) );
    42e0:	ce 01       	movw	r24, r28
    42e2:	0c 96       	adiw	r24, 0x0c	; 12
    42e4:	0e 94 5b 08 	call	0x10b6	; 0x10b6 <uxListRemove>

            /* Increment the uxTaskNumber also so kernel aware debuggers can
             * detect that the task lists need re-generating.  This is done before
             * portPRE_TASK_DELETE_HOOK() as in the Windows port that macro will
             * not return. */
            uxTaskNumber++;
    42e8:	80 91 08 07 	lds	r24, 0x0708
    42ec:	8f 5f       	subi	r24, 0xFF	; 255
    42ee:	80 93 08 07 	sts	0x0708, r24

            if( pxTCB == pxCurrentTCB )
    42f2:	80 91 f7 06 	lds	r24, 0x06F7
    42f6:	90 91 f8 06 	lds	r25, 0x06F8
    42fa:	c8 17       	cp	r28, r24
    42fc:	d9 07       	cpc	r29, r25
    42fe:	59 f4       	brne	.+22     	; 0x4316 <vTaskDelete+0x68>
                /* A task is deleting itself.  This cannot complete within the
                 * task itself, as a context switch to another task is required.
                 * Place the task in the termination list.  The idle task will
                 * check the termination list and free up any memory allocated by
                 * the scheduler for the TCB and stack of the deleted task. */
                vListInsertEnd( &xTasksWaitingTermination, &( pxTCB->xStateListItem ) );
    4300:	8c e4       	ldi	r24, 0x4C	; 76
    4302:	97 e0       	ldi	r25, 0x07	; 7
    4304:	b8 01       	movw	r22, r16
    4306:	0e 94 0a 08 	call	0x1014	; 0x1014 <vListInsertEnd>

                /* Increment the ucTasksDeleted variable so the idle task knows
                 * there is a task that has been deleted and that it should therefore
                 * check the xTasksWaitingTermination list. */
                ++uxDeletedTasksWaitingCleanUp;
    430a:	80 91 07 07 	lds	r24, 0x0707
    430e:	8f 5f       	subi	r24, 0xFF	; 255
    4310:	80 93 07 07 	sts	0x0707, r24
    4314:	1c c0       	rjmp	.+56     	; 0x434e <vTaskDelete+0xa0>
                 * required. */
                portPRE_TASK_DELETE_HOOK( pxTCB, &xYieldPending );
            }
            else
            {
                --uxCurrentNumberOfTasks;
    4316:	80 91 03 07 	lds	r24, 0x0703
    431a:	81 50       	subi	r24, 0x01	; 1
    431c:	80 93 03 07 	sts	0x0703, r24
#endif /* INCLUDE_vTaskDelete */
/*-----------------------------------------------------------*/

static void prvResetNextTaskUnblockTime( void )
{
    if( listLIST_IS_EMPTY( pxDelayedTaskList ) != pdFALSE )
    4320:	e0 91 3f 07 	lds	r30, 0x073F
    4324:	f0 91 40 07 	lds	r31, 0x0740
    4328:	80 81       	ld	r24, Z
    432a:	88 23       	and	r24, r24
    432c:	19 f4       	brne	.+6      	; 0x4334 <vTaskDelete+0x86>
    {
        /* The new current delayed list is empty.  Set xNextTaskUnblockTime to
         * the maximum possible value so it is  extremely unlikely that the
         * if( xTickCount >= xNextTaskUnblockTime ) test will pass until
         * there is an item in the delayed list. */
        xNextTaskUnblockTime = portMAX_DELAY;
    432e:	8f ef       	ldi	r24, 0xFF	; 255
    4330:	9f ef       	ldi	r25, 0xFF	; 255
    4332:	09 c0       	rjmp	.+18     	; 0x4346 <vTaskDelete+0x98>
    {
        /* The new current delayed list is not empty, get the value of
         * the item at the head of the delayed list.  This is the time at
         * which the task at the head of the delayed list should be removed
         * from the Blocked state. */
        xNextTaskUnblockTime = listGET_ITEM_VALUE_OF_HEAD_ENTRY( pxDelayedTaskList );
    4334:	e0 91 3f 07 	lds	r30, 0x073F
    4338:	f0 91 40 07 	lds	r31, 0x0740
    433c:	05 80       	ldd	r0, Z+5	; 0x05
    433e:	f6 81       	ldd	r31, Z+6	; 0x06
    4340:	e0 2d       	mov	r30, r0
    4342:	80 81       	ld	r24, Z
    4344:	91 81       	ldd	r25, Z+1	; 0x01
    4346:	90 93 ff 06 	sts	0x06FF, r25
    434a:	80 93 fe 06 	sts	0x06FE, r24
                /* Reset the next expected unblock time in case it referred to
                 * the task that has just been deleted. */
                prvResetNextTaskUnblockTime();
            }
        }
        taskEXIT_CRITICAL();
    434e:	0f 90       	pop	r0
    4350:	0f be       	out	0x3f, r0	; 63

        /* If the task is not deleting itself, call prvDeleteTCB from outside of
         * critical section. If a task deletes itself, prvDeleteTCB is called
         * from prvCheckTasksWaitingTermination which is called from Idle task. */
        if( pxTCB != pxCurrentTCB )
    4352:	80 91 f7 06 	lds	r24, 0x06F7
    4356:	90 91 f8 06 	lds	r25, 0x06F8
    435a:	c8 17       	cp	r28, r24
    435c:	d9 07       	cpc	r29, r25
    435e:	39 f0       	breq	.+14     	; 0x436e <vTaskDelete+0xc0>

        #if ( ( configSUPPORT_DYNAMIC_ALLOCATION == 1 ) && ( configSUPPORT_STATIC_ALLOCATION == 0 ) && ( portUSING_MPU_WRAPPERS == 0 ) )
        {
            /* The task can only have been allocated dynamically - free both
             * the stack and TCB. */
            vPortFreeStack( pxTCB->pxStack );
    4360:	8f 89       	ldd	r24, Y+23	; 0x17
    4362:	98 8d       	ldd	r25, Y+24	; 0x18
    4364:	0e 94 b2 07 	call	0xf64	; 0xf64 <vPortFree>
            vPortFree( pxTCB );
    4368:	ce 01       	movw	r24, r28
    436a:	0e 94 b2 07 	call	0xf64	; 0xf64 <vPortFree>
            prvDeleteTCB( pxTCB );
        }

        /* Force a reschedule if it is the currently running task that has just
         * been deleted. */
        if( xSchedulerRunning != pdFALSE )
    436e:	80 91 04 07 	lds	r24, 0x0704
    4372:	88 23       	and	r24, r24
    4374:	49 f0       	breq	.+18     	; 0x4388 <vTaskDelete+0xda>
        {
            if( pxTCB == pxCurrentTCB )
    4376:	80 91 f7 06 	lds	r24, 0x06F7
    437a:	90 91 f8 06 	lds	r25, 0x06F8
    437e:	c8 17       	cp	r28, r24
    4380:	d9 07       	cpc	r29, r25
    4382:	11 f4       	brne	.+4      	; 0x4388 <vTaskDelete+0xda>
            {
                configASSERT( uxSchedulerSuspended == 0 );
                portYIELD_WITHIN_API();
    4384:	0e 94 64 09 	call	0x12c8	; 0x12c8 <vPortYield>
            else
            {
                mtCOVERAGE_TEST_MARKER();
            }
        }
    }
    4388:	df 91       	pop	r29
    438a:	cf 91       	pop	r28
    438c:	1f 91       	pop	r17
    438e:	0f 91       	pop	r16
    4390:	08 95       	ret

00004392 <xTaskCreate>:
                            const char * const pcName, /*lint !e971 Unqualified char types are allowed for strings and single characters only. */
                            const configSTACK_DEPTH_TYPE usStackDepth,
                            void * const pvParameters,
                            UBaseType_t uxPriority,
                            TaskHandle_t * const pxCreatedTask )
    {
    4392:	4f 92       	push	r4
    4394:	5f 92       	push	r5
    4396:	6f 92       	push	r6
    4398:	7f 92       	push	r7
    439a:	8f 92       	push	r8
    439c:	9f 92       	push	r9
    439e:	af 92       	push	r10
    43a0:	bf 92       	push	r11
    43a2:	cf 92       	push	r12
    43a4:	df 92       	push	r13
    43a6:	ef 92       	push	r14
    43a8:	ff 92       	push	r15
    43aa:	0f 93       	push	r16
    43ac:	1f 93       	push	r17
    43ae:	cf 93       	push	r28
    43b0:	df 93       	push	r29
    43b2:	2c 01       	movw	r4, r24
    43b4:	5b 01       	movw	r10, r22
    43b6:	6a 01       	movw	r12, r20
    43b8:	39 01       	movw	r6, r18
    43ba:	47 01       	movw	r8, r14
        #else /* portSTACK_GROWTH */
        {
            StackType_t * pxStack;

            /* Allocate space for the stack used by the task being created. */
            pxStack = pvPortMallocStack( ( ( ( size_t ) usStackDepth ) * sizeof( StackType_t ) ) ); /*lint !e9079 All values returned by pvPortMalloc() have at least the alignment required by the MCU's stack and this allocation is the stack. */
    43bc:	ca 01       	movw	r24, r20
    43be:	0e 94 c2 07 	call	0xf84	; 0xf84 <pvPortMalloc>
    43c2:	7c 01       	movw	r14, r24

            if( pxStack != NULL )
    43c4:	00 97       	sbiw	r24, 0x00	; 0
    43c6:	a9 f0       	breq	.+42     	; 0x43f2 <xTaskCreate+0x60>
            {
                /* Allocate space for the TCB. */
                pxNewTCB = ( TCB_t * ) pvPortMalloc( sizeof( TCB_t ) ); /*lint !e9087 !e9079 All values returned by pvPortMalloc() have at least the alignment required by the MCU's stack, and the first member of TCB_t is always a pointer to the task's stack. */
    43c8:	88 e2       	ldi	r24, 0x28	; 40
    43ca:	90 e0       	ldi	r25, 0x00	; 0
    43cc:	0e 94 c2 07 	call	0xf84	; 0xf84 <pvPortMalloc>
    43d0:	ec 01       	movw	r28, r24

                if( pxNewTCB != NULL )
    43d2:	00 97       	sbiw	r24, 0x00	; 0
    43d4:	59 f0       	breq	.+22     	; 0x43ec <xTaskCreate+0x5a>
                {
                    memset( ( void * ) pxNewTCB, 0x00, sizeof( TCB_t ) );
    43d6:	88 e2       	ldi	r24, 0x28	; 40
    43d8:	fe 01       	movw	r30, r28
    43da:	11 92       	st	Z+, r1
    43dc:	8a 95       	dec	r24
    43de:	e9 f7       	brne	.-6      	; 0x43da <xTaskCreate+0x48>

                    /* Store the stack location in the TCB. */
                    pxNewTCB->pxStack = pxStack;
    43e0:	f8 8e       	std	Y+24, r15	; 0x18
    43e2:	ef 8a       	std	Y+23, r14	; 0x17
        pxNewTCB->pxEndOfStack = pxNewTCB->pxStack + ( ulStackDepth - ( uint32_t ) 1 );
    }
    #endif /* portSTACK_GROWTH */

    /* Store the task name in the TCB. */
    if( pcName != NULL )
    43e4:	a1 14       	cp	r10, r1
    43e6:	b1 04       	cpc	r11, r1
    43e8:	31 f4       	brne	.+12     	; 0x43f6 <xTaskCreate+0x64>
    43ea:	15 c0       	rjmp	.+42     	; 0x4416 <xTaskCreate+0x84>
                }
                else
                {
                    /* The stack cannot be used as the TCB was not created.  Free
                     * it again. */
                    vPortFreeStack( pxStack );
    43ec:	c7 01       	movw	r24, r14
    43ee:	0e 94 b2 07 	call	0xf64	; 0xf64 <vPortFree>
    43f2:	8f ef       	ldi	r24, 0xFF	; 255
    43f4:	de c0       	rjmp	.+444    	; 0x45b2 <xTaskCreate+0x220>
    43f6:	f5 01       	movw	r30, r10
    43f8:	de 01       	movw	r26, r28
    43fa:	90 e0       	ldi	r25, 0x00	; 0
    /* Store the task name in the TCB. */
    if( pcName != NULL )
    {
        for( x = ( UBaseType_t ) 0; x < ( UBaseType_t ) configMAX_TASK_NAME_LEN; x++ )
        {
            pxNewTCB->pcTaskName[ x ] = pcName[ x ];
    43fc:	80 81       	ld	r24, Z
    43fe:	59 96       	adiw	r26, 0x19	; 25
    4400:	8c 93       	st	X, r24
    4402:	59 97       	sbiw	r26, 0x19	; 25

            /* Don't copy all configMAX_TASK_NAME_LEN if the string is shorter than
             * configMAX_TASK_NAME_LEN characters just in case the memory after the
             * string is not accessible (extremely unlikely). */
            if( pcName[ x ] == ( char ) 0x00 )
    4404:	80 81       	ld	r24, Z
    4406:	88 23       	and	r24, r24
    4408:	29 f0       	breq	.+10     	; 0x4414 <xTaskCreate+0x82>
    #endif /* portSTACK_GROWTH */

    /* Store the task name in the TCB. */
    if( pcName != NULL )
    {
        for( x = ( UBaseType_t ) 0; x < ( UBaseType_t ) configMAX_TASK_NAME_LEN; x++ )
    440a:	9f 5f       	subi	r25, 0xFF	; 255
    440c:	31 96       	adiw	r30, 0x01	; 1
    440e:	11 96       	adiw	r26, 0x01	; 1
    4410:	98 30       	cpi	r25, 0x08	; 8
    4412:	a1 f7       	brne	.-24     	; 0x43fc <xTaskCreate+0x6a>
            }
        }

        /* Ensure the name string is terminated in the case that the string length
         * was greater or equal to configMAX_TASK_NAME_LEN. */
        pxNewTCB->pcTaskName[ configMAX_TASK_NAME_LEN - 1 ] = '\0';
    4414:	18 a2       	std	Y+32, r1	; 0x20
    4416:	04 30       	cpi	r16, 0x04	; 4
    4418:	08 f0       	brcs	.+2      	; 0x441c <xTaskCreate+0x8a>
    441a:	03 e0       	ldi	r16, 0x03	; 3
    else
    {
        mtCOVERAGE_TEST_MARKER();
    }

    pxNewTCB->uxPriority = uxPriority;
    441c:	0e 8b       	std	Y+22, r16	; 0x16
    #if ( configUSE_MUTEXES == 1 )
    {
        pxNewTCB->uxBasePriority = uxPriority;
    441e:	09 a3       	std	Y+33, r16	; 0x21
    }
    #endif /* configUSE_MUTEXES */

    vListInitialiseItem( &( pxNewTCB->xStateListItem ) );
    4420:	72 e0       	ldi	r23, 0x02	; 2
    4422:	a7 2e       	mov	r10, r23
    4424:	b1 2c       	mov	r11, r1
    4426:	ac 0e       	add	r10, r28
    4428:	bd 1e       	adc	r11, r29
    442a:	c5 01       	movw	r24, r10
    442c:	0e 94 06 08 	call	0x100c	; 0x100c <vListInitialiseItem>
    vListInitialiseItem( &( pxNewTCB->xEventListItem ) );
    4430:	ce 01       	movw	r24, r28
    4432:	0c 96       	adiw	r24, 0x0c	; 12
    4434:	0e 94 06 08 	call	0x100c	; 0x100c <vListInitialiseItem>

    /* Set the pxNewTCB as a link back from the ListItem_t.  This is so we can get
     * back to  the containing TCB from a generic item in a list. */
    listSET_LIST_ITEM_OWNER( &( pxNewTCB->xStateListItem ), pxNewTCB );
    4438:	d9 87       	std	Y+9, r29	; 0x09
    443a:	c8 87       	std	Y+8, r28	; 0x08

    /* Event lists are always in priority order. */
    listSET_LIST_ITEM_VALUE( &( pxNewTCB->xEventListItem ), ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) uxPriority ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
    443c:	84 e0       	ldi	r24, 0x04	; 4
    443e:	90 e0       	ldi	r25, 0x00	; 0
    4440:	80 1b       	sub	r24, r16
    4442:	91 09       	sbc	r25, r1
    4444:	9d 87       	std	Y+13, r25	; 0x0d
    4446:	8c 87       	std	Y+12, r24	; 0x0c
    listSET_LIST_ITEM_OWNER( &( pxNewTCB->xEventListItem ), pxNewTCB );
    4448:	db 8b       	std	Y+19, r29	; 0x13
    444a:	ca 8b       	std	Y+18, r28	; 0x12
            }
            #endif /* portSTACK_GROWTH */
        }
        #else /* portHAS_STACK_OVERFLOW_CHECKING */
        {
            pxNewTCB->pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxTaskCode, pvParameters );
    444c:	08 94       	sec
    444e:	c1 08       	sbc	r12, r1
    4450:	d1 08       	sbc	r13, r1
    4452:	c7 01       	movw	r24, r14
    4454:	8c 0d       	add	r24, r12
    4456:	9d 1d       	adc	r25, r13
    4458:	b2 01       	movw	r22, r4
    445a:	a3 01       	movw	r20, r6
    445c:	0e 94 86 08 	call	0x110c	; 0x110c <pxPortInitialiseStack>
    4460:	99 83       	std	Y+1, r25	; 0x01
    4462:	88 83       	st	Y, r24
        }
        #endif /* portHAS_STACK_OVERFLOW_CHECKING */
    }
    #endif /* portUSING_MPU_WRAPPERS */

    if( pxCreatedTask != NULL )
    4464:	81 14       	cp	r8, r1
    4466:	91 04       	cpc	r9, r1
    4468:	19 f0       	breq	.+6      	; 0x4470 <xTaskCreate+0xde>
    {
        /* Pass the handle out in an anonymous way.  The handle can be used to
         * change the created task's priority, delete the created task, etc.*/
        *pxCreatedTask = ( TaskHandle_t ) pxNewTCB;
    446a:	f4 01       	movw	r30, r8
    446c:	d1 83       	std	Z+1, r29	; 0x01
    446e:	c0 83       	st	Z, r28

static void prvAddNewTaskToReadyList( TCB_t * pxNewTCB )
{
    /* Ensure interrupts don't access the task lists while the lists are being
     * updated. */
    taskENTER_CRITICAL();
    4470:	0f b6       	in	r0, 0x3f	; 63
    4472:	f8 94       	cli
    4474:	0f 92       	push	r0
    {
        uxCurrentNumberOfTasks++;
    4476:	80 91 03 07 	lds	r24, 0x0703
    447a:	8f 5f       	subi	r24, 0xFF	; 255
    447c:	80 93 03 07 	sts	0x0703, r24

        if( pxCurrentTCB == NULL )
    4480:	80 91 f7 06 	lds	r24, 0x06F7
    4484:	90 91 f8 06 	lds	r25, 0x06F8
    4488:	89 2b       	or	r24, r25
    448a:	d1 f5       	brne	.+116    	; 0x4500 <xTaskCreate+0x16e>
        {
            /* There are no other tasks, or all the other tasks are in
             * the suspended state - make this the current task. */
            pxCurrentTCB = pxNewTCB;
    448c:	d0 93 f8 06 	sts	0x06F8, r29
    4490:	c0 93 f7 06 	sts	0x06F7, r28

            if( uxCurrentNumberOfTasks == ( UBaseType_t ) 1 )
    4494:	80 91 03 07 	lds	r24, 0x0703
    4498:	81 30       	cpi	r24, 0x01	; 1
    449a:	09 f0       	breq	.+2      	; 0x449e <xTaskCreate+0x10c>
    449c:	41 c0       	rjmp	.+130    	; 0x4520 <xTaskCreate+0x18e>
{
    UBaseType_t uxPriority;

    for( uxPriority = ( UBaseType_t ) 0U; uxPriority < ( UBaseType_t ) configMAX_PRIORITIES; uxPriority++ )
    {
        vListInitialise( &( pxReadyTasksLists[ uxPriority ] ) );
    449e:	89 e0       	ldi	r24, 0x09	; 9
    44a0:	97 e0       	ldi	r25, 0x07	; 7
    44a2:	0e 94 f6 07 	call	0xfec	; 0xfec <vListInitialise>
    44a6:	82 e1       	ldi	r24, 0x12	; 18
    44a8:	97 e0       	ldi	r25, 0x07	; 7
    44aa:	0e 94 f6 07 	call	0xfec	; 0xfec <vListInitialise>
    44ae:	8b e1       	ldi	r24, 0x1B	; 27
    44b0:	97 e0       	ldi	r25, 0x07	; 7
    44b2:	0e 94 f6 07 	call	0xfec	; 0xfec <vListInitialise>
    44b6:	84 e2       	ldi	r24, 0x24	; 36
    44b8:	97 e0       	ldi	r25, 0x07	; 7
    44ba:	0e 94 f6 07 	call	0xfec	; 0xfec <vListInitialise>
    }

    vListInitialise( &xDelayedTaskList1 );
    44be:	6d e2       	ldi	r22, 0x2D	; 45
    44c0:	e6 2e       	mov	r14, r22
    44c2:	67 e0       	ldi	r22, 0x07	; 7
    44c4:	f6 2e       	mov	r15, r22
    44c6:	c7 01       	movw	r24, r14
    44c8:	0e 94 f6 07 	call	0xfec	; 0xfec <vListInitialise>
    vListInitialise( &xDelayedTaskList2 );
    44cc:	06 e3       	ldi	r16, 0x36	; 54
    44ce:	17 e0       	ldi	r17, 0x07	; 7
    44d0:	c8 01       	movw	r24, r16
    44d2:	0e 94 f6 07 	call	0xfec	; 0xfec <vListInitialise>
    vListInitialise( &xPendingReadyList );
    44d6:	83 e4       	ldi	r24, 0x43	; 67
    44d8:	97 e0       	ldi	r25, 0x07	; 7
    44da:	0e 94 f6 07 	call	0xfec	; 0xfec <vListInitialise>

    #if ( INCLUDE_vTaskDelete == 1 )
    {
        vListInitialise( &xTasksWaitingTermination );
    44de:	8c e4       	ldi	r24, 0x4C	; 76
    44e0:	97 e0       	ldi	r25, 0x07	; 7
    44e2:	0e 94 f6 07 	call	0xfec	; 0xfec <vListInitialise>
    }
    #endif /* INCLUDE_vTaskDelete */

    #if ( INCLUDE_vTaskSuspend == 1 )
    {
        vListInitialise( &xSuspendedTaskList );
    44e6:	85 e5       	ldi	r24, 0x55	; 85
    44e8:	97 e0       	ldi	r25, 0x07	; 7
    44ea:	0e 94 f6 07 	call	0xfec	; 0xfec <vListInitialise>
    }
    #endif /* INCLUDE_vTaskSuspend */

    /* Start with pxDelayedTaskList using list1 and the pxOverflowDelayedTaskList
     * using list2. */
    pxDelayedTaskList = &xDelayedTaskList1;
    44ee:	f0 92 40 07 	sts	0x0740, r15
    44f2:	e0 92 3f 07 	sts	0x073F, r14
    pxOverflowDelayedTaskList = &xDelayedTaskList2;
    44f6:	10 93 42 07 	sts	0x0742, r17
    44fa:	00 93 41 07 	sts	0x0741, r16
    44fe:	10 c0       	rjmp	.+32     	; 0x4520 <xTaskCreate+0x18e>
        else
        {
            /* If the scheduler is not already running, make this task the
             * current task if it is the highest priority task to be created
             * so far. */
            if( xSchedulerRunning == pdFALSE )
    4500:	80 91 04 07 	lds	r24, 0x0704
    4504:	88 23       	and	r24, r24
    4506:	61 f4       	brne	.+24     	; 0x4520 <xTaskCreate+0x18e>
            {
                if( pxCurrentTCB->uxPriority <= pxNewTCB->uxPriority )
    4508:	e0 91 f7 06 	lds	r30, 0x06F7
    450c:	f0 91 f8 06 	lds	r31, 0x06F8
    4510:	96 89       	ldd	r25, Z+22	; 0x16
    4512:	8e 89       	ldd	r24, Y+22	; 0x16
    4514:	89 17       	cp	r24, r25
    4516:	20 f0       	brcs	.+8      	; 0x4520 <xTaskCreate+0x18e>
                {
                    pxCurrentTCB = pxNewTCB;
    4518:	d0 93 f8 06 	sts	0x06F8, r29
    451c:	c0 93 f7 06 	sts	0x06F7, r28
            {
                mtCOVERAGE_TEST_MARKER();
            }
        }

        uxTaskNumber++;
    4520:	80 91 08 07 	lds	r24, 0x0708
    4524:	8f 5f       	subi	r24, 0xFF	; 255
    4526:	80 93 08 07 	sts	0x0708, r24
            pxNewTCB->uxTCBNumber = uxTaskNumber;
        }
        #endif /* configUSE_TRACE_FACILITY */
        traceTASK_CREATE( pxNewTCB );

        prvAddTaskToReadyList( pxNewTCB );
    452a:	9e 89       	ldd	r25, Y+22	; 0x16
    452c:	80 91 fa 06 	lds	r24, 0x06FA
    4530:	89 17       	cp	r24, r25
    4532:	10 f4       	brcc	.+4      	; 0x4538 <xTaskCreate+0x1a6>
    4534:	90 93 fa 06 	sts	0x06FA, r25
    4538:	8e 89       	ldd	r24, Y+22	; 0x16
    453a:	90 e0       	ldi	r25, 0x00	; 0
    453c:	fc 01       	movw	r30, r24
    453e:	53 e0       	ldi	r21, 0x03	; 3
    4540:	ee 0f       	add	r30, r30
    4542:	ff 1f       	adc	r31, r31
    4544:	5a 95       	dec	r21
    4546:	e1 f7       	brne	.-8      	; 0x4540 <xTaskCreate+0x1ae>
    4548:	e8 0f       	add	r30, r24
    454a:	f9 1f       	adc	r31, r25
    454c:	e7 5f       	subi	r30, 0xF7	; 247
    454e:	f8 4f       	sbci	r31, 0xF8	; 248
    4550:	a1 81       	ldd	r26, Z+1	; 0x01
    4552:	b2 81       	ldd	r27, Z+2	; 0x02
    4554:	bd 83       	std	Y+5, r27	; 0x05
    4556:	ac 83       	std	Y+4, r26	; 0x04
    4558:	14 96       	adiw	r26, 0x04	; 4
    455a:	8d 91       	ld	r24, X+
    455c:	9c 91       	ld	r25, X
    455e:	15 97       	sbiw	r26, 0x05	; 5
    4560:	9f 83       	std	Y+7, r25	; 0x07
    4562:	8e 83       	std	Y+6, r24	; 0x06
    4564:	14 96       	adiw	r26, 0x04	; 4
    4566:	ed 91       	ld	r30, X+
    4568:	fc 91       	ld	r31, X
    456a:	15 97       	sbiw	r26, 0x05	; 5
    456c:	b3 82       	std	Z+3, r11	; 0x03
    456e:	a2 82       	std	Z+2, r10	; 0x02
    4570:	15 96       	adiw	r26, 0x05	; 5
    4572:	bc 92       	st	X, r11
    4574:	ae 92       	st	-X, r10
    4576:	14 97       	sbiw	r26, 0x04	; 4
    4578:	ee 89       	ldd	r30, Y+22	; 0x16
    457a:	89 e0       	ldi	r24, 0x09	; 9
    457c:	e8 9f       	mul	r30, r24
    457e:	f0 01       	movw	r30, r0
    4580:	11 24       	eor	r1, r1
    4582:	e7 5f       	subi	r30, 0xF7	; 247
    4584:	f8 4f       	sbci	r31, 0xF8	; 248
    4586:	fb 87       	std	Y+11, r31	; 0x0b
    4588:	ea 87       	std	Y+10, r30	; 0x0a
    458a:	80 81       	ld	r24, Z
    458c:	8f 5f       	subi	r24, 0xFF	; 255
    458e:	80 83       	st	Z, r24

        portSETUP_TCB( pxNewTCB );
    }
    taskEXIT_CRITICAL();
    4590:	0f 90       	pop	r0
    4592:	0f be       	out	0x3f, r0	; 63

    if( xSchedulerRunning != pdFALSE )
    4594:	80 91 04 07 	lds	r24, 0x0704
    4598:	88 23       	and	r24, r24
    459a:	51 f0       	breq	.+20     	; 0x45b0 <xTaskCreate+0x21e>
    {
        /* If the created task is of a higher priority than the current task
         * then it should run now. */
        if( pxCurrentTCB->uxPriority < pxNewTCB->uxPriority )
    459c:	e0 91 f7 06 	lds	r30, 0x06F7
    45a0:	f0 91 f8 06 	lds	r31, 0x06F8
    45a4:	96 89       	ldd	r25, Z+22	; 0x16
    45a6:	8e 89       	ldd	r24, Y+22	; 0x16
    45a8:	98 17       	cp	r25, r24
    45aa:	10 f4       	brcc	.+4      	; 0x45b0 <xTaskCreate+0x21e>
        {
            taskYIELD_IF_USING_PREEMPTION();
    45ac:	0e 94 64 09 	call	0x12c8	; 0x12c8 <vPortYield>
    45b0:	81 e0       	ldi	r24, 0x01	; 1
        {
            xReturn = errCOULD_NOT_ALLOCATE_REQUIRED_MEMORY;
        }

        return xReturn;
    }
    45b2:	df 91       	pop	r29
    45b4:	cf 91       	pop	r28
    45b6:	1f 91       	pop	r17
    45b8:	0f 91       	pop	r16
    45ba:	ff 90       	pop	r15
    45bc:	ef 90       	pop	r14
    45be:	df 90       	pop	r13
    45c0:	cf 90       	pop	r12
    45c2:	bf 90       	pop	r11
    45c4:	af 90       	pop	r10
    45c6:	9f 90       	pop	r9
    45c8:	8f 90       	pop	r8
    45ca:	7f 90       	pop	r7
    45cc:	6f 90       	pop	r6
    45ce:	5f 90       	pop	r5
    45d0:	4f 90       	pop	r4
    45d2:	08 95       	ret

000045d4 <vTaskStartScheduler>:

#endif /* ( ( INCLUDE_xTaskResumeFromISR == 1 ) && ( INCLUDE_vTaskSuspend == 1 ) ) */
/*-----------------------------------------------------------*/

void vTaskStartScheduler( void )
{
    45d4:	ef 92       	push	r14
    45d6:	ff 92       	push	r15
    45d8:	0f 93       	push	r16
        }
    }
    #else /* if ( configSUPPORT_STATIC_ALLOCATION == 1 ) */
    {
        /* The Idle task is being created using dynamically allocated RAM. */
        xReturn = xTaskCreate( prvIdleTask,
    45da:	8c e4       	ldi	r24, 0x4C	; 76
    45dc:	90 e2       	ldi	r25, 0x20	; 32
    45de:	6a e6       	ldi	r22, 0x6A	; 106
    45e0:	70 e0       	ldi	r23, 0x00	; 0
    45e2:	45 e5       	ldi	r20, 0x55	; 85
    45e4:	50 e0       	ldi	r21, 0x00	; 0
    45e6:	20 e0       	ldi	r18, 0x00	; 0
    45e8:	30 e0       	ldi	r19, 0x00	; 0
    45ea:	00 e0       	ldi	r16, 0x00	; 0
    45ec:	e5 e0       	ldi	r30, 0x05	; 5
    45ee:	ee 2e       	mov	r14, r30
    45f0:	e7 e0       	ldi	r30, 0x07	; 7
    45f2:	fe 2e       	mov	r15, r30
    45f4:	0e 94 c9 21 	call	0x4392	; 0x4392 <xTaskCreate>
            mtCOVERAGE_TEST_MARKER();
        }
    }
    #endif /* configUSE_TIMERS */

    if( xReturn == pdPASS )
    45f8:	81 30       	cpi	r24, 0x01	; 1
    45fa:	81 f4       	brne	.+32     	; 0x461c <vTaskStartScheduler+0x48>
        /* Interrupts are turned off here, to ensure a tick does not occur
         * before or during the call to xPortStartScheduler().  The stacks of
         * the created tasks contain a status word with interrupts switched on
         * so interrupts will automatically get re-enabled when the first task
         * starts to run. */
        portDISABLE_INTERRUPTS();
    45fc:	f8 94       	cli
             * block specific to the task that will run first. */
            configSET_TLS_BLOCK( pxCurrentTCB->xTLSBlock );
        }
        #endif

        xNextTaskUnblockTime = portMAX_DELAY;
    45fe:	8f ef       	ldi	r24, 0xFF	; 255
    4600:	9f ef       	ldi	r25, 0xFF	; 255
    4602:	90 93 ff 06 	sts	0x06FF, r25
    4606:	80 93 fe 06 	sts	0x06FE, r24
        xSchedulerRunning = pdTRUE;
    460a:	81 e0       	ldi	r24, 0x01	; 1
    460c:	80 93 04 07 	sts	0x0704, r24
        xTickCount = ( TickType_t ) configINITIAL_TICK_COUNT;
    4610:	10 92 fd 06 	sts	0x06FD, r1
    4614:	10 92 fc 06 	sts	0x06FC, r1

        traceTASK_SWITCHED_IN();

        /* Setting up the timer tick is hardware specific and thus in the
         * portable interface. */
        xPortStartScheduler();
    4618:	0e 94 ce 08 	call	0x119c	; 0x119c <xPortStartScheduler>
     * meaning xIdleTaskHandle is not used anywhere else. */
    ( void ) xIdleTaskHandle;

    /* OpenOCD makes use of uxTopUsedPriority for thread debugging. Prevent uxTopUsedPriority
     * from getting optimized out as it is no longer used by the kernel. */
    ( void ) uxTopUsedPriority;
    461c:	80 91 f8 00 	lds	r24, 0x00F8
}
    4620:	0f 91       	pop	r16
    4622:	ff 90       	pop	r15
    4624:	ef 90       	pop	r14
    4626:	08 95       	ret

00004628 <main>:
		vTaskDelay(1000);
	}
}

int main()
{
    4628:	cf 92       	push	r12
    462a:	df 92       	push	r13
    462c:	ef 92       	push	r14
    462e:	ff 92       	push	r15
    4630:	0f 93       	push	r16
    4632:	df 93       	push	r29
    4634:	cf 93       	push	r28
    4636:	00 d0       	rcall	.+0      	; 0x4638 <main+0x10>
    4638:	0f 92       	push	r0
    463a:	cd b7       	in	r28, 0x3d	; 61
    463c:	de b7       	in	r29, 0x3e	; 62
	LCD_KIT_voidInitialization();
    463e:	0e 94 0e 05 	call	0xa1c	; 0xa1c <LCD_KIT_voidInitialization>
	KEYBAD_voidInitialization();
    4642:	0e 94 d9 05 	call	0xbb2	; 0xbb2 <KEYBAD_voidInitialization>

	//LCD_KIT_voidDisplayCharacter('H');

	xQueue_Password = xQueueCreate( 5, sizeof( unsigned char ) );
    4646:	85 e0       	ldi	r24, 0x05	; 5
    4648:	61 e0       	ldi	r22, 0x01	; 1
    464a:	40 e0       	ldi	r20, 0x00	; 0
    464c:	0e 94 41 0f 	call	0x1e82	; 0x1e82 <xQueueGenericCreate>
    4650:	90 93 71 07 	sts	0x0771, r25
    4654:	80 93 70 07 	sts	0x0770, r24
	xQueue_Equation = xQueueCreate( 20, sizeof( u8 ) );
    4658:	84 e1       	ldi	r24, 0x14	; 20
    465a:	61 e0       	ldi	r22, 0x01	; 1
    465c:	40 e0       	ldi	r20, 0x00	; 0
    465e:	0e 94 41 0f 	call	0x1e82	; 0x1e82 <xQueueGenericCreate>
    4662:	90 93 75 07 	sts	0x0775, r25
    4666:	80 93 74 07 	sts	0x0774, r24

	xEventGroup = xEventGroupCreate();
    466a:	0e 94 9f 07 	call	0xf3e	; 0xf3e <xEventGroupCreate>
    466e:	90 93 6b 07 	sts	0x076B, r25
    4672:	80 93 6a 07 	sts	0x076A, r24

	Mutex_LCD = xSemaphoreCreateMutex();
    4676:	81 e0       	ldi	r24, 0x01	; 1
    4678:	0e 94 84 0f 	call	0x1f08	; 0x1f08 <xQueueCreateMutex>
    467c:	90 93 6d 07 	sts	0x076D, r25
    4680:	80 93 6c 07 	sts	0x076C, r24



	u8 LED_ID_1 = 4;
    4684:	84 e0       	ldi	r24, 0x04	; 4
    4686:	89 83       	std	Y+1, r24	; 0x01
	u8 LED_ID_2 = 5;
    4688:	85 e0       	ldi	r24, 0x05	; 5
    468a:	8a 83       	std	Y+2, r24	; 0x02
	u8 LED_ID_3 = 6;
    468c:	86 e0       	ldi	r24, 0x06	; 6
    468e:	8b 83       	std	Y+3, r24	; 0x03

	u8 Priority = 1;

	xTaskCreate(TasK1,"GET_PASSWORD",	150,&LED_ID_1,	3,	&Task1_Handler);
    4690:	89 e6       	ldi	r24, 0x69	; 105
    4692:	95 e2       	ldi	r25, 0x25	; 37
    4694:	6f e6       	ldi	r22, 0x6F	; 111
    4696:	70 e0       	ldi	r23, 0x00	; 0
    4698:	46 e9       	ldi	r20, 0x96	; 150
    469a:	50 e0       	ldi	r21, 0x00	; 0
    469c:	9e 01       	movw	r18, r28
    469e:	2f 5f       	subi	r18, 0xFF	; 255
    46a0:	3f 4f       	sbci	r19, 0xFF	; 255
    46a2:	03 e0       	ldi	r16, 0x03	; 3
    46a4:	ef e5       	ldi	r30, 0x5F	; 95
    46a6:	ee 2e       	mov	r14, r30
    46a8:	e7 e0       	ldi	r30, 0x07	; 7
    46aa:	fe 2e       	mov	r15, r30
    46ac:	0e 94 c9 21 	call	0x4392	; 0x4392 <xTaskCreate>
	xTaskCreate(TasK2,"CHECK_PASSWORD",	150,&LED_ID_2,	2,	&Task2_Handler);
    46b0:	8e ef       	ldi	r24, 0xFE	; 254
    46b2:	94 e2       	ldi	r25, 0x24	; 36
    46b4:	6c e7       	ldi	r22, 0x7C	; 124
    46b6:	70 e0       	ldi	r23, 0x00	; 0
    46b8:	46 e9       	ldi	r20, 0x96	; 150
    46ba:	50 e0       	ldi	r21, 0x00	; 0
    46bc:	9e 01       	movw	r18, r28
    46be:	2e 5f       	subi	r18, 0xFE	; 254
    46c0:	3f 4f       	sbci	r19, 0xFF	; 255
    46c2:	02 e0       	ldi	r16, 0x02	; 2
    46c4:	b1 e6       	ldi	r27, 0x61	; 97
    46c6:	eb 2e       	mov	r14, r27
    46c8:	b7 e0       	ldi	r27, 0x07	; 7
    46ca:	fb 2e       	mov	r15, r27
    46cc:	0e 94 c9 21 	call	0x4392	; 0x4392 <xTaskCreate>
	xTaskCreate(TasK3,"GET_EQUATION",	150,&LED_ID_3,	1,	&Task3_Handler);
    46d0:	a3 e0       	ldi	r26, 0x03	; 3
    46d2:	ca 2e       	mov	r12, r26
    46d4:	d1 2c       	mov	r13, r1
    46d6:	cc 0e       	add	r12, r28
    46d8:	dd 1e       	adc	r13, r29
    46da:	83 e7       	ldi	r24, 0x73	; 115
    46dc:	94 e2       	ldi	r25, 0x24	; 36
    46de:	6b e8       	ldi	r22, 0x8B	; 139
    46e0:	70 e0       	ldi	r23, 0x00	; 0
    46e2:	46 e9       	ldi	r20, 0x96	; 150
    46e4:	50 e0       	ldi	r21, 0x00	; 0
    46e6:	96 01       	movw	r18, r12
    46e8:	01 e0       	ldi	r16, 0x01	; 1
    46ea:	f3 e6       	ldi	r31, 0x63	; 99
    46ec:	ef 2e       	mov	r14, r31
    46ee:	f7 e0       	ldi	r31, 0x07	; 7
    46f0:	ff 2e       	mov	r15, r31
    46f2:	0e 94 c9 21 	call	0x4392	; 0x4392 <xTaskCreate>
	xTaskCreate(TasK4,"SOLVE_EQUATION",	150,&LED_ID_3,	1,	&Task4_Handler);
    46f6:	8d e9       	ldi	r24, 0x9D	; 157
    46f8:	93 e2       	ldi	r25, 0x23	; 35
    46fa:	68 e9       	ldi	r22, 0x98	; 152
    46fc:	70 e0       	ldi	r23, 0x00	; 0
    46fe:	46 e9       	ldi	r20, 0x96	; 150
    4700:	50 e0       	ldi	r21, 0x00	; 0
    4702:	96 01       	movw	r18, r12
    4704:	e5 e6       	ldi	r30, 0x65	; 101
    4706:	ee 2e       	mov	r14, r30
    4708:	e7 e0       	ldi	r30, 0x07	; 7
    470a:	fe 2e       	mov	r15, r30
    470c:	0e 94 c9 21 	call	0x4392	; 0x4392 <xTaskCreate>

	vTaskSuspend(Task2_Handler);
    4710:	80 91 61 07 	lds	r24, 0x0761
    4714:	90 91 62 07 	lds	r25, 0x0762
    4718:	0e 94 ef 20 	call	0x41de	; 0x41de <vTaskSuspend>
	vTaskSuspend(Task3_Handler);
    471c:	80 91 63 07 	lds	r24, 0x0763
    4720:	90 91 64 07 	lds	r25, 0x0764
    4724:	0e 94 ef 20 	call	0x41de	; 0x41de <vTaskSuspend>
	vTaskSuspend(Task4_Handler);
    4728:	80 91 65 07 	lds	r24, 0x0765
    472c:	90 91 66 07 	lds	r25, 0x0766
    4730:	0e 94 ef 20 	call	0x41de	; 0x41de <vTaskSuspend>

	vTaskStartScheduler();
    4734:	0e 94 ea 22 	call	0x45d4	; 0x45d4 <vTaskStartScheduler>
    4738:	ff cf       	rjmp	.-2      	; 0x4738 <main+0x110>

0000473a <TasK4>:
		vTaskDelay(1000);
	}
}

void TasK4(  void * PTR4 )
{
    473a:	ff 92       	push	r15
    473c:	0f 93       	push	r16
    473e:	1f 93       	push	r17
    4740:	df 93       	push	r29
    4742:	cf 93       	push	r28
    4744:	0f 92       	push	r0
    4746:	cd b7       	in	r28, 0x3d	; 61
    4748:	de b7       	in	r29, 0x3e	; 62
		static u16 res=0;
		static u8 opr=0;
		static u8 flag=0;
		static u8 Previous_operator='N';

		xQueueReceive( xQueue_Equation, &Recieve_Value, ( TickType_t ) 10 );
    474a:	8e 01       	movw	r16, r28
    474c:	0f 5f       	subi	r16, 0xFF	; 255
    474e:	1f 4f       	sbci	r17, 0xFF	; 255


		if( (Recieve_Value != '*') && (Recieve_Value != '/')  && (Recieve_Value != '+') && (Recieve_Value != '-') && (Recieve_Value != '='))
		{
			//LCD_KIT_voidDisplayCharacter(Recieve_Value);
			opr *= 10;
    4750:	fa e0       	ldi	r31, 0x0A	; 10
    4752:	ff 2e       	mov	r15, r31
		static u16 res=0;
		static u8 opr=0;
		static u8 flag=0;
		static u8 Previous_operator='N';

		xQueueReceive( xQueue_Equation, &Recieve_Value, ( TickType_t ) 10 );
    4754:	80 91 74 07 	lds	r24, 0x0774
    4758:	90 91 75 07 	lds	r25, 0x0775
    475c:	b8 01       	movw	r22, r16
    475e:	4a e0       	ldi	r20, 0x0A	; 10
    4760:	50 e0       	ldi	r21, 0x00	; 0
    4762:	0e 94 10 0c 	call	0x1820	; 0x1820 <xQueueReceive>
//		LCD_KIT_voidDisplayCharacter(Recieve_Value);


		if( (Recieve_Value != '*') && (Recieve_Value != '/')  && (Recieve_Value != '+') && (Recieve_Value != '-') && (Recieve_Value != '='))
    4766:	49 81       	ldd	r20, Y+1	; 0x01
    4768:	4a 32       	cpi	r20, 0x2A	; 42
    476a:	99 f0       	breq	.+38     	; 0x4792 <TasK4+0x58>
    476c:	4f 32       	cpi	r20, 0x2F	; 47
    476e:	89 f0       	breq	.+34     	; 0x4792 <TasK4+0x58>
    4770:	4b 32       	cpi	r20, 0x2B	; 43
    4772:	79 f0       	breq	.+30     	; 0x4792 <TasK4+0x58>
    4774:	4d 32       	cpi	r20, 0x2D	; 45
    4776:	69 f0       	breq	.+26     	; 0x4792 <TasK4+0x58>
    4778:	4d 33       	cpi	r20, 0x3D	; 61
    477a:	09 f4       	brne	.+2      	; 0x477e <TasK4+0x44>
    477c:	5a c0       	rjmp	.+180    	; 0x4832 <TasK4+0xf8>
		{
			//LCD_KIT_voidDisplayCharacter(Recieve_Value);
			opr *= 10;
    477e:	80 91 67 07 	lds	r24, 0x0767
    4782:	8f 9d       	mul	r24, r15
    4784:	80 2d       	mov	r24, r0
    4786:	11 24       	eor	r1, r1
			opr += Recieve_Value-48;
    4788:	40 53       	subi	r20, 0x30	; 48
    478a:	48 0f       	add	r20, r24
    478c:	40 93 67 07 	sts	0x0767, r20
    4790:	a5 c0       	rjmp	.+330    	; 0x48dc <TasK4+0x1a2>
		}
		else if((Recieve_Value != '='))
		{
			switch(Previous_operator)
    4792:	80 91 12 01 	lds	r24, 0x0112
    4796:	8d 32       	cpi	r24, 0x2D	; 45
    4798:	c1 f1       	breq	.+112    	; 0x480a <TasK4+0xd0>
    479a:	8e 32       	cpi	r24, 0x2E	; 46
    479c:	30 f4       	brcc	.+12     	; 0x47aa <TasK4+0x70>
    479e:	8a 32       	cpi	r24, 0x2A	; 42
    47a0:	49 f0       	breq	.+18     	; 0x47b4 <TasK4+0x7a>
    47a2:	8b 32       	cpi	r24, 0x2B	; 43
    47a4:	09 f0       	breq	.+2      	; 0x47a8 <TasK4+0x6e>
    47a6:	40 c0       	rjmp	.+128    	; 0x4828 <TasK4+0xee>
    47a8:	23 c0       	rjmp	.+70     	; 0x47f0 <TasK4+0xb6>
    47aa:	8f 32       	cpi	r24, 0x2F	; 47
    47ac:	99 f0       	breq	.+38     	; 0x47d4 <TasK4+0x9a>
    47ae:	8e 34       	cpi	r24, 0x4E	; 78
    47b0:	d9 f5       	brne	.+118    	; 0x4828 <TasK4+0xee>
    47b2:	34 c0       	rjmp	.+104    	; 0x481c <TasK4+0xe2>
			{
			case '*': res*=opr;break;
    47b4:	80 91 67 07 	lds	r24, 0x0767
    47b8:	90 e0       	ldi	r25, 0x00	; 0
    47ba:	20 91 68 07 	lds	r18, 0x0768
    47be:	30 91 69 07 	lds	r19, 0x0769
    47c2:	bc 01       	movw	r22, r24
    47c4:	26 9f       	mul	r18, r22
    47c6:	c0 01       	movw	r24, r0
    47c8:	27 9f       	mul	r18, r23
    47ca:	90 0d       	add	r25, r0
    47cc:	36 9f       	mul	r19, r22
    47ce:	90 0d       	add	r25, r0
    47d0:	11 24       	eor	r1, r1
    47d2:	16 c0       	rjmp	.+44     	; 0x4800 <TasK4+0xc6>
			case '/': res/=opr;break;
    47d4:	60 91 67 07 	lds	r22, 0x0767
    47d8:	80 91 68 07 	lds	r24, 0x0768
    47dc:	90 91 69 07 	lds	r25, 0x0769
    47e0:	70 e0       	ldi	r23, 0x00	; 0
    47e2:	0e 94 1f 26 	call	0x4c3e	; 0x4c3e <__udivmodhi4>
    47e6:	70 93 69 07 	sts	0x0769, r23
    47ea:	60 93 68 07 	sts	0x0768, r22
    47ee:	1c c0       	rjmp	.+56     	; 0x4828 <TasK4+0xee>
			case '+': res+=opr;break;
    47f0:	20 91 67 07 	lds	r18, 0x0767
    47f4:	80 91 68 07 	lds	r24, 0x0768
    47f8:	90 91 69 07 	lds	r25, 0x0769
    47fc:	82 0f       	add	r24, r18
    47fe:	91 1d       	adc	r25, r1
    4800:	90 93 69 07 	sts	0x0769, r25
    4804:	80 93 68 07 	sts	0x0768, r24
    4808:	0f c0       	rjmp	.+30     	; 0x4828 <TasK4+0xee>
			case '-': res-=opr;break;
    480a:	20 91 67 07 	lds	r18, 0x0767
    480e:	80 91 68 07 	lds	r24, 0x0768
    4812:	90 91 69 07 	lds	r25, 0x0769
    4816:	82 1b       	sub	r24, r18
    4818:	91 09       	sbc	r25, r1
    481a:	f2 cf       	rjmp	.-28     	; 0x4800 <TasK4+0xc6>
			case 'N': res=opr;
    481c:	80 91 67 07 	lds	r24, 0x0767
    4820:	80 93 68 07 	sts	0x0768, r24
    4824:	10 92 69 07 	sts	0x0769, r1
			}
			Previous_operator = Recieve_Value;
    4828:	40 93 12 01 	sts	0x0112, r20
			opr=0;
    482c:	10 92 67 07 	sts	0x0767, r1
    4830:	55 c0       	rjmp	.+170    	; 0x48dc <TasK4+0x1a2>
		}
		else if(Recieve_Value == '=')
		{
			switch(Previous_operator)
    4832:	80 91 12 01 	lds	r24, 0x0112
    4836:	8b 32       	cpi	r24, 0x2B	; 43
    4838:	41 f1       	breq	.+80     	; 0x488a <TasK4+0x150>
    483a:	8c 32       	cpi	r24, 0x2C	; 44
    483c:	18 f4       	brcc	.+6      	; 0x4844 <TasK4+0x10a>
    483e:	8a 32       	cpi	r24, 0x2A	; 42
    4840:	c9 f5       	brne	.+114    	; 0x48b4 <TasK4+0x17a>
    4842:	05 c0       	rjmp	.+10     	; 0x484e <TasK4+0x114>
    4844:	8d 32       	cpi	r24, 0x2D	; 45
    4846:	51 f1       	breq	.+84     	; 0x489c <TasK4+0x162>
    4848:	8f 32       	cpi	r24, 0x2F	; 47
    484a:	a1 f5       	brne	.+104    	; 0x48b4 <TasK4+0x17a>
    484c:	10 c0       	rjmp	.+32     	; 0x486e <TasK4+0x134>
			{
			case '*': res*=opr;break;
    484e:	80 91 67 07 	lds	r24, 0x0767
    4852:	90 e0       	ldi	r25, 0x00	; 0
    4854:	20 91 68 07 	lds	r18, 0x0768
    4858:	30 91 69 07 	lds	r19, 0x0769
    485c:	ac 01       	movw	r20, r24
    485e:	24 9f       	mul	r18, r20
    4860:	c0 01       	movw	r24, r0
    4862:	25 9f       	mul	r18, r21
    4864:	90 0d       	add	r25, r0
    4866:	34 9f       	mul	r19, r20
    4868:	90 0d       	add	r25, r0
    486a:	11 24       	eor	r1, r1
    486c:	1f c0       	rjmp	.+62     	; 0x48ac <TasK4+0x172>
			case '/': res/=opr;break;
    486e:	60 91 67 07 	lds	r22, 0x0767
    4872:	80 91 68 07 	lds	r24, 0x0768
    4876:	90 91 69 07 	lds	r25, 0x0769
    487a:	70 e0       	ldi	r23, 0x00	; 0
    487c:	0e 94 1f 26 	call	0x4c3e	; 0x4c3e <__udivmodhi4>
    4880:	70 93 69 07 	sts	0x0769, r23
    4884:	60 93 68 07 	sts	0x0768, r22
    4888:	15 c0       	rjmp	.+42     	; 0x48b4 <TasK4+0x17a>
			case '+': res+=opr;break;
    488a:	20 91 67 07 	lds	r18, 0x0767
    488e:	80 91 68 07 	lds	r24, 0x0768
    4892:	90 91 69 07 	lds	r25, 0x0769
    4896:	82 0f       	add	r24, r18
    4898:	91 1d       	adc	r25, r1
    489a:	08 c0       	rjmp	.+16     	; 0x48ac <TasK4+0x172>
			case '-': res-=opr;break;
    489c:	20 91 67 07 	lds	r18, 0x0767
    48a0:	80 91 68 07 	lds	r24, 0x0768
    48a4:	90 91 69 07 	lds	r25, 0x0769
    48a8:	82 1b       	sub	r24, r18
    48aa:	91 09       	sbc	r25, r1
    48ac:	90 93 69 07 	sts	0x0769, r25
    48b0:	80 93 68 07 	sts	0x0768, r24
			case 'N': break;
			}

			LCD_KIT_voidDisplayBigNumber(res);
    48b4:	60 91 68 07 	lds	r22, 0x0768
    48b8:	70 91 69 07 	lds	r23, 0x0769
    48bc:	80 e0       	ldi	r24, 0x00	; 0
    48be:	90 e0       	ldi	r25, 0x00	; 0
    48c0:	0e 94 06 04 	call	0x80c	; 0x80c <LCD_KIT_voidDisplayBigNumber>

			vTaskResume(Task1_Handler);
    48c4:	80 91 5f 07 	lds	r24, 0x075F
    48c8:	90 91 60 07 	lds	r25, 0x0760
    48cc:	0e 94 d7 1d 	call	0x3bae	; 0x3bae <vTaskResume>
			vTaskSuspend(Task4_Handler);
    48d0:	80 91 65 07 	lds	r24, 0x0765
    48d4:	90 91 66 07 	lds	r25, 0x0766
    48d8:	0e 94 ef 20 	call	0x41de	; 0x41de <vTaskSuspend>
//
//			vTaskResume(Task1_Handler);
//			vTaskSuspend(Task4_Handler);
//		}

		vTaskDelay(1000);
    48dc:	88 ee       	ldi	r24, 0xE8	; 232
    48de:	93 e0       	ldi	r25, 0x03	; 3
    48e0:	0e 94 21 20 	call	0x4042	; 0x4042 <vTaskDelay>
    48e4:	37 cf       	rjmp	.-402    	; 0x4754 <TasK4+0x1a>

000048e6 <TasK3>:
		vTaskDelay(1000);
	}
}

void TasK3(  void * PTR3 )
{
    48e6:	1f 93       	push	r17
    48e8:	cf 93       	push	r28
    48ea:	df 93       	push	r29
	LCD_KIT_voidRunCommand(0x01);
    48ec:	81 e0       	ldi	r24, 0x01	; 1
    48ee:	0e 94 d7 02 	call	0x5ae	; 0x5ae <LCD_KIT_voidRunCommand>

	LCD_KIT_voidSetCurser(Line1,Col0);
    48f2:	80 e8       	ldi	r24, 0x80	; 128
    48f4:	60 e0       	ldi	r22, 0x00	; 0
    48f6:	0e 94 60 03 	call	0x6c0	; 0x6c0 <LCD_KIT_voidSetCurser>
	LCD_KIT_voidDisplayString("Enter Equation");
    48fa:	87 ea       	ldi	r24, 0xA7	; 167
    48fc:	90 e0       	ldi	r25, 0x00	; 0
    48fe:	0e 94 fb 04 	call	0x9f6	; 0x9f6 <LCD_KIT_voidDisplayString>
	LCD_KIT_voidSetCurser(Line2,Col0);
    4902:	80 ec       	ldi	r24, 0xC0	; 192
    4904:	60 e0       	ldi	r22, 0x00	; 0
    4906:	0e 94 60 03 	call	0x6c0	; 0x6c0 <LCD_KIT_voidSetCurser>
			{
				LCD_KIT_voidDisplayCharacter(Keypad[ROW][COL]);
				xSemaphoreGive( Mutex_LCD );
			}

			xQueueSendToBack( xQueue_Equation, &Keypad[ROW][COL], ( TickType_t ) 10 );
    490a:	15 e0       	ldi	r17, 0x05	; 5
    490c:	c0 e9       	ldi	r28, 0x90	; 144
    490e:	d1 e0       	ldi	r29, 0x01	; 1

	while(1)
	{
		//LCD_KIT_voidDisplayCharacter('P');

		KEYBAD_voidGetPressedKey(&ROW,&COL,&Flag);
    4910:	8f e6       	ldi	r24, 0x6F	; 111
    4912:	97 e0       	ldi	r25, 0x07	; 7
    4914:	6e e6       	ldi	r22, 0x6E	; 110
    4916:	77 e0       	ldi	r23, 0x07	; 7
    4918:	46 e7       	ldi	r20, 0x76	; 118
    491a:	57 e0       	ldi	r21, 0x07	; 7
    491c:	0e 94 80 05 	call	0xb00	; 0xb00 <KEYBAD_voidGetPressedKey>

		if(Flag==1)
    4920:	80 91 76 07 	lds	r24, 0x0776
    4924:	81 30       	cpi	r24, 0x01	; 1
    4926:	09 f0       	breq	.+2      	; 0x492a <TasK3+0x44>
    4928:	64 c0       	rjmp	.+200    	; 0x49f2 <TasK3+0x10c>
		{
			if( xSemaphoreTake(Mutex_LCD , ( TickType_t ) 10 ) == pdTRUE )
    492a:	80 91 6c 07 	lds	r24, 0x076C
    492e:	90 91 6d 07 	lds	r25, 0x076D
    4932:	6a e0       	ldi	r22, 0x0A	; 10
    4934:	70 e0       	ldi	r23, 0x00	; 0
    4936:	0e 94 08 0e 	call	0x1c10	; 0x1c10 <xQueueSemaphoreTake>
    493a:	81 30       	cpi	r24, 0x01	; 1
    493c:	f1 f4       	brne	.+60     	; 0x497a <TasK3+0x94>
			{
				LCD_KIT_voidDisplayCharacter(Keypad[ROW][COL]);
    493e:	20 91 6e 07 	lds	r18, 0x076E
    4942:	80 91 6f 07 	lds	r24, 0x076F
    4946:	90 e0       	ldi	r25, 0x00	; 0
    4948:	fc 01       	movw	r30, r24
    494a:	ee 0f       	add	r30, r30
    494c:	ff 1f       	adc	r31, r31
    494e:	ee 0f       	add	r30, r30
    4950:	ff 1f       	adc	r31, r31
    4952:	e8 0f       	add	r30, r24
    4954:	f9 1f       	adc	r31, r25
    4956:	e2 0f       	add	r30, r18
    4958:	f1 1d       	adc	r31, r1
    495a:	e7 50       	subi	r30, 0x07	; 7
    495c:	ff 4f       	sbci	r31, 0xFF	; 255
    495e:	80 81       	ld	r24, Z
    4960:	0e 94 64 03 	call	0x6c8	; 0x6c8 <LCD_KIT_voidDisplayCharacter>
				xSemaphoreGive( Mutex_LCD );
    4964:	80 91 6c 07 	lds	r24, 0x076C
    4968:	90 91 6d 07 	lds	r25, 0x076D
    496c:	60 e0       	ldi	r22, 0x00	; 0
    496e:	70 e0       	ldi	r23, 0x00	; 0
    4970:	40 e0       	ldi	r20, 0x00	; 0
    4972:	50 e0       	ldi	r21, 0x00	; 0
    4974:	20 e0       	ldi	r18, 0x00	; 0
    4976:	0e 94 4b 0d 	call	0x1a96	; 0x1a96 <xQueueGenericSend>
			}

			xQueueSendToBack( xQueue_Equation, &Keypad[ROW][COL], ( TickType_t ) 10 );
    497a:	60 91 6f 07 	lds	r22, 0x076F
    497e:	61 9f       	mul	r22, r17
    4980:	b0 01       	movw	r22, r0
    4982:	11 24       	eor	r1, r1
    4984:	80 91 6e 07 	lds	r24, 0x076E
    4988:	68 0f       	add	r22, r24
    498a:	71 1d       	adc	r23, r1
    498c:	67 50       	subi	r22, 0x07	; 7
    498e:	7f 4f       	sbci	r23, 0xFF	; 255
    4990:	80 91 74 07 	lds	r24, 0x0774
    4994:	90 91 75 07 	lds	r25, 0x0775
    4998:	4a e0       	ldi	r20, 0x0A	; 10
    499a:	50 e0       	ldi	r21, 0x00	; 0
    499c:	20 e0       	ldi	r18, 0x00	; 0
    499e:	0e 94 4b 0d 	call	0x1a96	; 0x1a96 <xQueueGenericSend>

			Flag=0;
    49a2:	10 92 76 07 	sts	0x0776, r1

			if(Keypad[ROW][COL]=='=')
    49a6:	20 91 6e 07 	lds	r18, 0x076E
    49aa:	80 91 6f 07 	lds	r24, 0x076F
    49ae:	90 e0       	ldi	r25, 0x00	; 0
    49b0:	fc 01       	movw	r30, r24
    49b2:	ee 0f       	add	r30, r30
    49b4:	ff 1f       	adc	r31, r31
    49b6:	ee 0f       	add	r30, r30
    49b8:	ff 1f       	adc	r31, r31
    49ba:	e8 0f       	add	r30, r24
    49bc:	f9 1f       	adc	r31, r25
    49be:	e2 0f       	add	r30, r18
    49c0:	f1 1d       	adc	r31, r1
    49c2:	e7 50       	subi	r30, 0x07	; 7
    49c4:	ff 4f       	sbci	r31, 0xFF	; 255
    49c6:	80 81       	ld	r24, Z
    49c8:	8d 33       	cpi	r24, 0x3D	; 61
    49ca:	61 f4       	brne	.+24     	; 0x49e4 <TasK3+0xfe>
			{
				vTaskResume(Task4_Handler);
    49cc:	80 91 65 07 	lds	r24, 0x0765
    49d0:	90 91 66 07 	lds	r25, 0x0766
    49d4:	0e 94 d7 1d 	call	0x3bae	; 0x3bae <vTaskResume>
				vTaskSuspend(Task3_Handler);
    49d8:	80 91 63 07 	lds	r24, 0x0763
    49dc:	90 91 64 07 	lds	r25, 0x0764
    49e0:	0e 94 ef 20 	call	0x41de	; 0x41de <vTaskSuspend>
    49e4:	88 ee       	ldi	r24, 0xE8	; 232
    49e6:	93 e0       	ldi	r25, 0x03	; 3
    49e8:	fe 01       	movw	r30, r28
    49ea:	31 97       	sbiw	r30, 0x01	; 1
    49ec:	f1 f7       	brne	.-4      	; 0x49ea <TasK3+0x104>
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    49ee:	01 97       	sbiw	r24, 0x01	; 1
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    49f0:	d9 f7       	brne	.-10     	; 0x49e8 <TasK3+0x102>
			}

			_delay_ms(100);
		}

		vTaskDelay(1000);
    49f2:	88 ee       	ldi	r24, 0xE8	; 232
    49f4:	93 e0       	ldi	r25, 0x03	; 3
    49f6:	0e 94 21 20 	call	0x4042	; 0x4042 <vTaskDelay>
    49fa:	8a cf       	rjmp	.-236    	; 0x4910 <TasK3+0x2a>

000049fc <TasK2>:
		vTaskDelay(1000);
	}
}

void TasK2(  void * PTR2 )
{
    49fc:	cf 92       	push	r12
    49fe:	df 92       	push	r13
    4a00:	ef 92       	push	r14
    4a02:	ff 92       	push	r15
    4a04:	0f 93       	push	r16
    4a06:	1f 93       	push	r17
    4a08:	df 93       	push	r29
    4a0a:	cf 93       	push	r28
    4a0c:	0f 92       	push	r0
    4a0e:	cd b7       	in	r28, 0x3d	; 61
    4a10:	de b7       	in	r29, 0x3e	; 62
    4a12:	00 e0       	ldi	r16, 0x00	; 0
    4a14:	10 e0       	ldi	r17, 0x00	; 0
    4a16:	80 e9       	ldi	r24, 0x90	; 144
    4a18:	c8 2e       	mov	r12, r24
    4a1a:	81 e0       	ldi	r24, 0x01	; 1
    4a1c:	d8 2e       	mov	r13, r24
	{
		Error_Flag=0;

		for(u8 i=0;i<5;i++)
		{
			xQueueReceive( xQueue_Password, &Recieve_Value, ( TickType_t ) 10 );
    4a1e:	7e 01       	movw	r14, r28
    4a20:	08 94       	sec
    4a22:	e1 1c       	adc	r14, r1
    4a24:	f1 1c       	adc	r15, r1
    4a26:	12 c0       	rjmp	.+36     	; 0x4a4c <TasK2+0x50>
    4a28:	80 91 70 07 	lds	r24, 0x0770
    4a2c:	90 91 71 07 	lds	r25, 0x0771
    4a30:	b7 01       	movw	r22, r14
    4a32:	4a e0       	ldi	r20, 0x0A	; 10
    4a34:	50 e0       	ldi	r21, 0x00	; 0
    4a36:	0e 94 10 0c 	call	0x1820	; 0x1820 <xQueueReceive>
			if(Recieve_Value != Password[i])
    4a3a:	e1 2f       	mov	r30, r17
    4a3c:	f0 e0       	ldi	r31, 0x00	; 0
    4a3e:	e3 5f       	subi	r30, 0xF3	; 243
    4a40:	fe 4f       	sbci	r31, 0xFE	; 254
    4a42:	99 81       	ldd	r25, Y+1	; 0x01
    4a44:	80 81       	ld	r24, Z
    4a46:	98 13       	cpse	r25, r24
    4a48:	01 e0       	ldi	r16, 0x01	; 1
	u8 Error_Flag;
	while(1)
	{
		Error_Flag=0;

		for(u8 i=0;i<5;i++)
    4a4a:	1f 5f       	subi	r17, 0xFF	; 255
    4a4c:	15 30       	cpi	r17, 0x05	; 5
    4a4e:	60 f3       	brcs	.-40     	; 0x4a28 <TasK2+0x2c>
			}
		}

		//_delay_ms(1000);

		LCD_KIT_voidRunCommand(0x01);
    4a50:	81 e0       	ldi	r24, 0x01	; 1
    4a52:	0e 94 d7 02 	call	0x5ae	; 0x5ae <LCD_KIT_voidRunCommand>
		Queue_Index=0;
    4a56:	10 92 5e 07 	sts	0x075E, r1

		if(!Error_Flag)
    4a5a:	00 23       	and	r16, r16
    4a5c:	69 f4       	brne	.+26     	; 0x4a78 <TasK2+0x7c>
		{
			uxBits = xEventGroupSetBits( xEventGroup, Flag_Pass );
    4a5e:	80 91 6a 07 	lds	r24, 0x076A
    4a62:	90 91 6b 07 	lds	r25, 0x076B
    4a66:	60 e2       	ldi	r22, 0x20	; 32
    4a68:	70 e0       	ldi	r23, 0x00	; 0
    4a6a:	0e 94 42 06 	call	0xc84	; 0xc84 <xEventGroupSetBits>
    4a6e:	90 93 73 07 	sts	0x0773, r25
    4a72:	80 93 72 07 	sts	0x0772, r24
    4a76:	1a c0       	rjmp	.+52     	; 0x4aac <TasK2+0xb0>
		}
		else
		{
			LCD_KIT_voidSetCurser(Line1,Col0);
    4a78:	80 e8       	ldi	r24, 0x80	; 128
    4a7a:	60 e0       	ldi	r22, 0x00	; 0
    4a7c:	0e 94 60 03 	call	0x6c0	; 0x6c0 <LCD_KIT_voidSetCurser>
			LCD_KIT_voidDisplayString("Wrong Password");
    4a80:	86 eb       	ldi	r24, 0xB6	; 182
    4a82:	90 e0       	ldi	r25, 0x00	; 0
    4a84:	0e 94 fb 04 	call	0x9f6	; 0x9f6 <LCD_KIT_voidDisplayString>
    4a88:	88 e8       	ldi	r24, 0x88	; 136
    4a8a:	93 e1       	ldi	r25, 0x13	; 19
    4a8c:	f6 01       	movw	r30, r12
    4a8e:	31 97       	sbiw	r30, 0x01	; 1
    4a90:	f1 f7       	brne	.-4      	; 0x4a8e <TasK2+0x92>
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    4a92:	01 97       	sbiw	r24, 0x01	; 1
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    4a94:	d9 f7       	brne	.-10     	; 0x4a8c <TasK2+0x90>
			_delay_ms(500);
			LCD_KIT_voidRunCommand(0x01);
    4a96:	81 e0       	ldi	r24, 0x01	; 1
    4a98:	0e 94 d7 02 	call	0x5ae	; 0x5ae <LCD_KIT_voidRunCommand>
			LCD_KIT_voidDisplayString("Enter Password");
    4a9c:	85 ec       	ldi	r24, 0xC5	; 197
    4a9e:	90 e0       	ldi	r25, 0x00	; 0
    4aa0:	0e 94 fb 04 	call	0x9f6	; 0x9f6 <LCD_KIT_voidDisplayString>
			LCD_KIT_voidSetCurser(Line2,Col0);
    4aa4:	80 ec       	ldi	r24, 0xC0	; 192
    4aa6:	60 e0       	ldi	r22, 0x00	; 0
    4aa8:	0e 94 60 03 	call	0x6c0	; 0x6c0 <LCD_KIT_voidSetCurser>
		}

		vTaskResume(Task1_Handler);
    4aac:	80 91 5f 07 	lds	r24, 0x075F
    4ab0:	90 91 60 07 	lds	r25, 0x0760
    4ab4:	0e 94 d7 1d 	call	0x3bae	; 0x3bae <vTaskResume>
		vTaskSuspend(Task2_Handler);
    4ab8:	80 91 61 07 	lds	r24, 0x0761
    4abc:	90 91 62 07 	lds	r25, 0x0762
    4ac0:	0e 94 ef 20 	call	0x41de	; 0x41de <vTaskSuspend>

		vTaskDelay(1000);
    4ac4:	88 ee       	ldi	r24, 0xE8	; 232
    4ac6:	93 e0       	ldi	r25, 0x03	; 3
    4ac8:	0e 94 21 20 	call	0x4042	; 0x4042 <vTaskDelay>
    4acc:	00 e0       	ldi	r16, 0x00	; 0
    4ace:	10 e0       	ldi	r17, 0x00	; 0
    4ad0:	ab cf       	rjmp	.-170    	; 0x4a28 <TasK2+0x2c>

00004ad2 <TasK1>:
TaskHandle_t * Task2_Handler = NULL;
TaskHandle_t * Task3_Handler = NULL;
TaskHandle_t * Task4_Handler = NULL;

void TasK1(  void * PTR1 )
{
    4ad2:	ff 92       	push	r15
    4ad4:	0f 93       	push	r16
    4ad6:	1f 93       	push	r17
    4ad8:	cf 93       	push	r28
    4ada:	df 93       	push	r29
	LCD_KIT_voidSetCurser(Line1,Col0);
    4adc:	80 e8       	ldi	r24, 0x80	; 128
    4ade:	60 e0       	ldi	r22, 0x00	; 0
    4ae0:	0e 94 60 03 	call	0x6c0	; 0x6c0 <LCD_KIT_voidSetCurser>
	LCD_KIT_voidDisplayString("Enter the Password");
    4ae4:	84 ed       	ldi	r24, 0xD4	; 212
    4ae6:	90 e0       	ldi	r25, 0x00	; 0
    4ae8:	0e 94 fb 04 	call	0x9f6	; 0x9f6 <LCD_KIT_voidDisplayString>
	LCD_KIT_voidSetCurser(Line2,Col0);
    4aec:	80 ec       	ldi	r24, 0xC0	; 192
    4aee:	60 e0       	ldi	r22, 0x00	; 0
    4af0:	0e 94 60 03 	call	0x6c0	; 0x6c0 <LCD_KIT_voidSetCurser>
    4af4:	c0 e9       	ldi	r28, 0x90	; 144
    4af6:	d1 e0       	ldi	r29, 0x01	; 1
				xSemaphoreGive( Mutex_LCD );
			}

			if(Queue_Index<5)
			{
				xQueueSendToBack( xQueue_Password, &Keypad[ROW][COL], ( TickType_t ) 10 );
    4af8:	45 e0       	ldi	r20, 0x05	; 5
    4afa:	f4 2e       	mov	r15, r20

	while(1)
	{
		//LCD_KIT_voidDisplayCharacter('L');

		uxBits = xEventGroupWaitBits( xEventGroup, Flag_Pass, pdTRUE, pdFALSE, ( TickType_t ) 10 );
    4afc:	80 91 6a 07 	lds	r24, 0x076A
    4b00:	90 91 6b 07 	lds	r25, 0x076B
    4b04:	60 e2       	ldi	r22, 0x20	; 32
    4b06:	70 e0       	ldi	r23, 0x00	; 0
    4b08:	41 e0       	ldi	r20, 0x01	; 1
    4b0a:	20 e0       	ldi	r18, 0x00	; 0
    4b0c:	0a e0       	ldi	r16, 0x0A	; 10
    4b0e:	10 e0       	ldi	r17, 0x00	; 0
    4b10:	0e 94 b5 06 	call	0xd6a	; 0xd6a <xEventGroupWaitBits>
    4b14:	80 93 72 07 	sts	0x0772, r24
    4b18:	90 93 73 07 	sts	0x0773, r25
		if( uxBits & Flag_Pass )
    4b1c:	85 ff       	sbrs	r24, 5
    4b1e:	1f c0       	rjmp	.+62     	; 0x4b5e <TasK1+0x8c>
		{
			//LCD_KIT_voidDisplayCharacter('K');

			LCD_KIT_voidSetCurser(Line1,Col0);
    4b20:	80 e8       	ldi	r24, 0x80	; 128
    4b22:	60 e0       	ldi	r22, 0x00	; 0
    4b24:	0e 94 60 03 	call	0x6c0	; 0x6c0 <LCD_KIT_voidSetCurser>
			LCD_KIT_voidDisplayString("Correct Password");
    4b28:	87 ee       	ldi	r24, 0xE7	; 231
    4b2a:	90 e0       	ldi	r25, 0x00	; 0
    4b2c:	0e 94 fb 04 	call	0x9f6	; 0x9f6 <LCD_KIT_voidDisplayString>
			LCD_KIT_voidSetCurser(Line2,Col0);
    4b30:	80 ec       	ldi	r24, 0xC0	; 192
    4b32:	60 e0       	ldi	r22, 0x00	; 0
    4b34:	0e 94 60 03 	call	0x6c0	; 0x6c0 <LCD_KIT_voidSetCurser>
    4b38:	88 e8       	ldi	r24, 0x88	; 136
    4b3a:	93 e1       	ldi	r25, 0x13	; 19
    4b3c:	fe 01       	movw	r30, r28
    4b3e:	31 97       	sbiw	r30, 0x01	; 1
    4b40:	f1 f7       	brne	.-4      	; 0x4b3e <TasK1+0x6c>
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    4b42:	01 97       	sbiw	r24, 0x01	; 1
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    4b44:	d9 f7       	brne	.-10     	; 0x4b3c <TasK1+0x6a>
			_delay_ms(500);

			vTaskResume(Task3_Handler);
    4b46:	80 91 63 07 	lds	r24, 0x0763
    4b4a:	90 91 64 07 	lds	r25, 0x0764
    4b4e:	0e 94 d7 1d 	call	0x3bae	; 0x3bae <vTaskResume>
			vTaskSuspend(Task1_Handler);
    4b52:	80 91 5f 07 	lds	r24, 0x075F
    4b56:	90 91 60 07 	lds	r25, 0x0760
    4b5a:	0e 94 ef 20 	call	0x41de	; 0x41de <vTaskSuspend>
		}

		KEYBAD_voidGetPressedKey(&ROW,&COL,&Flag);
    4b5e:	8f e6       	ldi	r24, 0x6F	; 111
    4b60:	97 e0       	ldi	r25, 0x07	; 7
    4b62:	6e e6       	ldi	r22, 0x6E	; 110
    4b64:	77 e0       	ldi	r23, 0x07	; 7
    4b66:	46 e7       	ldi	r20, 0x76	; 118
    4b68:	57 e0       	ldi	r21, 0x07	; 7
    4b6a:	0e 94 80 05 	call	0xb00	; 0xb00 <KEYBAD_voidGetPressedKey>

		if(Flag==1)
    4b6e:	80 91 76 07 	lds	r24, 0x0776
    4b72:	81 30       	cpi	r24, 0x01	; 1
    4b74:	09 f0       	breq	.+2      	; 0x4b78 <TasK1+0xa6>
    4b76:	5e c0       	rjmp	.+188    	; 0x4c34 <TasK1+0x162>
		{
			Flag=0;
    4b78:	10 92 76 07 	sts	0x0776, r1

			if( xSemaphoreTake(Mutex_LCD , ( TickType_t ) 10 ) == pdTRUE )
    4b7c:	80 91 6c 07 	lds	r24, 0x076C
    4b80:	90 91 6d 07 	lds	r25, 0x076D
    4b84:	6a e0       	ldi	r22, 0x0A	; 10
    4b86:	70 e0       	ldi	r23, 0x00	; 0
    4b88:	0e 94 08 0e 	call	0x1c10	; 0x1c10 <xQueueSemaphoreTake>
    4b8c:	81 30       	cpi	r24, 0x01	; 1
    4b8e:	f1 f4       	brne	.+60     	; 0x4bcc <TasK1+0xfa>
			{
				LCD_KIT_voidDisplayCharacter(Keypad[ROW][COL]);
    4b90:	20 91 6e 07 	lds	r18, 0x076E
    4b94:	80 91 6f 07 	lds	r24, 0x076F
    4b98:	90 e0       	ldi	r25, 0x00	; 0
    4b9a:	fc 01       	movw	r30, r24
    4b9c:	ee 0f       	add	r30, r30
    4b9e:	ff 1f       	adc	r31, r31
    4ba0:	ee 0f       	add	r30, r30
    4ba2:	ff 1f       	adc	r31, r31
    4ba4:	e8 0f       	add	r30, r24
    4ba6:	f9 1f       	adc	r31, r25
    4ba8:	e2 0f       	add	r30, r18
    4baa:	f1 1d       	adc	r31, r1
    4bac:	e7 50       	subi	r30, 0x07	; 7
    4bae:	ff 4f       	sbci	r31, 0xFF	; 255
    4bb0:	80 81       	ld	r24, Z
    4bb2:	0e 94 64 03 	call	0x6c8	; 0x6c8 <LCD_KIT_voidDisplayCharacter>
				xSemaphoreGive( Mutex_LCD );
    4bb6:	80 91 6c 07 	lds	r24, 0x076C
    4bba:	90 91 6d 07 	lds	r25, 0x076D
    4bbe:	60 e0       	ldi	r22, 0x00	; 0
    4bc0:	70 e0       	ldi	r23, 0x00	; 0
    4bc2:	40 e0       	ldi	r20, 0x00	; 0
    4bc4:	50 e0       	ldi	r21, 0x00	; 0
    4bc6:	20 e0       	ldi	r18, 0x00	; 0
    4bc8:	0e 94 4b 0d 	call	0x1a96	; 0x1a96 <xQueueGenericSend>
			}

			if(Queue_Index<5)
    4bcc:	80 91 5e 07 	lds	r24, 0x075E
    4bd0:	85 30       	cpi	r24, 0x05	; 5
    4bd2:	c8 f4       	brcc	.+50     	; 0x4c06 <TasK1+0x134>
			{
				xQueueSendToBack( xQueue_Password, &Keypad[ROW][COL], ( TickType_t ) 10 );
    4bd4:	60 91 6f 07 	lds	r22, 0x076F
    4bd8:	6f 9d       	mul	r22, r15
    4bda:	b0 01       	movw	r22, r0
    4bdc:	11 24       	eor	r1, r1
    4bde:	80 91 6e 07 	lds	r24, 0x076E
    4be2:	68 0f       	add	r22, r24
    4be4:	71 1d       	adc	r23, r1
    4be6:	67 50       	subi	r22, 0x07	; 7
    4be8:	7f 4f       	sbci	r23, 0xFF	; 255
    4bea:	80 91 70 07 	lds	r24, 0x0770
    4bee:	90 91 71 07 	lds	r25, 0x0771
    4bf2:	4a e0       	ldi	r20, 0x0A	; 10
    4bf4:	50 e0       	ldi	r21, 0x00	; 0
    4bf6:	20 e0       	ldi	r18, 0x00	; 0
    4bf8:	0e 94 4b 0d 	call	0x1a96	; 0x1a96 <xQueueGenericSend>

//				u8 Recieve_Value;
//				xQueueReceive( xQueue_Password, &Recieve_Value, ( TickType_t ) 10 );
//				LCD_KIT_voidDisplayBigNumber(Recieve_Value);

				Queue_Index++;
    4bfc:	80 91 5e 07 	lds	r24, 0x075E
    4c00:	8f 5f       	subi	r24, 0xFF	; 255
    4c02:	80 93 5e 07 	sts	0x075E, r24
    4c06:	88 ee       	ldi	r24, 0xE8	; 232
    4c08:	93 e0       	ldi	r25, 0x03	; 3
    4c0a:	fe 01       	movw	r30, r28
    4c0c:	31 97       	sbiw	r30, 0x01	; 1
    4c0e:	f1 f7       	brne	.-4      	; 0x4c0c <TasK1+0x13a>
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    4c10:	01 97       	sbiw	r24, 0x01	; 1
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    4c12:	d9 f7       	brne	.-10     	; 0x4c0a <TasK1+0x138>
			}

			_delay_ms(100);

			if(Queue_Index==5)
    4c14:	80 91 5e 07 	lds	r24, 0x075E
    4c18:	85 30       	cpi	r24, 0x05	; 5
    4c1a:	61 f4       	brne	.+24     	; 0x4c34 <TasK1+0x162>
			{
				vTaskResume(Task2_Handler);
    4c1c:	80 91 61 07 	lds	r24, 0x0761
    4c20:	90 91 62 07 	lds	r25, 0x0762
    4c24:	0e 94 d7 1d 	call	0x3bae	; 0x3bae <vTaskResume>
				vTaskSuspend(Task1_Handler);
    4c28:	80 91 5f 07 	lds	r24, 0x075F
    4c2c:	90 91 60 07 	lds	r25, 0x0760
    4c30:	0e 94 ef 20 	call	0x41de	; 0x41de <vTaskSuspend>
			}

		}

		vTaskDelay(1000);
    4c34:	88 ee       	ldi	r24, 0xE8	; 232
    4c36:	93 e0       	ldi	r25, 0x03	; 3
    4c38:	0e 94 21 20 	call	0x4042	; 0x4042 <vTaskDelay>
    4c3c:	5f cf       	rjmp	.-322    	; 0x4afc <TasK1+0x2a>

00004c3e <__udivmodhi4>:
    4c3e:	aa 1b       	sub	r26, r26
    4c40:	bb 1b       	sub	r27, r27
    4c42:	51 e1       	ldi	r21, 0x11	; 17
    4c44:	07 c0       	rjmp	.+14     	; 0x4c54 <__udivmodhi4_ep>

00004c46 <__udivmodhi4_loop>:
    4c46:	aa 1f       	adc	r26, r26
    4c48:	bb 1f       	adc	r27, r27
    4c4a:	a6 17       	cp	r26, r22
    4c4c:	b7 07       	cpc	r27, r23
    4c4e:	10 f0       	brcs	.+4      	; 0x4c54 <__udivmodhi4_ep>
    4c50:	a6 1b       	sub	r26, r22
    4c52:	b7 0b       	sbc	r27, r23

00004c54 <__udivmodhi4_ep>:
    4c54:	88 1f       	adc	r24, r24
    4c56:	99 1f       	adc	r25, r25
    4c58:	5a 95       	dec	r21
    4c5a:	a9 f7       	brne	.-22     	; 0x4c46 <__udivmodhi4_loop>
    4c5c:	80 95       	com	r24
    4c5e:	90 95       	com	r25
    4c60:	bc 01       	movw	r22, r24
    4c62:	cd 01       	movw	r24, r26
    4c64:	08 95       	ret

00004c66 <__udivmodsi4>:
    4c66:	a1 e2       	ldi	r26, 0x21	; 33
    4c68:	1a 2e       	mov	r1, r26
    4c6a:	aa 1b       	sub	r26, r26
    4c6c:	bb 1b       	sub	r27, r27
    4c6e:	fd 01       	movw	r30, r26
    4c70:	0d c0       	rjmp	.+26     	; 0x4c8c <__udivmodsi4_ep>

00004c72 <__udivmodsi4_loop>:
    4c72:	aa 1f       	adc	r26, r26
    4c74:	bb 1f       	adc	r27, r27
    4c76:	ee 1f       	adc	r30, r30
    4c78:	ff 1f       	adc	r31, r31
    4c7a:	a2 17       	cp	r26, r18
    4c7c:	b3 07       	cpc	r27, r19
    4c7e:	e4 07       	cpc	r30, r20
    4c80:	f5 07       	cpc	r31, r21
    4c82:	20 f0       	brcs	.+8      	; 0x4c8c <__udivmodsi4_ep>
    4c84:	a2 1b       	sub	r26, r18
    4c86:	b3 0b       	sbc	r27, r19
    4c88:	e4 0b       	sbc	r30, r20
    4c8a:	f5 0b       	sbc	r31, r21

00004c8c <__udivmodsi4_ep>:
    4c8c:	66 1f       	adc	r22, r22
    4c8e:	77 1f       	adc	r23, r23
    4c90:	88 1f       	adc	r24, r24
    4c92:	99 1f       	adc	r25, r25
    4c94:	1a 94       	dec	r1
    4c96:	69 f7       	brne	.-38     	; 0x4c72 <__udivmodsi4_loop>
    4c98:	60 95       	com	r22
    4c9a:	70 95       	com	r23
    4c9c:	80 95       	com	r24
    4c9e:	90 95       	com	r25
    4ca0:	9b 01       	movw	r18, r22
    4ca2:	ac 01       	movw	r20, r24
    4ca4:	bd 01       	movw	r22, r26
    4ca6:	cf 01       	movw	r24, r30
    4ca8:	08 95       	ret

00004caa <memcpy>:
    4caa:	fb 01       	movw	r30, r22
    4cac:	dc 01       	movw	r26, r24
    4cae:	02 c0       	rjmp	.+4      	; 0x4cb4 <memcpy+0xa>
    4cb0:	01 90       	ld	r0, Z+
    4cb2:	0d 92       	st	X+, r0
    4cb4:	41 50       	subi	r20, 0x01	; 1
    4cb6:	50 40       	sbci	r21, 0x00	; 0
    4cb8:	d8 f7       	brcc	.-10     	; 0x4cb0 <memcpy+0x6>
    4cba:	08 95       	ret

00004cbc <_exit>:
    4cbc:	f8 94       	cli

00004cbe <__stop_program>:
    4cbe:	ff cf       	rjmp	.-2      	; 0x4cbe <__stop_program>
